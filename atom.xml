<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>莯滢</title>
  
  <subtitle>不念过往、不负当下、不畏将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://onlyangelia.github.io/"/>
  <updated>2019-05-08T13:08:52.282Z</updated>
  <id>https://onlyangelia.github.io/</id>
  
  <author>
    <name>莯滢</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python运算(五)统计statistic模块</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonCaculationsStatisticModule/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonCaculationsStatisticModule/</id>
    <published>2018-05-03T14:44:39.000Z</published>
    <updated>2019-05-08T13:08:52.282Z</updated>
    
    <content type="html"><![CDATA[<p><strong>statistics</strong>模块为具有数字特性的数据提供数学统计计算函数，若无明确指明，支持的数据类型 <strong>int</strong>, <strong>float</strong>, <strong>decimal.Decimal</strong> 和 <strong>fractions.Fraction</strong>。其它类型暂不支持，混合类型也不能独立操作，如果 输入的数据是混合类型，必须用<code>map()</code>函数转换成可识别的类型<code>map(float, inpud_data)</code>。 <strong>statistics</strong>模块中的统计函数有：</p><h2 id="平均-amp-中位数函数-平均值、中位数等"><a href="#平均-amp-中位数函数-平均值、中位数等" class="headerlink" title="平均&amp;中位数函数(平均值、中位数等)"></a>平均&amp;中位数函数(平均值、中位数等)</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>statistic.<strong>mean</strong>()</td><td>返回数据的算术平均值，如果数据为空，则会触发<a href="https://docs.python.org/zh-cn/3.6/library/statistics.html#statistics.StatisticsError"><code>StatisticsError</code></a>。算术平均值容易受到异常值的影响，并不是一个稳定的估量值。</td></tr><tr><td>statistic.<strong>harmonic_mean</strong>()</td><td>返回调和优化平均值。调和平均值又被称为倒数平均值，是算术平均值的倒数。计算形式如下：数据a，b，c 的调和平均值为$\dfrac{3}{\dfrac{1}{a} + \dfrac{1}{b} + \dfrac{1}{c}}$     如果数据为空，或数据存在负数，同样会触发<a href="https://docs.python.org/zh-cn/3.6/library/statistics.html#statistics.StatisticsError"><code>StatisticsError</code></a></td></tr><tr><td>statistic.<strong>median</strong>()</td><td>返回数据的中位数，如果数据总和为偶数，则返回中间两个数字的平均值。中位数比较稳定，不太容易受异常数据的影响。如果数据为空，同样会触发<a href="https://docs.python.org/zh-cn/3.6/library/statistics.html#statistics.StatisticsError"><code>StatisticsError</code></a></td></tr><tr><td>statistic.<strong>median_low</strong>()</td><td>返回较低平均值，当数据总数为偶数时，取中间位置较小的数值</td></tr><tr><td>statistic.<strong>median_high</strong>()</td><td>返回较高平均值，当数据总数为偶数时，取中间位置较大的数值</td></tr><tr><td>statistic.<strong>median_grouped</strong>(data, interval = 1)</td><td>返回分组连续数据的中位数，以50%位数计算，interval代表计算间距，默认为1</td></tr><tr><td>statistic.<strong>media_mode</strong>()</td><td>返回出现频率最高的数值</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import statistics&gt;&gt;&gt; statistics.mean([23.4,47.2,56.45,65.8])48.2125&gt;&gt;&gt; statistics.harmonic_mean([2.4, 3.6, 12.3])3.867248908296943&gt;&gt;&gt; statistics.median([12,4,6,8,9,14,35])9&gt;&gt;&gt; statistics.median([1,3,5,7])4.0&gt;&gt;&gt; statistics.median_low([1,3,5,7])3&gt;&gt;&gt; statistics.median_high([1,3,5,7])5&gt;&gt;&gt; statistics.median_grouped([52,52,53,54])52.5&gt;&gt;&gt; statistics.median_grouped([1,2,2,3,4,4,4,4,4,5])3.7&gt;&gt;&gt; statistics.median_grouped([1,3,5,7], interval =1)4.5&gt;&gt;&gt; statistics.median_grouped([1,3,5,7], interval = 2)4.0&gt;&gt;&gt; statistics.mode([1,1,2,3,3,3,3,4])3&gt;&gt;&gt; statistics.mode([&#39;red&#39;,&#39;blue&#39;,&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;,&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;,&#39;red&#39;])&#39;red&#39;</code></pre><h2 id="分布函数-方差、标准差等"><a href="#分布函数-方差、标准差等" class="headerlink" title="分布函数(方差、标准差等)"></a>分布函数(方差、标准差等)</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>statistics.<strong>pstdev</strong>(data, mu=None)</td><td>返回数据的总体标准差，mu为平均值，如果给值则用指定的数值，如果没有指定，则自动计算</td></tr><tr><td>statistics.<strong>pvariance</strong>(data, mu=None)</td><td>返回数据的总体方差,mu为平均值，如果指定数据则用给定值，如果未给出，则自动计算</td></tr><tr><td>statistics.<strong>stdev</strong>(data, xbar=None)</td><td>返回数据的样品标准差，xbar如果指定则用给的值，如果没有指定则自动计算。</td></tr><tr><td>statistics.<strong>variance</strong>(data, xbar=None)</td><td>返回样本方差，如果指定xbar则用给的值，如果没有给出，则自动计算</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; statistics.pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])0.986893273527251&gt;&gt;&gt; statistics.pvariance([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])0.9739583333333334&gt;&gt;&gt; statistics.stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])1.0810874155219827&gt;&gt;&gt; statistics.variance([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])1.16875</code></pre><p>有关Python针对数据的运算各个类型数据的运算和相关的算术模块整理完毕，正因为Python对数据运算处理的庞大，使得Python在数据分析之中占有重要的位置。同时有许多外置框架将Python数据结构改良和对统计模块的扩展，例如Numpy、Pandas等，非常方便数据清洗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;statistics&lt;/strong&gt;模块为具有数字特性的数据提供数学统计计算函数，若无明确指明，支持的数据类型 &lt;strong&gt;int&lt;/strong&gt;, &lt;strong&gt;float&lt;/strong&gt;, &lt;strong&gt;decimal.Decimal&lt;/s
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python运算(四)random模块&amp;secrets模块</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculationsRandomAndSecrets/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculationsRandomAndSecrets/</id>
    <published>2018-05-03T10:52:27.000Z</published>
    <updated>2019-05-08T10:41:14.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h1><p><strong>random</strong>模块实现了这种分布的伪随机数生成器，随机数可以被应用于数学、安全等领域，并且也经常被嵌入算法中，用以提高算法效率，在机器学习算法中对随机数的设定是必要的一步，并且随机数的设定会影响算法的好坏。</p><p><strong>random</strong>模块提供的函数是基于random.Random类的隐藏实例的绑定方法，几乎所有模块函数都依赖于基本函数<code>random()</code>，<code>random()</code>函数在半开放区间[0.0, 1.0)内均匀生成随机浮点数。用Randon类作为子类，重写 <code>random()</code> 、 <code>seed()</code> 、 <code>getstate()</code> 以及 <code>setstate()</code> 方法可以自己设计不同随机生成器。</p><p><strong>random</strong>针对整数，范围有统一的选择；针对序列，随机元素统一选择、存在用于生成列表的随机排列函数，以及用于随机抽样而无需替换的函数；针对实数轴，有计算<strong>均匀、正态(高斯)、对数正态、负指数、伽马和贝塔分布</strong>的函数，生成角度分布，可以使用<strong>von Mises</strong>分布。</p><h2 id="Bookkeeping-函数"><a href="#Bookkeeping-函数" class="headerlink" title="Bookkeeping 函数"></a>Bookkeeping 函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>random.<strong>seed</strong>(a=None, version=2)</td><td>初始化随机数生成器，如果a被省略为或为None，则使用当前系统时间。如果提供随机源，则使用提供的随机源，如果a是int类型，则直接使用。</td></tr><tr><td>random.<strong>getstate</strong>()</td><td>捕获随机生成器当前内部状态的对象，可以将该对象传递给setstate()来恢复状态</td></tr><tr><td>random.<strong>setstate</strong>(state)</td><td>state是调用getstate()获得，并且setstate()将生成器的内部状态恢复到getstate()被调用时候的状态</td></tr><tr><td>random.<strong>getrandbits</strong>(k)</td><td>返回带有K位随机的Python整数，此方法随MersenneTwister生成器一起提供其他一些生成器也可以将其作为API的可选部分提供(注：Python 使用 Mersenne Twister 作为核心生成器。 它产生 53 位精度浮点数，周期为 2**19937-1)。</td></tr></tbody></table><h2 id="整数随机函数"><a href="#整数随机函数" class="headerlink" title="整数随机函数"></a>整数随机函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>random.<strong>randrange</strong>(stop)</td><td>返回不高于stop的一个随机数</td></tr><tr><td>random.<strong>randrange</strong>(start, stop, step)</td><td>从 <code>range(start, stop, step)</code> 返回一个随机选择的元素，相当于 <code>choice(range(start, stop, step))</code> ，但实际上并没有构建一个 range 对象，<em>在 3.2 版更改:</em> <a href="https://docs.python.org/zh-cn/3.6/library/random.html#random.randrange"><code>randrange()</code></a> 在生成均匀分布的值方面更为复杂</td></tr><tr><td>random.<strong>randint</strong>(a,b)</td><td>返回随机满足a&lt;=N&lt;=b的随机整数N。相当于 <code>randrange(a, b+1)</code></td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import random&gt;&gt;&gt; random.randrange(100)94&gt;&gt;&gt; random.randrange(0, 100, 3)81&gt;&gt;&gt; random.randint(0, 10)4</code></pre><h2 id="序列随机函数"><a href="#序列随机函数" class="headerlink" title="序列随机函数"></a>序列随机函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>random.<strong>choice</strong>(seq)</td><td>从非空序列 <em>seq</em> 返回一个随机元素。 如果 <em>seq</em> 为空，则引发 <a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#IndexError"><code>IndexError</code></a></td></tr><tr><td>random.<strong>choices</strong>(population, weights =None, *, cum_weights=None, k = 1 )</td><td>从<em>population</em>中选择替换，返回大小为 <em>k</em> 的元素列表。 如果 <em>population</em> 为空，则引发 IndexError。如果指定了weight序列，则根据相对权重进行选择。或者，如果给出 <em>cum_weights</em> 序列，则根据累积权重（可能使用 <a href="https://docs.python.org/zh-cn/3.6/library/itertools.html#itertools.accumulate"><code>itertools.accumulate()</code></a> 计算）进行选择。 例如，相对权重<code>[10, 5, 30, 5]</code>相当于累积权重<code>[10, 15, 45, 50]</code>。 在内部，相对权重在进行选择之前会转换为累积权重，因此提供累积权重可以节省工作量。如果既未指定 <em>weight</em> 也未指定 <em>cum_weights</em> ，则以相等的概率进行选择。 如果提供了权重序列，则它必须与 <em>population</em> 序列的长度相同。<em>weights</em> 或 <em>cum_weights</em> 可以使用任何与 <a href="https://docs.python.org/zh-cn/3.6/library/random.html#module-random"><code>random()</code></a> 返回的 <a href="https://docs.python.org/zh-cn/3.6/library/functions.html#float"><code>float</code></a> 值互操作的数值类型（包括整数，浮点数和分数但不包括十进制小数</td></tr><tr><td>random.<strong>shuffle</strong>(x, random)</td><td>将序列x随机打乱位置。可选参数 <em>random</em> 是一个0参数函数，在 [0.0, 1.0) 中返回随机浮点数；默认情况下，这是函数 <a href="https://docs.python.org/zh-cn/3.6/library/random.html#random.random"><code>random()</code></a> 。要改变一个不可变的序列并返回一个新的打乱列表，请使用<code>sample(x, k=len(x))</code>。</td></tr><tr><td>random.<strong>sample</strong>(poplation, k)</td><td>返回从总体序列或集合中选择的唯一元素的 <em>k</em> 长度列表。 用于无重复的随机抽样。返回包含来自总体的元素的新列表，同时保持原始总体不变。 结果列表按选择顺序排列，因此所有子切片也将是有效的随机样本。 这允许抽奖获奖者（样本）被划分为大奖和第二名获胜者（子切片）。要从一系列整数中选择样本，请使用 <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#range"><code>range()</code></a> 对象作为参数。 对于从大量人群中采样，这种方法特别快速且节省空间：<code>sample(range(10000000), k=60)</code> 。</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; random.choice([&#39;win&#39;, &#39;lose&#39;, &#39;draw&#39;])&#39;lose&#39;&gt;&gt;&gt; deck = &#39;one two three foure&#39;.split()&gt;&gt;&gt; random.shuffle(deck)&gt;&gt;&gt; deck[&#39;three&#39;, &#39;two&#39;, &#39;one&#39;, &#39;foure&#39;]&gt;&gt;&gt; random.sample([23,12,45,23,45,678,34,75], k = 4)[23, 75, 34, 23]</code></pre><h2 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>random.<strong>random</strong>()</td><td>返回[0.0, 1.0)范围内的一个随机浮点数</td></tr><tr><td>random.<strong>uniform</strong>(a,b)</td><td>返回一个随机浮点数 <em>N</em> ，当 <code>a &lt;= b</code> 时 <code>a &lt;= N &lt;= b</code> ，当 <code>b &lt; a</code> 时 <code>b &lt;= N &lt;= a</code> 。</td></tr><tr><td>random.<strong>triangular</strong>(low,high,mode)</td><td>返回一个随机浮点数N，使得low &lt;= N &lt;= high 并在这些边界之间使用指定的 <em>mode</em> 。 <em>low</em> 和 <em>high</em> 边界默认为零和一。 <em>mode</em> 参数默认为边界之间的中点，给出对称分布</td></tr><tr><td>random.<strong>betavariate</strong>(alpha,beta)</td><td>Beta分布，参数alpha、beta都必须&gt;0，返回的范围介于0~1之间</td></tr><tr><td>random.<strong>expovariate</strong>(lambd)</td><td>指数分布，lambd是1.0除以所需的平均值，非零。如果lambd为正，则返回0到正无穷；如果lambd为负，则返回负无穷到0。</td></tr><tr><td>random.<strong>gammavariate</strong>(alpha,beta)</td><td>Gmma分布，参数alpha和beta必须&gt;0。</td></tr><tr><td>random.<strong>gauss</strong>(mu,sigma)</td><td>高斯分布，mu是平均值，sigma是标准差</td></tr><tr><td>random.<strong>lognormvariate</strong>(mu,sigma)</td><td>对数正态分布，如果采用的是自然对数，则会得到平均值为mu，方差为sigma的正态分布，mu可以是任何职，sigma必须大于零</td></tr><tr><td>random.<strong>normalvariate</strong>(mu, sigma)</td><td>正态分布，mu是平均值，sigma是标准差</td></tr><tr><td>random.<strong>vonmisesvariate</strong>(mu, kappa)</td><td>mu是平均角度，以弧度表示，介于0和2<em>pi之间，kappa是浓度参数，必须大于或等于零，如果kappa等于零，则该分部在0到2\</em>pi的范围内较少到均匀的随机角度。</td></tr><tr><td>random.<strong>paretovariate</strong>(alpha)</td><td>帕累托分布，alpha是形状参数</td></tr><tr><td>random.<strong>weibullvariate</strong>(alpha, beta)</td><td>威布尔分布，alpha是比例参数，beta是形状参数</td></tr></tbody></table><p><strong>Gmma分布</strong>的概率函数为：</p><p>​                                            $pdf(x) = \dfrac{x^{(alpha-1)}\times math.exp(\dfrac{-x}{beta})}{math.gamma(alpha)\times beta^ {alpha}}$</p><pre><code class="python">&gt;&gt;&gt; import random&gt;&gt;&gt; random.random()0.024784298572476104&gt;&gt;&gt; random.uniform(2.0, 5.0)3.4259267542329748&gt;&gt;&gt; random.triangular(0.3, 1.5, 0.9)1.1348586558465164&gt;&gt;&gt; random.betavariate(0.3, 0.25)0.9983372793378633&gt;&gt;&gt; random.expovariate(3.0)1.680963868987473&gt;&gt;&gt; random.gammavariate(0.25, 2.0)0.0888430548880927&gt;&gt;&gt; random.gauss(13, 2.64)14.755902455467584</code></pre><h2 id="替代随机生成器"><a href="#替代随机生成器" class="headerlink" title="替代随机生成器"></a>替代随机生成器</h2><p>使用os.urandom()函数的类，用从操作系统提供的源生成随机数，但这并非适用于所有的系统，也不依赖于软件的序列状态，生成的序列不可再现，因此导致seed()方法没有效果而被忽略，getstate()和setstate()函数被调用会引发<a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#NotImplementedError"><code>NotImplementedError</code></a>。因此random模块提供了替代随机生成器：</p><p>random.<strong>SystemRandom</strong>(seed)</p><h2 id="随机序列重现问题"><a href="#随机序列重现问题" class="headerlink" title="随机序列重现问题"></a>随机序列重现问题</h2><p>有的时候需要重现伪随机数生成器给出的序列，这在一些特殊情况下有着特殊的作用，通过重新使用新种子值，只要没有多个线程同时运行，相同的序列就可以在两次不同运行之间重现。</p><p>多数的随机模块算法和种子函数都会在Python版本中发生变化，但不变的方面有两个：</p><p>. 如果添加了新的生成方法，则会提供向后兼容的随机生成器</p><p>. 当兼容的生成器被赋予相同种子，生成器的random()方法将会产生相同的序列</p><h1 id="secrets模块"><a href="#secrets模块" class="headerlink" title="secrets模块"></a>secrets模块</h1><p>虽然<strong>random</strong>模块可以生成随机数，但是并不能对生成随机数的种子、随机机制、生成的随机序列进行加密。而<strong>secrets</strong>模块就是专门用来为管理像密码、验证码、加密token等需要加密数据而生成具有非常强加密性的随机数字。</p><h2 id="加密随机数函数"><a href="#加密随机数函数" class="headerlink" title="加密随机数函数"></a>加密随机数函数</h2><p>secrets模块能够提供最强的能够操作系统提供的加密随机性资源。其访问和生成函数如下:</p><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>secrets.<strong>SystemRandom</strong></td><td>生成加密系统随机函数生成器</td></tr><tr><td>secrets.<strong>choice</strong>(sequence)</td><td>从非空序列sequence中随机返回一个元素</td></tr><tr><td>secrets.<strong>randbelow</strong>(n)</td><td>返回[0,n)范围内的随机数</td></tr><tr><td>secrets.<strong>randbits</strong>(k)</td><td>随机返回一个bit长度为k的整数</td></tr></tbody></table><h2 id="生成tokens"><a href="#生成tokens" class="headerlink" title="生成tokens"></a>生成tokens</h2><p>secrets模块为密码以及网络访问提供了生成token函数</p><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>secrets.<strong>token_bytes</strong>(nbytes=None)</td><td>随机返回字节数长度为nbytes值的字节形式的字符串，如果nbytes=None则使用默认的nbytes长度</td></tr><tr><td>secrets.<strong>token_hex</strong>(nbytes=None)</td><td>随机返回文本长度为nbytes的文本字符串，如果nbytes=None则使用默认的nbytes长度</td></tr><tr><td>secrets.<strong>token_urlsafe</strong>(nbytes=None)</td><td>随机返回URL-safe文本字符串，文本形式经过Base64转换，如果nbytes=None则使用默认的nbytes长度</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import secrets&gt;&gt;&gt; secrets.token_bytes(16)b&#39;\xe4\xef\x0e`\xf6k\xda\x01\xc2\xd0\x94L\x84B\xe2v&#39;&gt;&gt;&gt; secrets.token_hex(16)&#39;1e702fc2ed63e4e08d2b075d62b6e782&#39;&gt;&gt;&gt; secrets.token_urlsafe(16)&#39;EsZPaNvSuNKw6XpHr6xCCQ&#39;</code></pre><h2 id="token字节长度问题"><a href="#token字节长度问题" class="headerlink" title="token字节长度问题"></a>token字节长度问题</h2><p>关于token字节长度问题过去很长一段时间没有得到明确的值，直到2015年，32个字节(256bits)长度确定为是token最能接受的高效的长度。如果想要更改token字节长度，就需要给出token的长度。</p><h2 id="字节比较功能"><a href="#字节比较功能" class="headerlink" title="字节比较功能"></a>字节比较功能</h2><p>secrets模块中的secrets__compare_digest__(a,b)函数可以用来进行字节或字符的比较，如果a和b是一样的，则返回Ture，如果不同则返回False</p><h2 id="secrets-练习"><a href="#secrets-练习" class="headerlink" title="secrets 练习"></a>secrets 练习</h2><pre><code class="python">&gt;&gt;&gt; import string&gt;&gt;&gt; alphabet = string.ascii_letters + string.digits&gt;&gt;&gt; while True:    password = &#39;&#39;.join(secrets.choice(alphabet) for i in range(10))    if(any(c.islower() for c in password) and any(c.isupper() for c in password) and sum(c.isdigit() for c in password) &gt;= 3):        break</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;random模块&quot;&gt;&lt;a href=&quot;#random模块&quot; class=&quot;headerlink&quot; title=&quot;random模块&quot;&gt;&lt;/a&gt;random模块&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;random&lt;/strong&gt;模块实现了这种分布的伪随机数生成器，随机数可以
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数字运算(三)cmath模块</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculationsCmathModule/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculationsCmathModule/</id>
    <published>2018-05-03T04:56:50.000Z</published>
    <updated>2019-05-07T11:01:20.047Z</updated>
    
    <content type="html"><![CDATA[<p><strong>cmath</strong>模块为复数提供了有关数学运算函数，使得复数也能想整型或浮点型数字一样计算</p><h2 id="复数极坐标系转换函数"><a href="#复数极坐标系转换函数" class="headerlink" title="复数极坐标系转换函数"></a>复数极坐标系转换函数</h2><p>在<a href="https://onlyangelia.github.io/PythonAdvance/PythonBasicDataTypeNumber/">Python数据类型(一)数字类型</a>中讲到复数的存储本质，和在极坐标系的定义，有关极坐标转换函数如下：</p><table><thead><tr><th>函数名</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>phase</strong>(x)</td><td>以浮点数的形式返回x的弧度，范围在[-π，π]</td></tr><tr><td>cmath.<strong>polar</strong>(x)</td><td>返回x在极坐标系中的坐标(r,phi)</td></tr><tr><td>cmath.<strong>rect</strong>(r, phi)</td><td>返回坐标(r, phi)在极坐标系中对应的复数</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import cmath&gt;&gt;&gt; cmath.phase(complex(-1.0, 0.0))3.141592653589793&gt;&gt;&gt; cmath.phase(complex(-1.0,0.0))3.141592653589793&gt;&gt;&gt; cmath.phase(complex(-0.5, 0.0))3.141592653589793&gt;&gt;&gt; cmath.phase(complex(-0.5, 0.3))2.601173153319209&gt;&gt;&gt; cmath.polar(complex(-0.5, 0.3))(0.58309518948453, 2.601173153319209)&gt;&gt;&gt; cmath.rect(0.58309518948453, 2.601173153319209)(-0.49999999999999994+0.3j)</code></pre><h2 id="幂函数与对数函数"><a href="#幂函数与对数函数" class="headerlink" title="幂函数与对数函数"></a>幂函数与对数函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>exp</strong>(x)</td><td>返回<code>e**x</code></td></tr><tr><td>cmath.<strong>log</strong>(x,base)</td><td>返回以base为底x的对数</td></tr><tr><td>cmath.<strong>log10</strong>(x)</td><td>返回以10为底x的对数</td></tr><tr><td>cmath.<strong>sqrt</strong>(x)</td><td>x的开方</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; cmath.exp(complex(2.0, 0.0))(7.38905609893065+0j)&gt;&gt;&gt; cmath.exp(complex(10.0, 2.0))(-9166.244060822655+20028.608669281643j)&gt;&gt;&gt; cmath.log10(complex(100.0,2.0))(2.0000868415292326+0.008684731797315706j)&gt;&gt;&gt; cmath.sqrt(complex(2.0, 1.0))(1.455346690225355+0.34356074972251244j)</code></pre><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>acos</strong>(x)</td><td>返回x的反余弦值</td></tr><tr><td>cmath.<strong>asin</strong>(x)</td><td>返回x的反正弦值</td></tr><tr><td>cmath.<strong>atan</strong>(x)</td><td>返回x的反正切值</td></tr><tr><td>cmath.<strong>cos</strong>(x)</td><td>返回x的余弦值</td></tr><tr><td>cmath.<strong>sin</strong>(x)</td><td>返回x的正弦值</td></tr><tr><td>cmath.<strong>tan</strong>(x)</td><td>返回x的正切值</td></tr></tbody></table><h2 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>acosh</strong>(x)</td><td>返回双曲线中x的反余弦值</td></tr><tr><td>cmath.<strong>asinh</strong>(x)</td><td>返回双曲线中x的反正弦值</td></tr><tr><td>cmath.<strong>atanh</strong>(x)</td><td>返回双曲线中x的反正切值</td></tr><tr><td>cmath.<strong>cosh</strong>(x)</td><td>返回双曲线中x的余弦值</td></tr><tr><td>cmath.<strong>sinh</strong>(x)</td><td>返回双曲线中x的正弦值</td></tr><tr><td>cmath.<strong>tanh</strong>(x)</td><td>返回双曲线中x的正切值</td></tr></tbody></table><h2 id="分类函数"><a href="#分类函数" class="headerlink" title="分类函数"></a>分类函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>isfinite</strong>(x)</td><td>模数r和弧度phi都是有理数，则返回True，否则返回False</td></tr><tr><td>cmath.<strong>isinf</strong>(x)</td><td>模数r和弧度phi都趋近于正无穷，则返回True，否则返回False</td></tr><tr><td>cmath.<strong>isnan</strong>(x)</td><td>模数r和弧度phi都是Nan，则返回True，否则返回False</td></tr><tr><td>cmath.<strong>isclose</strong>(a,b,*,rel_tol,abs_tol)</td><td>若a和b的值比较接近则返回True，否则返回False。判定标准是根据给定的绝对和相对容差。rel_tol是相对容差，必须大于0，是a和b之间允许的最大差值。abs_tol是最小绝对容差，至少为0</td></tr></tbody></table><h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><table><thead><tr><th>常数名</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>pi</strong></td><td>常数π=3.141926….</td></tr><tr><td>cmath.<strong>e</strong></td><td>常数e= 2.718281….</td></tr><tr><td>cmath.<strong>tau</strong></td><td>常数τ = 6.283185…，为π的两倍</td></tr><tr><td>cmath.<strong>inf</strong></td><td>正无穷大浮点数</td></tr><tr><td>cmath.<strong>infj</strong></td><td>实部为0，虚部为正无穷大浮点数的复数</td></tr><tr><td>cmath.<strong>nan</strong></td><td>浮点数”非数值”</td></tr><tr><td>cmath.<strong>nanj</strong></td><td>实部为0，虚部为Nan的”非数值”</td></tr></tbody></table><p><strong>cmath</strong>模块与<strong>math</strong>模块许多功能看上去相似，但实际上是不同的功能。cmath返回的值是复数，哪怕虚部为0。许多人不理解为什么单独定义一个cmath模块而不是math模块一起解决复数运算问题。假设有一天需要用特别复杂的方式去计算，就会理解这么定义的原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;cmath&lt;/strong&gt;模块为复数提供了有关数学运算函数，使得复数也能想整型或浮点型数字一样计算&lt;/p&gt;
&lt;h2 id=&quot;复数极坐标系转换函数&quot;&gt;&lt;a href=&quot;#复数极坐标系转换函数&quot; class=&quot;headerlink&quot; title=&quot;复数极坐标系
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python运算(二)math模块</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonCaculationsMathModule/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonCaculationsMathModule/</id>
    <published>2018-05-02T05:49:09.000Z</published>
    <updated>2019-05-08T11:22:03.203Z</updated>
    
    <content type="html"><![CDATA[<p><strong>math</strong>是Python自带的数学函数模块，对大多数数字类型适用，但不适用于复数，如果是复数需要使用<strong>cmath</strong>模块的同名函数，无特殊情况下，<strong>math</strong>模块中的函数返回值均为浮点数。</p><h2 id="数论与表示函数"><a href="#数论与表示函数" class="headerlink" title="数论与表示函数"></a>数论与表示函数</h2><table><thead><tr><th>函数名</th><th>释义/代码实例</th></tr></thead><tbody><tr><td>math.<strong>ceil</strong>(x)</td><td>返回大于或等于x的最小整数，如果x不是浮点数，则会委托x.<strong>ceil</strong>()返回一个Integer类的值</td></tr><tr><td>math.<strong>copysign</strong>(x,y)</td><td>返回一个基于x的绝对值和y的符号的浮点数&gt;&gt;&gt; math.copysign(2.4, -1.2)<br>-2.4</td></tr><tr><td>math.<strong>fabs</strong>(x)</td><td>返回x的绝对值</td></tr><tr><td>math.<strong>factorial</strong>(x)</td><td>返回x的阶乘，当x不是整数或者是负数时，引发ValueError异常</td></tr><tr><td>math.<strong>floor</strong>(x)</td><td>返回x的向下取整，小于或等于x的最大整数，如果x不是浮点数，则委托x.<strong>floor</strong>()返回一个Integral值</td></tr><tr><td>math.<strong>fmod</strong>(x,y)</td><td>x除以y的余数，但结果并不一定与x%y相同，x%y取余是向下取余，而fomd函数是向靠近0的方向取余，并且fmod函数精度更准确，所以fmod()函数更适合浮点数</td></tr><tr><td>math.<strong>frexp</strong>(x)</td><td>返回x的尾数和指数对(m，e),m是一个浮点数，e是一个整数，m和e要满足 <code>x== m * 2 **e</code>。 如果x为零，则返回(0.0,0)</td></tr><tr><td>math.<strong>fsum</strong>(iterable)</td><td>返回迭代中的精确浮点值，通过跟踪多个中间部分和 以此避免精度损失。该方法的准确性取决于IEEE-754算术保证和 舍入模式为半偶的典型情况，在一些非Windows版本中，底层C库使用扩展精度添加，并且有时可能会使中间和加倍，导致在最低有效位中关闭。<br>&gt;&gt;&gt; sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])<br>0.9999999999999999<br>&gt;&gt;&gt; math. fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])<br>1.0<br></td></tr><tr><td>math.<strong>gcd</strong>(a,b)</td><td>返回a和b的最大公约数，如果a或b之一非负，则函数函数的值是同时能正常a和b的最大正整数，gcd(0，0)则返回0</td></tr><tr><td>math.<strong>isclose</strong>(a,b,*,rel_tol=1e-09,abs_tol=0.0)</td><td>若a和b的值比较接近则返回True，否则返回False。判定标准是根据给定的绝对和相对容差。rel_tol是相对容差，必须大于0，是a和b之间允许的最大差值。abs_tol是最小绝对容差，至少为0</td></tr><tr><td>math.<strong>isfinite</strong>(x)</td><td>如果x是有限位数，则返回True，否则返回False</td></tr><tr><td>math.<strong>isinf</strong>(x)</td><td>如果x是正无穷或负无穷，则返回True，否则返回False</td></tr><tr><td>math.<strong>isnan</strong>(x)</td><td>如果x是NaN，则返回True，否则返回False</td></tr><tr><td>math.<strong>ldexp</strong>(x,i)</td><td>返回<code>x*(2**i)</code>, 是函数frexp()的反函数</td></tr><tr><td>math.<strong>modf</strong>(x)</td><td>返回x的小数和整数部分，两个结果都带有x的符号并且是浮点数</td></tr><tr><td>math.<strong>trunc</strong>(x)</td><td>返回x实部截断Integeral</td></tr></tbody></table><h2 id="幂函数与对数函数"><a href="#幂函数与对数函数" class="headerlink" title="幂函数与对数函数"></a>幂函数与对数函数</h2><table><thead><tr><th>函数名</th><th>释义/代码示例</th></tr></thead><tbody><tr><td>math.<strong>exp</strong>(x)</td><td>返回 e**x</td></tr><tr><td>math.<strong>expm1</strong>(x)</td><td>返回e**x - 1</td></tr><tr><td>math.<strong>log</strong>(x,base)</td><td>使用一个参数，则返回x的自然对数(底为e)。使用两个参数，返回给定的base的对数x，计算为log(x)/log(base)。</td></tr><tr><td>math.<strong>log1p</strong>(x)</td><td>返回1+x(base e)的自然对数</td></tr><tr><td>math.<strong>log2</strong>(x)</td><td>返回x以2为底的对数，比log(x,2)准确度高</td></tr><tr><td>math.<strong>log10</strong>(x)</td><td>返回x底为10的对数，比log(x,10)准确度高</td></tr><tr><td>math.<strong>pow</strong>(x,y)</td><td>返回x的y次幂</td></tr><tr><td>math.<strong>sqrt</strong>(x)</td><td>返回x的平方根</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; x = 5&gt;&gt;&gt; math.exp(x)148.4131591025766&gt;&gt;&gt; math.expm1(x)147.4131591025766&gt;&gt;&gt; math.log(x)1.6094379124341003&gt;&gt;&gt; math.log(x, 2)2.321928094887362&gt;&gt;&gt; math.log1p(x)1.791759469228055&gt;&gt;&gt; math.log2(x)2.321928094887362&gt;&gt;&gt; math.log10(x)0.6989700043360189&gt;&gt;&gt; math.pow(x, 2)25.0&gt;&gt;&gt; math.sqrt(x)2.23606797749979</code></pre><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><table><thead><tr><th>函数名</th><th>释义/代码示例</th></tr></thead><tbody><tr><td>math.<strong>acos</strong>(x)</td><td>以弧度为单位返回x的反余弦值</td></tr><tr><td>math.<strong>asin</strong>(x)</td><td>以弧度为单位返回x的反正弦值</td></tr><tr><td>math.<strong>atan</strong>(x)</td><td>以弧度为单位返回x的反正切值</td></tr><tr><td>math.<strong>atan2</strong>(y,x)</td><td>以弧度为单位返回athan(y/x)，结果在-pi和pi之间，可以计算角度的正确象限</td></tr><tr><td>math.<strong>cos</strong>(x)</td><td>返回x弧度的余弦值</td></tr><tr><td>math.<strong>hypot</strong>(x,y)</td><td>返回欧几里德范数，sqrt(x<em>x + y\</em>y),是原点到点(x，y)的向量距离</td></tr><tr><td>math.<strong>sin</strong>(x)</td><td>返回x弧度的正弦值</td></tr><tr><td>math.<strong>tan</strong>(x)</td><td>返回x弧度的正切值</td></tr></tbody></table><p>注意： x的取值若超出范围，否则会报<code>ValueError: math domain error</code></p><pre><code class="python">&gt;&gt;&gt; math.acos(2.3)Traceback (most recent call last):  File &quot;&lt;pyshell#26&gt;&quot;, line 1, in &lt;module&gt;    math.acos(2.3)ValueError: math domain error&gt;&gt;&gt; math.acos(0.5)1.0471975511965976&gt;&gt;&gt; math.asin(0.5)0.5235987755982988&gt;&gt;&gt; math.atan(0.5)0.46364760900080615&gt;&gt;&gt; math.atan2(0.5,0.5)0.7853981633974483&gt;&gt;&gt; math.cos(0.5)0.8775825618903728&gt;&gt;&gt; math.hypot(0.5,0.5)0.7071067811865476&gt;&gt;&gt; math.sin(0.5)0.479425538604203&gt;&gt;&gt; math.tan(0.5)0.5463024898437905&gt;&gt;&gt; math.tan(1)1.557407724654902&gt;&gt;&gt; math.tan(1.4)5.797883715482887&gt;&gt;&gt; math.tan(2)-2.185039863261519&gt;&gt;&gt; math.tan(2.5)-0.7470222972386602</code></pre><h2 id="角度转换"><a href="#角度转换" class="headerlink" title="角度转换"></a>角度转换</h2><table><thead><tr><th>函数名</th><th>释义</th></tr></thead><tbody><tr><td>math.<strong>degrees</strong>(x)</td><td>将角度x从弧度转换为度数</td></tr><tr><td>math.<strong>radians</strong>(x)</td><td>将角度x从度数转换为弧度</td></tr></tbody></table><h2 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h2><p>双曲函数是基于双曲线而非圆来对三角函数进行模拟</p><table><thead><tr><th>函数名</th><th>释义</th></tr></thead><tbody><tr><td>math.<strong>acosh</strong>(x)</td><td>返回x的反双曲余弦值</td></tr><tr><td>math.<strong>asinh</strong>(x)</td><td>返回x的反双曲正弦值</td></tr><tr><td>math.<strong>atanh</strong>(x)</td><td>返回x的反双曲正切值</td></tr><tr><td>math.<strong>cosh</strong>(x)</td><td>返回x的双曲余弦值</td></tr><tr><td>math.<strong>sinh</strong>(x)</td><td>返回x的双曲正弦值</td></tr><tr><td>math.<strong>tanh</strong>(x)</td><td>返回x的双曲正切值</td></tr></tbody></table><h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><table><thead><tr><th>函数名</th><th>释义</th></tr></thead><tbody><tr><td>math.<strong>erf</strong>(x)</td><td>用来计算传统的统计函数，如累积标准正态分布</td></tr><tr><td>math.<strong>erfc</strong>(x)</td><td>返回x的互补误差函数，<a href="https://en.wikipedia.org/wiki/Error_function">互补错误函数</a> 定义为 <code>1.0 - erf(x)</code></td></tr><tr><td>math.<strong>gamma</strong>(x)</td><td>返回x的伽马函数值</td></tr><tr><td>math.<strong>lgamma</strong>(x)</td><td>返回Gamma函数x绝对值的自然对数</td></tr></tbody></table><h2 id="math模块中的常数"><a href="#math模块中的常数" class="headerlink" title="math模块中的常数"></a>math模块中的常数</h2><table><thead><tr><th>常数</th><th>释义</th></tr></thead><tbody><tr><td>math.<strong>pi</strong></td><td>数学常数π=3.1415926…</td></tr><tr><td>math.<strong>e</strong></td><td>数学常数e= 2.718281….</td></tr><tr><td>math.<strong>tau</strong></td><td>数学常数τ = 6.283185…</td></tr><tr><td>math.<strong>inf</strong></td><td>正无穷大浮点数，负无穷大浮点数使用-math.<strong>inf</strong></td></tr><tr><td>math.<strong>nan</strong></td><td>浮点”非数字”值</td></tr></tbody></table><p>math模块是数学函数的包装模块，若使用不符合数学规范，则会触发<a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#ValueError"><code>ValueError</code></a> </p><p>参考文献：</p><p>1.<a href="https://docs.python.org/English/3.6/library/math.html#math.fmod">https://docs.python.org/English/3.6/library/math.html#math.fmod</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;math&lt;/strong&gt;是Python自带的数学函数模块，对大多数数字类型适用，但不适用于复数，如果是复数需要使用&lt;strong&gt;cmath&lt;/strong&gt;模块的同名函数，无特殊情况下，&lt;strong&gt;math&lt;/strong&gt;模块中的函数返回值均为浮点
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数字运算(-)数值、哈希、按位、布尔等运算</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculations/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculations/</id>
    <published>2018-05-01T12:34:35.000Z</published>
    <updated>2019-05-07T02:26:47.435Z</updated>
    
    <content type="html"><![CDATA[<p>所有的类型都可以被比较、检测逻辑值、转换字符串，所有的数据类型都可进行数学运算。</p><h2 id="逻辑值检测"><a href="#逻辑值检测" class="headerlink" title="逻辑值检测"></a>逻辑值检测</h2><p>任何数据类型或对象皆可进行逻辑值检测，默认情况下均被视为真值，除非对象或所属类重定义了<strong>bool</strong>()方法且返回<code>False</code> 或者是对象定义了<strong>len</strong>()方法且返回零。</p><p>以下是在逻辑检测时被视为假值的对象:</p><p>.被定义为假值的常量：<code>None 和 False</code></p><p>.任何数值类型的零：<code>0，0.0，0j,Decimal(0),Fraction(0,1)</code></p><p>.空的序列和多项集：<code>&#39;&#39;，()，{}，set(),range(0)</code></p><h2 id="Bool运算"><a href="#Bool运算" class="headerlink" title="Bool运算"></a>Bool运算</h2><p>Bool运算包括 <code>and、or、not</code>，按照优先级排列not &gt; and &gt; or</p><table><thead><tr><th>运算</th><th>结果</th><th>注释</th></tr></thead><tbody><tr><td>x or y</td><td>如果x为false，那么返回y，否则返回x</td><td>or为短路运算符，只有在第一个参数为假值时才会对第二个参数求值</td></tr><tr><td>x and y</td><td>如果x为false，那么返回x，否则返回y</td><td>and同样是短路运算符，只有在第一个参数为真值时才会对第二个参数求值</td></tr><tr><td>not x</td><td>如果x为false，那么返回True，否则返回False</td><td>优先级比非布尔运算符低，因此 <code>not a == b</code>会被解读为<code>not (a==b)</code>，而<code>a == not b</code>会造成语法错误</td></tr></tbody></table><h2 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h2><p>Python中有八种比较运算符，优先级相同，但都比布尔运算优先级高，并且比较运算符可以任意串联。例如，<code>x&lt;y&lt;=z</code>等价于 <code>x&lt; y and y &lt;=z</code>,不同之处是前者y只被求值一次，后者会被求值两次，相同点是在x&lt;y结果为假时z都不会被求值。</p><p>八种比较运算符如下：</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>&lt;</strong></td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center"><strong>&lt;=</strong></td><td style="text-align:center">小于或等于</td></tr><tr><td style="text-align:center"><strong>&gt;</strong></td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center"><strong>&gt;=</strong></td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center"><strong>==</strong></td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center"><strong>!=</strong></td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center"><strong>is</strong></td><td style="text-align:center">对象标识</td></tr><tr><td style="text-align:center"><strong>is not</strong></td><td style="text-align:center">否定的对象标识</td></tr></tbody></table><h3 id="比较运算注意点"><a href="#比较运算注意点" class="headerlink" title="比较运算注意点"></a>比较运算注意点</h3><p>. 不同数字、不同类型对象比较时绝不会相等</p><p>. 函数类型仅支持简化形式比较</p><p>. &lt;,&lt;=,&gt;,&gt;= 运算符在比较复数和其它数字类型时，或在两个对象具有无法被比较的不同类型时，或在未定义次序的其他情况时，以上皆会产生<code>TypeErroe</code>异常</p><p>. 不同标识类的实例比较，除非定义了<strong>eq</strong>()方法，否则不相等</p><p>. 类实例不能与相同类或其他实例或其它类型对象进行排序，除非定义了 <strong>it</strong>(),<strong>le</strong>(),<strong>gt</strong>(),<strong>ge</strong>()这些函数</p><p>. <code>is</code> 和 <code>is not</code>无法自定义，可以被应用于任意两个对象不引发异常。</p><p>.<code>in</code> 和 <code>not in</code> ，与上面八种比较运算符具有相同优先级，但只能支持<strong>iterable(可迭代对象)</strong>或实现了<strong>contains</strong>()方法的类型</p><h2 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h2><p>所有的数字类型，除了复数类型，都支持下面的运算操作，所有数字运算的优先级都高于比较运算，以下按照<strong>优先级升序排列</strong>：</p><table><thead><tr><th style="text-align:center">运算</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>+</strong></td><td>两数之和</td></tr><tr><td style="text-align:center"><strong>-</strong></td><td>两数之差</td></tr><tr><td style="text-align:center">$ \times $</td><td>两数乘积</td></tr><tr><td style="text-align:center"><strong>/</strong></td><td>两数相除，结果返回商</td></tr><tr><td style="text-align:center"><strong>//</strong></td><td>两数整除，结果返回商数</td></tr><tr><td style="text-align:center"><strong>%</strong></td><td>两数相除结果取余数</td></tr><tr><td style="text-align:center"><strong>-x</strong></td><td>x取反</td></tr><tr><td style="text-align:center"><strong>+x</strong></td><td>x取正</td></tr><tr><td style="text-align:center"><strong>abs(x)</strong></td><td>x的绝对值</td></tr><tr><td style="text-align:center"><strong>int(x)</strong></td><td>将x转换为整数</td></tr><tr><td style="text-align:center"><strong>float(x)</strong></td><td>将x转换为浮点数</td></tr><tr><td style="text-align:center"><strong>complex(re,im)</strong></td><td>一个带有实部re和虚部im的复数，im默认为0</td></tr><tr><td style="text-align:center"><strong>c.conjugate()</strong></td><td>复数c的共轭</td></tr><tr><td style="text-align:center"><strong>divmod(x,y)</strong></td><td>执行x//y x%y ，得到x被y除之后的商和余数</td></tr><tr><td style="text-align:center"><strong>pow(x,y)</strong></td><td>x的y次幂</td></tr><tr><td style="text-align:center">x **y</td><td>同样表示x的y次幂</td></tr><tr><td style="text-align:center">invmod(x,y)</td><td>对x模y取反</td></tr></tbody></table><h3 id="数字运算注意点："><a href="#数字运算注意点：" class="headerlink" title="数字运算注意点："></a>数字运算注意点：</h3><p>. / 除法运算返回的永远是一个浮点数</p><p>.// 整除结果值是一个整数，但结果的类型不一定是int。 运算结果永远向负无穷方向舍入， 1//2 为0, (-1)//2 为-1，1//(-2)为-1,(-1)//(-2)为0。</p><p>. % 不能用于复数</p><p>. int() 若从浮点数转换为整数会被舍入或被截断，原因在前面文章数字类型中提到过，因为二进制浮点数问题</p><p>数字类型还能进行数学函数运算，具体会在后面math和cmath模块讲到。</p><h2 id="整数类型按位运算"><a href="#整数类型按位运算" class="headerlink" title="整数类型按位运算"></a>整数类型按位运算</h2><p>按位运算只对整数有意义，按位运算优先级低于数字运算，高于比较运算，但一元运算<code>~</code>与其它一元算术运算符优先级相同。</p><table><thead><tr><th>运算</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>x\</td><td>y</td><td>x和y按位或</td><td></td></tr><tr><td>x^y</td><td>x和y按位异或</td><td></td></tr><tr><td>x&amp;y</td><td>x和y按位与</td><td></td></tr><tr><td>x&lt;&lt;n</td><td>x左移n位</td><td>负的移位会引发ValueError，左移n位等价于不带溢出检测的乘以pow(2,n)</td></tr><tr><td>x&gt;&gt;n</td><td>x右移n位</td><td>负的移位同样会引发ValueErroe，右移n位等价于不带溢出检测的除以pow(2,n)</td></tr><tr><td>~x</td><td>x按位取反</td></tr></tbody></table><h2 id="数字类型的哈希运算"><a href="#数字类型的哈希运算" class="headerlink" title="数字类型的哈希运算"></a>数字类型的哈希运算</h2><p><strong>不同数字类型的两个数，要做== 比较运算时，必须转成哈希值，即hash(x)==hash(y)</strong>。为便于在各种数字类型上实现并保证效率，Python对数字类型的哈希运算是基于任意有理数定义统一的数学函数，本质上hash()是通过以一个固定质数P进行P降模。P的值在 Python 中可以 <a href="https://docs.python.org/zh-cn/3.6/library/sys.html#sys.hash_info"><code>sys.hash_info</code></a> 的 <code>modulus</code> 属性的形式被访问。</p><p>CPython implementation detail: 所用质数设定，在 C long 为 32 位的机器上 <code>P = 2**31 - 1</code> 而在 C long 为 64 位的机器上 <code>P = 2**61 - 1</code></p><p>运算规则如下：</p><ul><li>如果 <code>x = m / n</code> 是一个非负比例数，且 <code>n</code> 不能被 <code>P</code> 整除，则定义 <code>hash(x)</code> 为 <code>m * invmod(n, P) % P</code>。</li><li>如果 <code>x = m / n</code> 是一个非负比例数，且 <code>n</code> 能被 <code>P</code> 整除（但 <code>m</code> 不能）则 <code>n</code> 不能对 <code>P</code> 降模，以上规则不适用；在此情况下则定义 <code>hash(x)</code> 为常数值 <code>sys.hash_info.inf</code>。</li><li>如果 <code>x = m / n</code> 是一个负比例数，则定义 <code>hash(x)</code> 为 <code>-hash(-x)</code>。 如果结果哈希值为 <code>-1</code> 则将其替换为 <code>-2</code>。</li><li>特定值 <code>sys.hash_info.inf</code>, <code>-sys.hash_info.inf</code> 和 <code>sys.hash_info.nan</code> 被用作正无穷、负无穷和空值（所分别对应的）哈希值。 （所有可哈希的空值都具有相同的哈希值）</li><li>对于一个 <a href="https://docs.python.org/zh-cn/3.6/library/functions.html#complex"><code>complex</code></a> 值 <code>z</code>，会通过计算 <code>hash(z.real) + sys.hash_info.imag * hash(z.imag)</code> 将实部和虚部的哈希值结合起来，并进行降模 <code>2**sys.hash_info.width</code> 以使其处于 <code>range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))</code> 范围之内。 同样地，如果结果为 <code>-1</code> 则将其替换为 <code>-2</code></li></ul><p>为了更好的理解运算规则，用代码实现如下:</p><p>对分数求哈希值：</p><pre><code class="python">&gt;&gt;&gt; import sys,math&gt;&gt;&gt; def hash_fraction(m,n):    &#39;&#39;&#39;计算比例数m/n的哈希值，m和n为整数，n为正数&#39;&#39;&#39;    P = sys.hash_info.modulus    #去掉P的公因数，除非m和n互质    while m%P == n%P ==0:        m,n = m//P, n//P    #如果n能被P整除，hash值为固定值    if n % P == 0:        hash_value = sys.hash_info.inf    else:        #如果n不能被P整除，则对P进行降模处理        hash_value = (abs(m)%P)*pow(n,P-2,P)%P    #判断m是否是负数，对负数求hash    if m &lt; 0:        hash_value = -hash_value    if hash_value == -1:        hash_value = -2    return hash_value</code></pre><p>对float浮点数类型求哈希值：</p><pre><code class="python">&gt;&gt;&gt; def hash_float(x):    #计算浮点数x的哈希值    if math.isnan(x):        return sys.hash_info.nan    elif math.isinf(x):        return sys.hash_info.inf if x &gt; 0 else -sys.hash_info.inf    else:        return hash_fraction(*x.as_integer_ratio())</code></pre><p>对复数类型求哈希值：</p><pre><code class="python">#计算复数z的哈希值    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)    M = 2 **(sys.hash_info.width - 1)    hash_value = (hash_value &amp; (M-1)) - (hash_value&amp;M)    if hash_value == -1:        hash_value = -2    return hash_value</code></pre><h2 id="Decimal运算实例"><a href="#Decimal运算实例" class="headerlink" title="Decimal运算实例"></a>Decimal运算实例</h2><p>Decimal 进行  $+ 、- 、\times 、/$  运算</p><pre><code class="python">&gt;&gt;&gt; data = list(map(Decimal, &#39;1.34 1.87 3.45 2.35 1.00 0.03 9.25&#39;.split()))&gt;&gt;&gt; sum (data)Decimal(&#39;19.29&#39;)&gt;&gt;&gt; min(data)Decimal(&#39;0.03&#39;)&gt;&gt;&gt; max(data)Decimal(&#39;9.25&#39;)&gt;&gt;&gt; min(data)Decimal(&#39;0.03&#39;)&gt;&gt;&gt; a,b,c = data[:3]&gt;&gt;&gt; a * 5Decimal(&#39;6.70&#39;)&gt;&gt;&gt; a * bDecimal(&#39;2.5058&#39;)&gt;&gt;&gt; c % aDecimal(&#39;0.77&#39;)&gt;&gt;&gt; a + b + cDecimal(&#39;6.66&#39;)&gt;&gt;&gt; a - bDecimal(&#39;-0.53&#39;)&gt;&gt;&gt; </code></pre><p>当余数运算%应用于Decimal对象时，结果的符号是被除数的符号，而不是除数的符号</p><pre><code class="python">&gt;&gt;&gt; -5 % 83&gt;&gt;&gt; Decimal(-5) % Decimal(8)Decimal(&#39;-5&#39;)&gt;&gt;&gt; Decimal(8) % Decimal(-5)Decimal(&#39;3&#39;)</code></pre><p>同样Decimal也可以进行一些数学函数运算</p><pre><code class="python">&gt;&gt;&gt; Decimal(2).sqrt()Decimal(&#39;1.41421&#39;)&gt;&gt;&gt; Decimal(1).exp()Decimal(&#39;2.71828&#39;)&gt;&gt;&gt; Decimal(10).ln&lt;built-in method ln of decimal.Decimal object at 0x1073b04a8&gt;&gt;&gt;&gt; Decimal(10).ln()Decimal(&#39;2.30259&#39;)&gt;&gt;&gt; Decimal(&#39;10&#39;).log10()Decimal(&#39;1&#39;)</code></pre><p>关于四舍五入，Decimal的quantize()方法可以将数字四舍五入为固定函数</p><pre><code class="python">&gt;&gt;&gt; Decimal(&#39;7.325&#39;).quantize(Decimal(&#39;0.01&#39;), rounding=ROUND_DOWN)Decimal(&#39;7.32&#39;)&gt;&gt;&gt; Decimal(&#39;7.325&#39;).quantize(Decimal(&#39;1.&#39;), rounding=ROUND_UP)Decimal(&#39;8&#39;)</code></pre><h2 id="Fraction运算实例"><a href="#Fraction运算实例" class="headerlink" title="Fraction运算实例"></a>Fraction运算实例</h2><p>Fraction同样可以进行$+、-、\times /$   四则运算和%运算等</p><pre><code class="python">&gt;&gt;&gt; from fractions import Fraction&gt;&gt;&gt; import math&gt;&gt;&gt; Fraction(2,3) + Fraction(3,5)Fraction(19, 15)&gt;&gt;&gt; Fraction(2,3) - Fraction(3,5)Fraction(1, 15)&gt;&gt;&gt; Fraction(2,3) * Fraction(3,5)Fraction(2, 5)&gt;&gt;&gt; Fraction(2,3) / Fraction(3,5)Fraction(10, 9)&gt;&gt;&gt; Fraction(2,3) % Fraction(-3, 5)Fraction(-8, 15)&gt;&gt;&gt; Fraction(2,3) % Fraction(3,5)Fraction(1, 15)</code></pre><p>Fraction没有sqrt()、exp()等函数方法。</p><p>参考文献：</p><p>1.<a href="https://docs.python.org/zh-cn/3.6/contents.html">https://docs.python.org/zh-cn/3.6/contents.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所有的类型都可以被比较、检测逻辑值、转换字符串，所有的数据类型都可进行数学运算。&lt;/p&gt;
&lt;h2 id=&quot;逻辑值检测&quot;&gt;&lt;a href=&quot;#逻辑值检测&quot; class=&quot;headerlink&quot; title=&quot;逻辑值检测&quot;&gt;&lt;/a&gt;逻辑值检测&lt;/h2&gt;&lt;p&gt;任何数据类型或对象皆
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数据类型(一)数字类型</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonBasicDataTypeNumber/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonBasicDataTypeNumber/</id>
    <published>2018-05-01T07:23:14.000Z</published>
    <updated>2019-05-07T13:41:36.062Z</updated>
    
    <content type="html"><![CDATA[<p>Python3有六个标准数据类型：</p><p>.不可变数据类型：<strong>Number(数字)、String(字符串)、Tuple(元组)</strong></p><p>.可变数据类型： <strong>List(列表)、Dictionary(字典)、Set(集合)</strong></p><p>在每种基本数据类型下会有其它一些衍生类型。以上六种是基本的数据类型，除基本数据类型外，其它数据类型有：<strong>Datetime(时间)、Calendar(日历)、Collection(容器)、enum(枚举)</strong>等。</p><p>该篇讲述<strong>Number</strong>(数字)的各种类型、衍生类型<strong>Decimal</strong>类型和<strong>Fractions</strong>类型的适用情况以及针对数据类型的运算规则。</p><p><strong>Number</strong>：</p><p>Python3 支持<strong>int、float、bool、complext、Decimal、Fraction</strong> 等数值类型，数值类型可以直接进行<code>+、-、*、/</code>运算，<code>()</code>用于分组。内置函数<code>type()</code>和<code>isinstance()</code>可以查看变量所指的对象类型，<strong>适用于所有的数据类型</strong>,两者的区别是<code>type()</code>不认为子类是父类类型  <code>isinstance()</code>认为子类是父类类型。</p><h2 id="int-整数"><a href="#int-整数" class="headerlink" title="int(整数)"></a>int(整数)</h2><p>整数(例如<code>4，5，6</code>)类型为<strong>int</strong> 类型，Python3之后只有一种整数类型int，表示长整型，不再有之前的<strong>long</strong>类型。在Python2中用数字0表示<code>False</code>，用数字1表示<code>True</code>，但是Python3 中直接把<code>True</code>和<code>False</code>定义为关键字，其值还是表示0和1。布尔值属于整数的子类型，整数具有无限的精度。</p><pre><code class="python">&gt;&gt;&gt; a = 1; b=2&gt;&gt;&gt; isinstance(a, int)True&gt;&gt;&gt; type(b)&lt;class &#39;int&#39;&gt; #以上两个函数同样适用于其它Number类型以及String等</code></pre><h3 id="整数类型附加方法"><a href="#整数类型附加方法" class="headerlink" title="整数类型附加方法"></a>整数类型附加方法</h3><p>int 类型实现了<a href="https://docs.python.org/zh-cn/3.6/library/numbers.html#numbers.Integral"><code>numbers.Integral</code></a> <a href="https://docs.python.org/zh-cn/3.6/glossary.html#term-abstract-base-class">abstract base class</a>，也提供了其他方法</p><h4 id="bit-length"><a href="#bit-length" class="headerlink" title="bit_length()"></a>bit_length()</h4><p><code>int.bit_length()</code>返回以二进制表示一个整数所需要的位数，不包括符号位和前面的零</p><pre><code class="python">&gt;&gt;&gt; a = -13&gt;&gt;&gt;#转换成二进制&gt;&gt;&gt; bin(a)&#39;-0b1101&#39;&gt;&gt;&gt; a.bit_length()4</code></pre><p>如果a的值为0，则<code>bit_length(</code>)函数返回0，如果a的值不为0，则<code>bit_length()</code>是使得<code>2**(k-1) &lt;= abs(x)&lt; 2 **k</code>的 唯一正整数k,同样abs(a)小到足以具有正确的舍入对数时，则<code>k = 1 + int(log(abs(x),2))</code>。</p><p>等价于：</p><pre><code class="python">&gt;&gt;&gt; def bit_length(self):    s = bin(self)   #将整数转换为二进制    s = s.lstrip(&#39;-0b&#39;) #将二进制的前缀去掉    return len(s)   #返回二进制位的长度</code></pre><h4 id="to-bytes"><a href="#to-bytes" class="headerlink" title="to_bytes()"></a>to_bytes()</h4><p>int.<strong>to_bytes</strong>(length, byteorder, *,signed=False)返回一个整数的字节数组，是Python3.1新增加的功能</p><p>参数含义：</p><p>length: 整数字节数，如果不能用给定的字节数来表示则会引发OverflowError</p><p>byteorder:  确定用于表示整数的字节顺序，byteorder为’big’表示最高位字节放在字节位开头。byteorder为’little’表示最高位字节放在字节数组的末尾。</p><p>signed: 是否使用二进制补码来表示整数，如果signed为False并且给出的是负整数，则会引发<a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#OverflowError"><code>OverflowError</code></a>。默认值为False</p><pre><code class="python">&gt;&gt;&gt; a = 1024&gt;&gt;&gt; a.to_bytes(2, byteorder=&#39;big&#39;)b&#39;\x04\x00&#39;&gt;&gt;&gt; a.to_bytes(10, byteorder=&#39;big&#39;)b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00&#39;&gt;&gt;&gt; a.to_bytes(10, byteorder=&#39;big&#39;, signed=True)b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00&#39;&gt;&gt;&gt; b = -1024&gt;&gt;&gt; b.to_bytes(10, byteorder=&#39;big&#39;, signed=True)b&#39;\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00&#39;&gt;&gt;&gt; c = 1000&gt;&gt;&gt; c.to_bytes((c.bit_length()+7)//8, byteorder=&#39;little&#39;)b&#39;\xe8\x03&#39;</code></pre><h4 id="from-bytes"><a href="#from-bytes" class="headerlink" title="from_bytes()"></a>from_bytes()</h4><p>int.from_bytes(bytes, byteorder, *, signed=False) 返回给定字节数组表示的整数，是Python3.2增加的功能。</p><p>参数含义:</p><p>bytes: 必须是一个<a href="https://docs.python.org/zh-cn/3.6/glossary.html#term-bytes-like-object">bytes-like object</a> 或是生成字节的可迭代对象</p><p>byteorder： 表示整数的字节顺序，如果 <em>byteorder</em> 为 <code>&quot;big&quot;</code>，则最高位字节放在字节数组的开头。 如果 <em>byteorder</em> 为 <code>&quot;little&quot;</code>，则最高位字节放在字节数组的末尾</p><p>signed：是否使用二进制补码表示</p><pre><code class="python">&gt;&gt;&gt; int.from_bytes(b&#39;\x04\x00&#39;,byteorder=&#39;big&#39;)1024&gt;&gt;&gt; int.from_bytes(b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00&#39;, byteorder=&#39;big&#39;)1024&gt;&gt;&gt; int.from_bytes(b&#39;\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00&#39;, byteorder=&#39;big&#39;,signed=True)-1024</code></pre><h2 id="float（浮点数）"><a href="#float（浮点数）" class="headerlink" title="float（浮点数）"></a>float（浮点数）</h2><p>带小数部分的数字（如：<code>4.5，6.78</code>）是<strong>float类型</strong>。<code>float()</code>函数可以将数字转换为<strong>float类型</strong>。浮点数通常使用C中的double来实现，浮点数精度和内部表示可以查看<a href="https://docs.python.org/zh-cn/3.6/library/sys.html#sys.float_info"><code>sys.float_info</code></a></p><pre><code class="python">&gt;&gt;&gt; float(8)8.0</code></pre><h3 id="浮点数类型附加方法"><a href="#浮点数类型附加方法" class="headerlink" title="浮点数类型附加方法"></a>浮点数类型附加方法</h3><p>float 类型实现了 <a href="https://docs.python.org/zh-cn/3.6/library/numbers.html#numbers.Real"><code>numbers.Real</code></a> <a href="https://docs.python.org/zh-cn/3.6/glossary.html#term-abstract-base-class">abstract base class</a>。 float 具有以下附加方法。</p><h4 id="as-integer-ratio"><a href="#as-integer-ratio" class="headerlink" title="as_integer_ratio()"></a>as_integer_ratio()</h4><p>float.as_integer_ratio() 返回一对整数，其比率证照等于原浮点数并且分母为整数，如果是无穷大会引发 <a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#OverflowError"><code>OverflowError</code></a> 而 NaN 则会引发 <a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#ValueError"><code>ValueError</code></a></p><pre><code class="py">&gt;&gt;&gt; 2.5.as_integer_ratio()(5, 2)</code></pre><h4 id="is-integer"><a href="#is-integer" class="headerlink" title="is_integer()"></a>is_integer()</h4><p>float.is_integer() 如果float实例可以用有限位整数表示则返回<code>True</code>，否则返回<code>False</code></p><pre><code class="py">&gt;&gt;&gt; 2.0.is_integer()True&gt;&gt;&gt; 3.3.is_integer()False</code></pre><p><strong>注意点</strong>：</p><p>以上两个方法都支持与十六进制数、字符串之间转换。由于 Python 浮点数在内部存储为二进制数，因此浮点数与 <em>十进制数</em> 字符串之间的转换往往会导致微小的舍入错误。 而十六进制数字符串却允许精确地表示和描述浮点数。 这在进行调试和数值工作时非常有用。</p><h4 id="hex"><a href="#hex" class="headerlink" title="hex()"></a>hex()</h4><p><code>float.hex()</code> 以十六进制字符串的形式返回一个浮点数，如果是有限浮点数，这种表示法将包含前导的 <code>0x</code> 和尾随的 <code>p</code> 加指数，此方法是<strong>实例方法</strong></p><pre><code class="python">&gt;&gt;&gt; 4.7.hex()&#39;0x1.2cccccccccccdp+2&#39;&gt;&gt;&gt; 3.3.hex()&#39;0x1.a666666666666p+1&#39;</code></pre><h4 id="fromhex"><a href="#fromhex" class="headerlink" title="fromhex()"></a>fromhex()</h4><p><code>float.fromhex()</code>是<strong>类方法</strong>，返回以十六进制字符串 <em>s</em> 表示的浮点数的类方法，返回的字符串可以带有前导和尾随的空格</p><pre><code class="python">&gt;&gt;&gt; float.fromhex(&#39;0x1.a666666666666p+1&#39;)3.3&gt;&gt;&gt; float.fromhex(&#39;0x1.2cccccccccccdp+2&#39;)4.7</code></pre><h2 id="complex（复数）"><a href="#complex（复数）" class="headerlink" title="complex（复数）"></a>complex（复数）</h2><p>complext由实部re和虚部im构成，实部和虚部都是浮点类型，使用后缀j和J表示虚数部分，表示为a+bj，函数<code>complex(re,im)</code>同样可以构造复数。</p><pre><code class="python">&gt;&gt;&gt; complex(4.5, 1.2)(4.5+1.2j)</code></pre><h3 id="复数极坐标"><a href="#复数极坐标" class="headerlink" title="复数极坐标"></a>复数极坐标</h3><p>Python中复数本质上实现是一个长方形坐标系或由笛卡尔坐标系存储。它被定义为实部和虚部：</p><p><code>z=z.real + z.imag*1j</code></p><p>极坐标系 提供了可供选择的表达复数的方式，在极坐标系中复数z被定义为是由模数<em>r</em>和位项角<em>phi</em>构成。模数<em>r</em>是由z到原点的距离，位项角<em>phi</em>是正x轴到原点与z轴连接线段按弧度计算的逆时针角度。</p><pre><code class="python">The modulus r is the distance from z to the origin, while the phase phi is the counterclockwise angle, measured in radians, from the positive x-axis to the line segment that joins the origin to z</code></pre><p>有关于复数极坐标的转换函数可以查看：<a href="https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculationsCmathModule/">Python运算(三)cmath模块</a></p><h2 id="Decimal-十进制定点和浮点数"><a href="#Decimal-十进制定点和浮点数" class="headerlink" title="Decimal(十进制定点和浮点数)"></a>Decimal(十进制定点和浮点数)</h2><p>Decimal能够快速正确舍入十进制，为十进制浮点运算提供支持。Decimal是基于浮点模型，方便十进制浮点数科学运算，并且提高来精确性。Decimal保留尾数零，如<code>1.30 + 1.70 = 3.00</code>, <code>1.20 *1.40 =1.6800</code> ;</p><p>具有严格相等不变量的会计或金融程序中，会优先选择Decimal类型，举例来说，<code>1.0-1.0</code> 结果恰好为0，但是在二进制数值中结果为<code>5.5511151231257827e-017</code>，虽然无限接近于0，但是仍然存在误差，若用Decimal则不会存在这样的误差，其结果为0；Decimal作为十进制的浮点数可以设置精度(默认为28个精度)</p><p>Decimal由<strong>十进制数</strong>、<strong>信号</strong>、和<strong>算数上下文</strong>组成。</p><h3 id="Decimal构成——十进制数"><a href="#Decimal构成——十进制数" class="headerlink" title="Decimal构成——十进制数"></a>Decimal构成——十进制数</h3><p>值的注意的是Decimal中的十进制数与整型的十进制数并不完全相同，Decimal中的十进制数由符号、系数数字和指数构成，系数数字不截断尾数零，并且十进制数包括特殊字符(如：<code>Infinity</code>、<code>-Infinity</code>以及<code>NaN</code>)，并且还区分<code>-0</code> 和 <code>+ 0</code>即代表同样都是0但是<code>-0</code> 和<code>+0</code> 在Decimal中是两个不同的数字。</p><p>如：利用整数、字符串、浮点或元组(这些类型后面会讲到)构造十进制实例，<strong>NaN 在这里并不代表空值，而是代表”非数字”</strong>。</p><pre><code class="python">&gt;&gt;&gt; getcontext().prec = 6&gt;&gt;&gt; Decimal(10)Decimal(&#39;10&#39;)&gt;&gt;&gt; Decimal(&#39;3.1415&#39;)Decimal(&#39;3.1415&#39;)&gt;&gt;&gt; Decimal(3.14)Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)&gt;&gt;&gt; Decimal((0,(3,1,4),-2))Decimal(&#39;3.14&#39;)&gt;&gt;&gt; Decimal(str(2.0**0.5))Decimal(&#39;1.4142135623730951&#39;)&gt;&gt;&gt; Decimal(2) ** Decimal(&#39;0.5&#39;)Decimal(&#39;1.41421&#39;)&gt;&gt;&gt; Decimal(&#39;NaN&#39;)Decimal(&#39;NaN&#39;)&gt;&gt;&gt; Decimal(&#39;-Infinity&#39;)Decimal(&#39;-Infinity&#39;)</code></pre><p>若Decimal(value)中并没有给value赋值，则会返回<code>Decimal(&#39;0&#39;)</code>。</p><p>如果value是tuple，则有三个组件，一个符号、一个数字的tuple、和整数指数，如上面的代码<code>Decimal((0,(3,1,4),-2))</code> ，返回<code>Decimal(&#39;3.14&#39;)</code></p><p>如果value是float，则二进制浮点值无损地转换为其精确的十进制等效值。该转换通常需要50位精度或更高位数的精度转换，例如上面代码中<code>Decimal(3.14)</code>转换为<code>Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)</code></p><h3 id="Decimal构成——信号"><a href="#Decimal构成——信号" class="headerlink" title="Decimal构成——信号"></a>Decimal构成——信号</h3><p>信号是计算过程中出现的异常条件。根据程序需要，信号有时会被忽略，有时被视为信息，也有可能被视为异常。每个信号，由一个标志和一个陷阱启动器构成，遇到信号时，其标志设置为 1 ，若陷阱启用器设置为 1 ，则引发异常，并且用户需要在监控计算之前重置标志。信号有<a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Clamped"><code>Clamped</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.InvalidOperation"><code>InvalidOperation</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.DivisionByZero"><code>DivisionByZero</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Inexact"><code>Inexact</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Rounded"><code>Rounded</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Subnormal"><code>Subnormal</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Overflow"><code>Overflow</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Underflow"><code>Underflow</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.FloatOperation"><code>FloatOperation</code></a>。</p><p>若FloatOperation信号被捕获，若使用浮点数进行构造Decimal或者浮点数做排序和比较运算，则会抛出异常,但等于比较不会引发异常。</p><pre><code class="python">&gt;&gt;&gt; context = getcontext()&gt;&gt;&gt; context.traps[FloatOperation] = True&gt;&gt;&gt; Decimal(3.14)Traceback (most recent call last):  File &quot;&lt;pyshell#23&gt;&quot;, line 1, in &lt;module&gt;    Decimal(3.14)decimal.FloatOperation: [&lt;class &#39;decimal.FloatOperation&#39;&gt;]&gt;&gt;&gt; Decimal(&#39;3.4&#39;) &lt; 3.5Traceback (most recent call last):  File &quot;&lt;pyshell#24&gt;&quot;, line 1, in &lt;module&gt;    Decimal(&#39;3.4&#39;) &lt; 3.5decimal.FloatOperation: [&lt;class &#39;decimal.FloatOperation&#39;&gt;]&gt;&gt;&gt; Decimal(&#39;3.5&#39;)==3.5True</code></pre><h3 id="Decimal构成——算术上下文"><a href="#Decimal构成——算术上下文" class="headerlink" title="Decimal构成——算术上下文"></a>Decimal构成——算术上下文</h3><p>算术上下文是指精度、舍入规则、指数限制、指示操作结果的标志以及信号被视为异常的陷阱启动器的环境。</p><p>舍入选项包括 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_CEILING"><code>ROUND_CEILING</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_DOWN"><code>ROUND_DOWN</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_FLOOR"><code>ROUND_FLOOR</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_HALF_DOWN"><code>ROUND_HALF_DOWN</code></a>, <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_HALF_EVEN"><code>ROUND_HALF_EVEN</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_HALF_UP"><code>ROUND_HALF_UP</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_UP"><code>ROUND_UP</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_05UP"><code>ROUND_05UP</code></a>。 用函数getcontext()可以访问当前上下文，并可以更改设置。Context()函数可以创建算数上下文，若启用备用上下文，则需要setcontext()函数。</p><pre><code class="python">&gt;&gt;&gt; from decimal import *&gt;&gt;&gt; getcontext()Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])&gt;&gt;&gt; getcontext().prec = 6</code></pre><p> Decimal提供了两个现成的上下文<strong>BasicContext</strong> 和 <strong>ExtendedContext</strong>，<strong>BasicContext</strong>启用了许多陷阱对调试起到很大作用。算数上下文的另一个作用就是监视计算期间遇到的异常情况信号标志，举例见上文中信号部分示例。</p><h3 id="Decimal-常数"><a href="#Decimal-常数" class="headerlink" title="Decimal 常数"></a>Decimal 常数</h3><p>常数是C语言模块，但是完全可以和Python和谐共存。其中Decimal的常数有：</p><table><thead><tr><th>常数名称</th><th>32-bit</th><th>64-bit</th></tr></thead><tbody><tr><td>decimal.MAX_PREC</td><td>425000000</td><td>999999999999999999</td></tr><tr><td>decimal.MAX_EMAX</td><td>425000000</td><td>999999999999999999</td></tr><tr><td>decimal.MIN_EMIN</td><td>-425000000</td><td>-999999999999999999</td></tr><tr><td>decimal.MIN_ETINY</td><td>-849999999</td><td>-1999999999999999997</td></tr></tbody></table><p>另外，还有一个比较特别的常数 <code>decimal.HAVE_THREADS</code>, 默认值为<code>True</code>，但如果Python被编译的时候没有开辟线程，C会自动的杀死本地运行环境中开销比较大的线程，这种情况下，值为<code>False</code></p><h3 id="Decimal方法"><a href="#Decimal方法" class="headerlink" title="Decimal方法"></a>Decimal方法</h3><p>除了标准的数字属性，Decimal也有许多专门方法，并且方法很多</p><table><thead><tr><th style="text-align:left">方法名</th><th>含义</th><th>代码示例</th></tr></thead><tbody><tr><td style="text-align:left">adjuested()</td><td>移除系数最右边数字之后返回调整后的指数，直到只剩下前导数字</td><td></td></tr><tr><td style="text-align:left">as_integer_ratio()</td><td>返回一对(n,d)整数，表示给Decimal实例作为分数最简形式并带正分母</td><td>&gt;&gt;&gt; Decimal(‘-3.14’).as_integer_ratio()<br>(-157, 50)</td></tr><tr><td style="text-align:left">as_tuple()</td><td>返回一个tuple表示的数值</td><td>DecimalTuple(sign, digits, exponent)</td></tr><tr><td style="text-align:left">canonical()</td><td>返回参数的规范编码</td><td></td></tr><tr><td style="text-align:left">compare()</td><td>比较两个Decimal实例的值</td><td>a or b is a NaN  ==&gt; Decimal(‘NaN’)                 a &lt; b            ==&gt; Decimal(‘-1’)                              a == b           ==&gt; Decimal(‘0’)                                  a &gt; b            ==&gt; Decimal(‘1’)</td></tr><tr><td style="text-align:left">compare_signal()</td><td>除了所有的NaN信号之外，此操作与compare()方法相同</td><td></td></tr><tr><td style="text-align:left">compare_total()</td><td>使用抽象表示来比较 两个操作数</td><td></td></tr><tr><td style="text-align:left">compare_total_mag</td><td>使用抽象表示来比较，但忽略操作数的符号</td><td></td></tr><tr><td style="text-align:left">conjugate()</td><td>返回自身，只符合Decimal规范</td><td></td></tr><tr><td style="text-align:left">copy_abs()</td><td>返回参数的绝对值，操作不受上下文影响，不执行舍入</td><td></td></tr><tr><td style="text-align:left">copy_negate()</td><td>返回参数的否定值，符号设置与第二个操作数符号相同</td><td>&gt;&gt;&gt; Decimal(‘2.3’).copy_sign(Decimal(‘-1.5’)) Decimal(‘-2.3’)</td></tr><tr><td style="text-align:left">exp(context=None)</td><td>返回给定数字的指数函数，结果使用ROUND_HALF_EVEN模式舍入</td><td>&gt;&gt;&gt; Decimal(1).exp() Decimal(‘2.718281828459045235360287471’)     &gt;&gt;&gt; Decimal(321).exp() Decimal(‘2.561702493119680037517373933E+139’)</td></tr><tr><td style="text-align:left">from_float()</td><td>将浮点数转换为十进制数，Python3.2之后可以直接用float构造</td><td></td></tr><tr><td style="text-align:left">fma(other,third,context=None)</td><td>混合乘法加法，返回self *other+third，乘积不会四舍五入</td><td>&gt;&gt;&gt; Decimal(2).fma(3, 5)                                   Decimal(‘11’)</td></tr><tr><td style="text-align:left">is_canonical()</td><td>参数是规范的，则为返回 [<code>True</code>]，否则为 [<code>False</code>]</td><td></td></tr><tr><td style="text-align:left">is_finite()</td><td>参数是有限数 则返回True，否则返回Fasle</td><td></td></tr><tr><td style="text-align:left">is_infinite()</td><td>参数为正负无穷大，则返回True，否则为False</td><td></td></tr><tr><td style="text-align:left">is_nan()</td><td>如果参数为Nan，则返回True，否则返回False</td><td></td></tr><tr><td style="text-align:left">is_normal(context=None)</td><td>如果参数是一个有限正规数，返回 <code>True</code>，如果参数是0、次正规数、无穷大或是NaN，返回 <code>False</code></td><td></td></tr><tr><td style="text-align:left">is_qnan()</td><td>同is_nan()</td><td></td></tr><tr><td style="text-align:left">is_signed()</td><td>如果参数带有负数，返回True，否则返回False</td><td></td></tr><tr><td style="text-align:left">is_snan()</td><td>如果参数为显示NaN，则返回True，否则返回False</td><td></td></tr><tr><td style="text-align:left">is_subnormal(context=None)</td><td>如果参数为低于给定值，则返回 True，否则返回 False。</td><td></td></tr><tr><td style="text-align:left">is_zero()</td><td>如果参数是0(正负皆可)，则返回True，否则返回False</td></tr></tbody></table><p>Decimal参数很多，这里不一一列举了，更多函数可以参考<a href="https://docs.python.org/3.6/library/decimal.html">Deccimal标准库</a></p><h3 id="Decimal-注意点"><a href="#Decimal-注意点" class="headerlink" title="Decimal 注意点"></a>Decimal 注意点</h3><p>新版本Python3.3之后，congtext精度不会影响存储的位数，完全由value中的位数决定，context精度和舍入仅在算数期间发挥作用。context参数的目的是确定value是格式错误的字符串时该怎么做，如果context陷阱<a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.InvalidOperation"><code>InvalidOperation</code></a>则引发 异常，否则构造函数返回一个新的Decimal，其值为NaN。构造完成后Decimal对象是不可变的。Python3.6之后允许下划线进行分组。</p><pre><code class="python">&gt;&gt;&gt; from decimal import *&gt;&gt;&gt; getcontext().prec = 6&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;)Decimal(&#39;3.1415926535&#39;)&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;) + Decimal(&#39;2.7182818285&#39;)Decimal(&#39;5.85987&#39;)&gt;&gt;&gt; getcontext().rounding = ROUND_UP&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;) + Decimal(&#39;2.7182818285&#39;)Decimal(&#39;5.85988&#39;)</code></pre><h2 id="Fraction-分数-："><a href="#Fraction-分数-：" class="headerlink" title="Fraction(分数)："></a>Fraction(分数)：</h2><p>Fraction分数类型可以由一系列整型数值，或其它数字类型，又或者是string(字符串)构造。</p><h3 id="Fraction构建方式"><a href="#Fraction构建方式" class="headerlink" title="Fraction构建方式"></a>Fraction构建方式</h3><p>Fraction构建形式为:</p><pre><code class="python">Fraction(numerator=0, denominator=1)Fraction(other_fraction)Fraction(float)Fraction(decimal)Fraction(string)</code></pre><p>第一种构建方式，需要一个符合数字类型的数值当分子，和一个符合数字类型的数值当分母，构造函数会返回一个<code>分子/分母</code>值的Fraction实例。众所周知，分数分母不能为0，如果分母为0，会出现<code>ZeroDivisionError</code>的错误。</p><p>第二种构建方式也必须要求是一个符合数字类型的数值当分子，返回同样值的一个fraction分数实例。</p><p>第三种和第四种构建方式接受数字类型为float类型和Decimal类型，返回一个精确的具有同样数值大小的Fraction分数实例。不过由于二进制浮点数问题，类似于Fraction(1.1)并不能准确地返回类似于Fration(11,10)这样的分数实例。具体的构建规则，由函数<code>limit_denominator()</code>决定(该函数后面会涉及)。</p><p>最后一种构建方式用string字符串类型或unicode类型构建，一般形式为:</p><p><code>[符号] 分子&#39;/&#39;分母</code> 如:<code>Fraction(&#39;-3/7&#39;)</code></p><pre><code class="python">&gt;&gt;&gt; from fractions import Fraction&gt;&gt;&gt;#第一种构建方式&gt;&gt;&gt; Fraction(-4, 5)Fraction(-4, 5)&gt;&gt;&gt; Fraction(3, 8)Fraction(3, 8)&gt;&gt;&gt;#第二种构建方式&gt;&gt;&gt; Fraction()Fraction(0, 1)&gt;&gt;&gt;#第三种构建方式&gt;&gt;&gt; Fraction(2.30)Fraction(2589569785738035, 1125899906842624)&gt;&gt;&gt; Fraction(Decimal (&#39;1.1&#39;))Fraction(11, 10)&gt;&gt;&gt;#第四种构建方式&gt;&gt;&gt; Fraction(&#39;-3/7&#39;)Fraction(-3, 7)&gt;&gt;&gt; Fraction(&#39;7e-6&#39;)Fraction(7, 1000000)</code></pre><p>Fraction类型继承字基本数据类型(numbers.Rational)，并继承了基类中的方法和操作。Fraction类型能够进行哈希运算，并且是不可变类型。</p><h3 id="Fraction属性和方法"><a href="#Fraction属性和方法" class="headerlink" title="Fraction属性和方法"></a>Fraction属性和方法</h3><p>属性：</p><p>numerator： 分子</p><p>denominator:  分母</p><p>方法：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:center">含义</th><th style="text-align:left">代码</th></tr></thead><tbody><tr><td style="text-align:left">from_float(flt)</td><td style="text-align:center">类方法，用float构建Fraction实例 Python3.2之后的方法</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">from_decimal(dec)</td><td style="text-align:center">类方法，用Decimal构建Fraction实例，同样是Python3.2之后才有</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">limit_denominator (max_denominator=100000)</td><td style="text-align:center">查找并返回一个和构造Fraction类数值接近，且分母是不超过设置的max_denominator的最大分母；该方法用来寻找与给定浮点数相近比例数，以及纠正一个近似float类型的比例数值</td><td style="text-align:left">&gt;&gt;&gt; from fractions import Fraction<br>&gt;&gt;&gt; Fraction(‘3.1415926’).limit_denominator(1000)<br>Fraction(355, 113)<br>&gt;&gt;&gt; from math import pi, cos<br>&gt;&gt;&gt; Fraction(cos(pi/3))<br>Fraction(4503599627370497, 9007199254740992)<br>&gt;&gt;&gt; Fraction(cos(pi/3)).limit_denominator()<br>Fraction(1, 2)<br>&gt;&gt;&gt; Fraction(1.1).limit_denominator()<br>Fraction(11, 10)<br>&gt;&gt;&gt;</td></tr><tr><td style="text-align:left"><strong>floor</strong>()</td><td style="text-align:center">返回一个&lt;= 分数自身的 int类型值，也可用数学模块中的math.floor()</td><td style="text-align:left">&gt;&gt;&gt; from math import floor<br>&gt;&gt;&gt; floor(Fraction(335,113))<br>2</td></tr><tr><td style="text-align:left"><strong>ceil</strong>()</td><td style="text-align:center">返回一个&gt;=分数自身的最小int值，同样可以用数学模块中的math.ceil()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>round</strong>() /<strong>round</strong>(ndigits)</td><td style="text-align:center">round()返回Fraction的四舍五入最接近的int值; round(ndigits)返回Fraction(1, 10*ndigits)最接近的倍数数</td><td style="text-align:left">&gt;&gt;&gt; round(Fraction(4.8))<br>5<br>&gt;&gt;&gt; round(Fraction(4.5))<br>4<br>&gt;&gt;&gt; round(Fraction(4.3))<br>4<br>&gt;&gt;&gt; round(Fraction(4.389089), 3)<br>Fraction(4389, 1000)</td></tr><tr><td style="text-align:left">fractions.gcd(a,b)</td><td style="text-align:center">返回整数a和b最大公约数, Python3.5之后用math.gcd()代替</td><td style="text-align:left">&gt;&gt;&gt; import fractions<br>&gt;&gt;&gt; fractions.gcd(2,3)<br>1<br>&gt;&gt;&gt; fractions.gcd(36, 24)<br>12</td></tr></tbody></table><h3 id="round-函数注意点"><a href="#round-函数注意点" class="headerlink" title="round()函数注意点"></a>round()函数注意点</h3><p>round()默认会进行四舍五入，但我们发现在上面的代码中</p><pre><code class="python">&gt;&gt;&gt; round(Fraction(4.5))4</code></pre><p>4.5四舍五入值应该为5，但是给出的结果是4。</p><p>这是因为Python3.5 之后round()函数如果遇到浮点距离两边一样远，会保留到偶数那一边，doc中的原话为：”values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice.”  </p><p>因为4.5 距离4 和距离5 都是0.5的距离，但因为4是偶数，所以最后结果是偶数4。如果是5.5的话，结果就是6</p><pre><code class="python">&gt;&gt;&gt; round(5.5)6</code></pre><p>不过在Pyton2 中就不会有这个问题，round()函数会保留到离上一位更近的一端，即远离0的一端。</p><p>瞬间是不是觉得有点坑，如果代码从Python2 迁移到Python3 涉及到了大量round()函数的话，就比较坑，所以建议如果是要进行数据运算，还是尽量使用math或cmath模块中的函数。</p><p>此外，除来以上问题之外，还存在着一个问题：<strong>浮点数精度问题</strong></p><p>例如代码</p><pre><code class="py">&gt;&gt;&gt; round (2.565, 2)2.56</code></pre><p>无论是Python2 还算Python3 以上代码得到的结果都是2.56，显然这不符合常理。这是<strong>因为数字的存储都是用二进制，如果换算成二进制后一串1和0后可能是无限位数的，机器已经做出了截断处理，那么2565这个数字就比实际数字要小一点点</strong>。这一点点就导致了它离2.56要更近一点点，所以保留两位小数时就近似到了2.56。</p><p>那round()函数对精度把控不准，有替代函数吗？</p><p>1.像上面提到的，使用math中函数替代 ，如math.ceiling</p><p>2.Python自带整除//</p><p>3.可以将浮点型做截断转成字符串</p><p>有关具体的各类Number运算，详见：<a href="https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculations/">Python运算(-)数值、哈希、布尔等运算</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python3有六个标准数据类型：&lt;/p&gt;
&lt;p&gt;.不可变数据类型：&lt;strong&gt;Number(数字)、String(字符串)、Tuple(元组)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.可变数据类型： &lt;strong&gt;List(列表)、Dictionary(字典)、Set(集
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python前篇</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/Pythonbrief/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/Pythonbrief/</id>
    <published>2018-05-01T05:34:08.000Z</published>
    <updated>2019-05-07T02:05:50.562Z</updated>
    
    <content type="html"><![CDATA[<p>Python是一种解释型语言，一门完善的面向对象高级编程语言，无需编译和链接，为编写大型程序提供更多的结构和支持，并且与Shell脚本相比，适合编写GUI应用程序或游戏。Python提供大量的多种类型标准模块，模块提供了诸如I/O、 系统调用、Socket支持、用户图形（GUI工具）、机器学习、可视化等；内置高级的数据结构类型，为数据分析提供了更多支持；Python是可扩展的，可以将Python解释器集成进其它应用程序。</p><p><strong>Python学习建议</strong>：对于学习Python的建议是可以先敲几行代码，再回头看具体的类型和语法解释，因为这样会理解深刻，地基也能打的更牢靠。然后在这一组循环结束之后，再进行Python高阶学习，效率会更高。</p><p>个人认为的Python的优点： 每种语言都有自己的特点，之所以选择学习Python，是认可了Python对数字类型、字符串 强大的处理能力，以及对数据结构的扩展，这两点对数据清洗、数据存储和操作有很大帮助。</p><p>Python官网：<a href="https://www.python.org/">https://www.python.org/</a></p><h2 id="Python下载安装"><a href="#Python下载安装" class="headerlink" title="Python下载安装"></a>Python下载安装</h2><p>官网地址<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>提供各种版本的平台安装包，可以根据自己电脑版本下载对应的平台包。本人电脑是Mac 版，所以安装的Mac OS X平台包。不过Mac系统自带Python2.7环境，可以打开Termail 输入<code>Python -v</code>查看版本号，或者打开Python自带的IDLE，解释器开头会有Python环境的描述。因为本人要学习Python3，所以保留了自带的Python2.7环境，又下载来Python3.6，同时存在两种版本。若只想将Python2.7升级到Python3.6，则需要将下载后的Python3.6 替换原有的Python2.7。 </p><p>通常Python安装目录是:<code>/usr/local/bin</code>  ,如果是windows，安装目录一般是<code>C:\Python36</code>, 这里目录并不是固定Python36，如果安装版本是3.5，则目录就是<code>C:\Python35</code></p><h2 id="Python-IDE：模式-amp-类型"><a href="#Python-IDE：模式-amp-类型" class="headerlink" title="Python IDE：模式&amp;类型"></a>Python IDE：模式&amp;类型</h2><p>Python运行，需要通过IDE，Python IDE有很多种，例如：IDLE、PyCharm、Sublime Text、iPython、Vim、Eclipse + PyDev、jupyter、notebook+spyder3 等，可以根据个人习惯安装适合的IDE，以JAVA开发为主的编程人员可能更习惯使用Eclipse，不太会编码的人员可能使用notebook+spyder3更普遍，不过本人使用最频繁的IDE是Pycharm，Pycharm自带错误提示和输入提示，节约编码时间，提高编码效率，并且适合编写爬虫。</p><p>以上IDE中有IDE是工作在交互模式下，例如IDLE，打开IDLE会发现每行都以<code>&gt;&gt;&gt;</code>开头，<code>&gt;&gt;&gt;</code>是主标识符。若解释器从tty读取命名，则称解释器工作于<strong>交互模式</strong>，IDLE就是工作于交互模式的解释器，这种模式是根据主提示符来执行，主提示符通常情况下标识为三个大于号<code>&gt;&gt;&gt;</code> ，继续部分称为从属提示符，通常是三个点<code>...</code>,</p><p>在第一行主提示符之前，IDE打印欢迎信息、版本号和授权提示，这就是我们打开Python安装包自带的IDLE就能查看版本号的原因。因为交互模式的工作方式，每行代码敲完后都需要回车，回车之后会继续有三个大于号<code>&gt;&gt;&gt;</code> 的提示符，再继续输入后面的内容。脚本式编程的IDE 不会有提示符，代码编写完成后再运行即可。</p><h2 id="Python-IDE-环境设计"><a href="#Python-IDE-环境设计" class="headerlink" title="Python IDE 环境设计"></a>Python IDE 环境设计</h2><p>Python3 之前默认的编码格式是ASCII格式，在没有修改编码格式之前无法打印汉字，不过Python3 之后这个问题不存在，默认情况下源码文件以<strong>UTF-8</strong>编码。若使用的Python3之前的版本，则在编写程序之间需要添加一行注释：</p><pre><code class="python"># -*- coding: utf-8 -*-</code></pre><p>若要支持其它文字，则需要输入对应的编码格式。</p><p>针对部分IDE，可以统一设置编码格式，统一设置编码格式后则不需要在每次编码的时候添加注释。统一设置一般是在setting(mac版为偏好设置)中，找到对应的File encodings 将其中的IDE Encoding和Project Encoding设置为utf-8</p><h2 id="Python-基础语法"><a href="#Python-基础语法" class="headerlink" title="Python 基础语法"></a>Python 基础语法</h2><h3 id="1-缩进问题"><a href="#1-缩进问题" class="headerlink" title="1.缩进问题"></a>1.缩进问题</h3><p>​    缩进在Python中作为语法出现，表示代码的层级关系，同一个代码块的语句必须包含相同的缩进空格数。所以空格缩进问题要特别注意，多一个空格或少空格会造成语法错误。</p><pre><code class="python">IndentationError: unindent does not match any outer indentation level</code></pre><h3 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2.标识符"></a>2.标识符</h3><p>标识符由字母、数字、下划线构成，第一个字符必须是字母表中字母或下划线<code>_</code>，并且标识符区分大小写。以下划线开头的标识符有特殊含义， 单下划线开头<code>_modelorclassname</code>代表不能直接访问的类属性,需通过类提供的接口进行访问，不能用<code>from xxx import *</code>导入；双下划线开头<code>__propertyname</code>代表类的私有成员；以双下划线开头和结尾的<code>__name__</code> 是Python特殊方法专用表示，如<code>__init()__</code>代表类的构造函数。此外，Python3 现在可以接收非ASCII字符。</p><h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3.注释"></a>3.注释</h3><p>单行注释用<strong>#</strong>开头，多行注释可以用多个#号，或者是三个单引号’’’，或者三个双引号”””</p><pre><code class="python">#Python简介#Python基础语法&#39;&#39;&#39;Python简介Python基础语法&#39;&#39;&#39;&quot;&quot;&quot;Python简介Python基础语法&quot;&quot;&quot;</code></pre><h3 id="4-保留字"><a href="#4-保留字" class="headerlink" title="4.保留字"></a>4.保留字</h3><p>保留字是Python系统的关键字，所以开发者不能用来当标识符。Python3中可以查看所有保留字</p><pre><code class="python">&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</code></pre><h3 id="5-多行语句"><a href="#5-多行语句" class="headerlink" title="5.多行语句"></a>5.多行语句</h3><p>在[],{},()中的语句可以直接回车换行进行多行语句书写，但非以上结构中的语句，要想换行写必须使用反斜杠<code>\</code>。</p><pre><code class="python">number = 120000000 + 2000000000 + \                 3424546 + 58690765465\               234567789 + 5678900</code></pre><h3 id="6-标点符号问题"><a href="#6-标点符号问题" class="headerlink" title="6.标点符号问题"></a>6.标点符号问题</h3><p>Python环境中，除了Python流程控制函数后需要输入冒号以此来区分控制语句的多行代码，其它情况每行代码后无需加任何标点符号。</p><h3 id="7-空行"><a href="#7-空行" class="headerlink" title="7.空行"></a>7.空行</h3><p>空行在Python中也是程序代码的一部分，但空行并不是Python语法的一部分。函数之间、类的方法之间用空行分隔，表式一段新的代码的开始，不插入空行也不会报错。</p><h3 id="8-一行显示多条语句"><a href="#8-一行显示多条语句" class="headerlink" title="8.一行显示多条语句"></a>8.一行显示多条语句</h3><p>Python中可以在同一行中写多条语句，这个时候语句之间要使用分号<strong>；</strong>分割。交互式IDE中会一次性输出多条语句的执行结果。</p><h3 id="9-多个语句构成代码组"><a href="#9-多个语句构成代码组" class="headerlink" title="9. 多个语句构成代码组"></a>9. 多个语句构成代码组</h3><p>前面讲到缩进相同的代码代表同一个层级，这些代码构成来一个代码块，称为代码组。</p><p><strong>if</strong>、<strong>while</strong>等控制语句就会形成代码组。以及自定义函数<strong>def</strong> 或 <strong>class</strong>后面可以形成代码组。 交互式系统中代码组最后一行必须是空行 以此来表示代码组结束。</p><h3 id="10-import-与-from-…-import"><a href="#10-import-与-from-…-import" class="headerlink" title="10. import 与 from … import"></a>10. import 与 from … import</h3><p>Python中导入模块有<strong>import</strong>与<strong>form…import</strong>两种方式。整个模块导入用import格式，从某个模块中导入某个函数使用from…import个数。多个模块导入或某个模块导入多个函数，则在模块或特定函数之间用逗号<strong>,</strong>分割</p><pre><code class="python">import modulenameimport moduleone,moduletwofrom modulename import funcnamefrom modulename import funcone,functwo</code></pre><h3 id="11-模块下载"><a href="#11-模块下载" class="headerlink" title="11.模块下载"></a>11.模块下载</h3><p>Python具有兼容性，许多第三方module要自己下载，打开Terimal,输入：</p><pre><code class="python">python -m install modulename  #modulename 为要下载的部件名称</code></pre><p>如果电脑上有多个Python版本，需要指定Python版本进行下载</p><pre><code class="python">python3 -m install modulename </code></pre><h3 id="12-命令行参数"><a href="#12-命令行参数" class="headerlink" title="12. 命令行参数"></a>12. 命令行参数</h3><p>在Terimal中使用<strong>-h</strong>参数可以查看各参数帮助信息：</p><pre><code class="python">apple@muyingdeMacBook-Pro ~&gt; python -husage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...Options and arguments (and corresponding environment variables):-B     : don&#39;t write .py[co] files on import; also PYTHONDONTWRITEBYTECODE=x-c cmd : program passed in as string (terminates option list)-d     : debug output from parser; also PYTHONDEBUG=x-E     : ignore PYTHON* environment variables (such as PYTHONPATH)-h     : print this help message and exit (also --help)-i     : inspect interactively after running script; forces a prompt even         if stdin does not appear to be a terminal; also PYTHONINSPECT=x-m mod : run library module as a script (terminates option list)-O     : optimize generated bytecode slightly; also PYTHONOPTIMIZE=x-OO    : remove doc-strings in addition to the -O optimizations-R     : use a pseudo-random salt to make hash() values of various types be         unpredictable between separate invocations of the interpreter, as         a defense against denial-of-service attacks-Q arg : division options: -Qold (default), -Qwarn, -Qwarnall, -Qnew-s     : don&#39;t add user site directory to sys.path; also PYTHONNOUSERSITE-S     : don&#39;t imply &#39;import site&#39; on initialization-t     : issue warnings about inconsistent tab usage (-tt: issue errors)-u     : unbuffered binary stdout and stderr; also PYTHONUNBUFFERED=x         see man page for details on internal buffering relating to &#39;-u&#39;-v     : verbose (trace import statements); also PYTHONVERBOSE=x         can be supplied multiple times to increase verbosity-V     : print the Python version number and exit (also --version)-W arg : warning control; arg is action:message:category:module:lineno         also PYTHONWARNINGS=arg-x     : skip first line of source, allowing use of non-Unix forms of #!cmd-3     : warn about Python 3.x incompatibilities that 2to3 cannot trivially fixfile   : program read from script file-      : program read from stdin (default; interactive mode if a tty)arg ...: arguments passed to program in sys.argv[1:]Other environment variables:PYTHONSTARTUP: file executed on interactive startup (no default)PYTHONPATH   : &#39;:&#39;-separated list of directories prefixed to the               default module search path.  The result is sys.path.PYTHONHOME   : alternate &lt;prefix&gt; directory (or &lt;prefix&gt;:&lt;exec_prefix&gt;).               The default module search path uses &lt;prefix&gt;/pythonX.X.PYTHONCASEOK : ignore case in &#39;import&#39; statements (Windows).PYTHONIOENCODING: Encoding[:errors] used for stdin/stdout/stderr.PYTHONHASHSEED: if this variable is set to &#39;random&#39;, the effect is the same   as specifying the -R option: a random value is used to seed the hashes of   str, bytes and datetime objects.  It can also be set to an integer   in the range [0,4294967295] to get hash values with a predictable seed.</code></pre><p>此外，Python提供来<strong>getopt</strong>模块获取命令行参数， 或者用<strong>sys</strong> 模块的<strong>sys.argv</strong>获取命令行参数</p><h4 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块:"></a>sys模块:</h4><p><code>sys.argv[0]表示脚本名</code></p><p><code>sys.argv是命令行参数列表</code></p><p><code>len(sys.argv)是命令行参数个数</code></p><p>.py文件(.py为Python文件的后缀)中：</p><pre><code class="python">import sysprint (&#39;命令行参数个数为:&#39;, len(sys.argv))pring (&#39;命令行参数列表:&#39;, str(sys.argv)) </code></pre><p>执行和输出结果为:</p><pre><code class="python">python3 classname.py arg1 arg2输出结果：命令行参数个数为： 4命令行参数列表：[&#39;classname.py&#39;, &#39;arg1&#39;, &#39;arg2&#39;]</code></pre><h4 id="getopt模块"><a href="#getopt模块" class="headerlink" title="getopt模块"></a>getopt模块</h4><p>getopt模块专门处理命令行参数，用于获取命令行选型和参数支持短选项模式<code>-</code>和长选项模式<code>—</code></p><p>模块中共有：两个方法；一个异常。 用来处理解析命令行参数。</p><p><strong>getopt</strong>方法：</p><p>此方法解析命令行参数列表：</p><pre><code class="python">getopt.getopt(args, options[, long_options])</code></pre><p>方法参数说明:</p><p>args：要解析的命令行参数列表</p><p>options: 以字符串格式定义，options后的冒号: 表示该选项必须有附加的参数，没有则代表不需要附加参数。</p><p>long_options ： 列表格式定义，long_options 后的等号表示如果设置该选项，必须有附加的参数，否则就不附加参数。</p><p>返回值由两个元素组成：第一个是 <strong>(option, value)</strong> 元组的列表。 第二个是参数列表，包含那些没有’-‘或’–’的参数。</p><p><strong>gnu_getopt</strong>方法:</p><p>getopt.getopt方法在遇到第一个不符合设置的参数时就会自动忽略，而gnu_getopt方法则不会存在这样的情况，即使参数不符合设定也会将结果输出出来，能够得到全部的命令行参数。</p><p><strong>GetoptError</strong>异常：</p><p>没有找到参数列表或选项需要的参数为空时会触发此异常。异常的参数是一个字符串，表示错误的原因。属性msg和opt为相关选项的错误信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python是一种解释型语言，一门完善的面向对象高级编程语言，无需编译和链接，为编写大型程序提供更多的结构和支持，并且与Shell脚本相比，适合编写GUI应用程序或游戏。Python提供大量的多种类型标准模块，模块提供了诸如I/O、 系统调用、Socket支持、用户图形（G
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网络连接过程</title>
    <link href="https://onlyangelia.github.io/computerIntnet/intnetlink/"/>
    <id>https://onlyangelia.github.io/computerIntnet/intnetlink/</id>
    <published>2018-03-07T14:02:04.000Z</published>
    <updated>2019-04-30T14:30:59.890Z</updated>
    
    <content type="html"><![CDATA[<p>讲解连接过程之前，先解释几点，给后面的阐述做铺垫。在我们的电脑启动时，会通过<strong>DHCP协议(也是属于应用层的协议，基于UDP协议，全程 Dynamic Host Configuration Protocol ：动态主机配置协议)</strong> 进行动态配置IP地址（当然也可以手动配置IP，一般人不会这么做），并且我们的电脑会有对应的唯一的<strong>MAC地址（MAC全称：Media Access Control，媒体访问控制）</strong>，发送网络包，目标地址既要包括IP地址，也要包含MAC地址。IP地址类似于住址，MAC地址类似于身份证，两者缺一不可。IP地址和MAC地址的映射可以通过<strong>APR协议(全称：Address Resolution Protocol 地址解析协议，是属于链路层的协议 )</strong> 查询。记住IP地址和MAC地址这两个概念。</p><p>​<br>在<strong>TCP/IP五层模型</strong>下，通过在浏览器中浏览网页，我们来梳理下网络的连接过程。比如，我们在浏览器输入：<a href="https://onlyAnglia.github.io">https://onlyAnglia.github.io</a> ，按下回车，到浏览器中显示出博客内容中间经历了哪些过程？先简单的讲下HTTP的连接，再在HTTP的基础上补充HTTPS的连接。当然应用层还有许多协议，例如RTMP、QUIC、GTP等，有基于TCP的，也有基于UDP的。这里举例用基于TCP的HTTP协议，有关传输层常用的协议UDP 和 TCP连接不同和详细的连接过程，后面会单独写解释,接下来看一下网络的连接。</p><p>整体的传输流程如下：<br><img src="/computerIntnet/intnetlink/TCP-IP五层模型数据传输.png" alt></p><p>首先，机器和人不一样，并不能识别我们能熟记的域名，机器只认IP地址，所以</p><p><strong>step1：进行DNS解析，得到域名对应的IP地址</strong>(DNS解析比较复杂，这里只说下一般流程，有关<strong>负载均衡</strong>等暂且不提)</p><p>浏览器先在<strong>本地DNS</strong>缓存中查找onlyAnglia.github.io 对应的IP地址，若找到则返回对应的IP；倘若<strong>本地DNS缓存</strong>中未查找到域名对应的IP地址，则接下来会像<strong>本地DNS服务器</strong>询问（如果是通过<strong>DHCP</strong>配置，<strong>本地DNS服务器</strong>由对应的 <strong>网络服务商（ISP</strong>自动分配），如果找到就直接返回IP地址；若没有找到，<strong>本地DNS服务器</strong>会向它的<strong>根域名服务器</strong>询问,<strong>根域名服务器</strong>会告诉<strong>本地DNS服务器</strong>该向哪个<strong>顶级域名服务器</strong>询问，之后<strong>顶级域名服务器</strong>会告诉<strong>本地DNS服务器</strong>该向哪个<strong>权威域名服务器</strong>询问；接下来<strong>本地DNS服务器</strong>会找到对应的<strong>权威域名服务器</strong>查询对应的IP地址，<strong>权威服务器</strong>将对应的IP地址告诉<strong>本地DNS服务器</strong>，<strong>本地DNS服务器</strong>再将IP地址返回给浏览器，浏览器接收到对应的IP地址，准备开始建立连接。</p><p>​<br><strong>step2：使用HTTP协议，经过应用层包装</strong></p><p>查询到域名对应的IP地址之后表示请求访问的目标存在，可以进行访问。然后应用层请求构建<strong>HTTP</strong>，客户端的<strong>HTTP报文</strong>叫做<strong>请求报文</strong>，多数使用的还是<strong>HTTP1.1</strong>,在<strong>HTTP1.1</strong>的<strong>请求报文中</strong>包含了<strong>请求行</strong>、<strong>首部</strong>、<strong>正文实体</strong>。 其中，<strong>请求行</strong>包含用户<strong>请求的方法</strong>，<strong>请求URI</strong> 和 <strong>HTTP版本号</strong>。 例如：<code>POST  /form/entry  HTTP1.1</code>    <strong>首部字段</strong> 包含各种<strong>请求条件</strong>和<strong>请求属性</strong>，有些字段只是<strong>请求首部字段</strong>，部分是<strong>通用首部字段</strong>，还有一部分是<strong>实体首部字段</strong>(有关该部分可详见：<a href="https://github.com/onlyAngelia/Read-Mark/blob/master/HTTP/HTTP图解mark.md">HTTP协议简单解释</a>)。构建好请求报文后，通过<strong>stream二进制流</strong>传递给传输层。并且浏览器开启端口号监听。</p><p>​<br><strong>step3：传输层接收请求报文，构建请求段</strong>(传输层协议主要有UDP协议和TCP协议，HTTP是基于TCP协议)</p><p>应用层将请求报文传递给传输层后，传输层根据要使用的协议进行传输层报文的封装，在这里构建的是<strong>TCP包头</strong>，传输层构建好<strong>TCP包头</strong>后，将传输来的流信息作为数据项。<strong>TCP的包头</strong>比较复杂,这和<strong>TCP</strong>的可靠连接有关，此时到了传输层后内核会开启，监听端口号，等待接下来的回应。（一般机器中会有一个网卡，也有部分机器会装有多个网卡）此时浏览器处于<strong>SYN-SENT</strong>状态。<br><img src="/computerIntnet/intnetlink/TCP包头.jpg" alt> </p><p>​<br><strong>step4：网络层接收传输层的段，构建IP包</strong>（网络传输二层叫帧，网络层叫包，传输层叫段）</p><p>网络层在接收到传输层传过来的<strong>TCP包</strong>后，第一个任务是封装<strong>IP包</strong>，将应用层传输过来的TCP包作为数据项，添加IP首部，形成IP包。传输层TCP协议的包头首部中包含了源端口号、目的端口号，在网络层IP协议要将<strong>源地址</strong>、<strong>目的地址</strong>包装在IP包中。此外，<strong>IP包中还包含了版本、首部长度、服务类型TOS、总长度、标识、标志、片偏移、首部检验和、生存时间TTL等</strong>。网络层封装完<strong>IP包</strong>后，将<strong>IP包</strong>传交给链路层。</p><p>​<br><strong>step5：数据链路层接收IP包，构建MAC帧</strong></p><p>数据链路层又可称为<strong>MAC层(MAC全称 Media Access Control 媒体访问控制)</strong>，<strong>MAC层</strong>接收到<strong>IP包</strong>后，开始构建<strong>MAC帧</strong>，<strong>MAC帧</strong>开始是<strong>目标MAC地址</strong>和<strong>源MAC地址</strong>，<strong>源MAC地址</strong>毫无疑问是我们<strong>本机的MAC地址</strong>，<strong>本机的MAC地址</strong>在该设备被创造出来的时候就有，并且是唯一的(要想查看<strong>IP地址</strong>和<strong>MAC地址</strong>，linux上使用<strong>ifconfig</strong>或者<strong>ip addr</strong>，会在终端输出电脑的网络相关信息)。知道了自己设备上的<strong>MAC地址</strong>，但不知道<strong>目标IP地址</strong>对应的<strong>MAC地址</strong>，所以需要一个能够查询<strong>IP地址</strong>和<strong>MAC地址</strong>对应的协议，就是<strong>ARP（Address Resolution Protocol）协议</strong>。<strong>ARP协议</strong>只是针对<strong>IPv4</strong>，若是<strong>IPv6</strong>，要使用<strong>NDP协议</strong>。机器本地是有<strong>ARP协议缓存</strong>的，若能在<strong>ARP协议缓存</strong>中找到<strong>IP地址</strong>对应的<strong>MAC地址</strong>，便不会再去请求<strong>ARP协议</strong>，若没有则会请求<strong>ARP协议</strong>。在知道了<strong>目标IP地</strong>址对应的<strong>MAC地址</strong>后，将<strong>目标MAC地址</strong>放在<strong>MAC帧</strong>里,以太网的第二层最后面是<strong>CRC</strong>，也就是<strong>循环冗余检测</strong>，（<strong>MAC帧</strong>的其它组成不在细说）。</p><p>​<br><strong>step6：MAC帧头构建好后，网关准备发包</strong></p><p>MAC帧构建好，在网络中传输的网络包即构建好，然后将网络包发出去。在发包之前IP地址是否在同一个网段内的问题，通过CIDR和子网掩码计算是否在一个网段内，若在同一个网段内直接发出。一般我们访问的网站是不太可能和我们在同一网段内的，那么需要将包发往默认网关，默认网关收入包。</p><p><strong>step7：网关查询路由表，通过路由协议进行网络传输</strong></p><p>网关收入包后，取下<strong>MAC帧</strong>和<strong>IP包</strong>，判断该网哪里转发，根据路由算法，选择一个合适的网段。网段的选择会涉及到两种形式的路由算法，一种是<strong>静态路由</strong>，一种是<strong>动态路由</strong>。<strong>静态路由</strong>就是在路由器上配置一条条规则，维护路由表。可以通过route命令和ip route命令查看进行<strong>静态路由</strong>的查询和配置。 <strong>动态路由</strong>使用动态路由路由器，根据路由协议算法生成动态路由表，随网络运行情况的变化而变化。<strong>动态路由协议算法</strong>也涉及两大类，第一大类算法称为<strong>距离矢量路由（distance vector  routing）</strong>适用于小型网络，最早的路由协议<strong>RIP</strong>采用该算法，第二大类算法是<strong>链路状态路由（link state routing）</strong>。内部网关协议采用基于链路状态路由算法的<strong>OSPF（Open Shortest Path First，开放式最短路径优先</strong>），网络的路由协议是基于距离矢量路由算法的<strong>BGP(Border Gateway  Protocol)</strong>。<strong>BGP</strong>分为两类，<strong>eBGP</strong>和<strong>iBGP</strong>。对于网络包，每个数据中心有自己的规则，网络中这种不同规则所构成的网络包为<strong>自治系统AS(Autonomous System)</strong>。<strong>自治系统</strong>间边界路由器使用<strong>eBGP</strong>广播路由，内部运行<strong>iBGP</strong>，让内部路由器快速找到到达外网目的的最好的边界路由器。路由器之间信息交换使用的协议，<strong>RIP</strong>使用<strong>UDP协议</strong>，<strong>OSPF</strong>直接发送<strong>IP包</strong>，而<strong>BGP</strong>使用的是<strong>TCP协议</strong>，路由之间会建立<strong>TCP连接</strong>，每60s发送一次<strong>keep-alive</strong> 消息。此外<strong>HTTP 1.1</strong>默认<strong>keep-alive</strong>是开启的。这样网络包就像跳方格一样跳了多个（也许是一个）路由器之后，终于找到了目的<strong>IP地址</strong>所在的网关。</p><p>​<br><strong>step8：找到目的IP地址后，网关取下MAC头，将IP包发送给目的主机的网络层，检查IP地址是否对上</strong></p><p><strong>目的IP地址</strong>所在的网关接收到<strong>网络包</strong>后，发现在同一个网段内， 将包收入，然后发送给<strong>目的主机</strong>，<strong>目的主机</strong>取下<strong>MAC头</strong>，判断一下<strong>MAC地址</strong>和自己的相符，然后将<strong>IP包</strong>传给网络层，网络层取下<strong>IP包</strong>头,查看<strong>IP地址</strong>和自己的<strong>IP地址</strong>是否对上。</p><p>​<br><strong>step9：IP地址对上之后，网络层将包传递给传输层，TCP发确认包，会延刚才的方向报平安，直到收到平安到达的回复，进行TCP握手</strong></p><p>网络层数判断<strong>IP地址</strong>对上之后，根据IP头中的协议项，知道自己上层还需要<strong>TCP协议</strong>，将包传递给传输层，目的主机的内核开启，当目的主机有了IP的端口号，就可以调用<strong>listen函数</strong>进行监听(<strong>TCP</strong>和<strong>UDP</strong>都是基于 <strong>Socket</strong>,  而 <strong>listen函数 </strong>是<strong>Socket</strong>里的函数，有关 <strong>Socket</strong> 这里不详细解说)，目的主机处于<strong>LISTEN</strong>状态。传输层在收到TCP请求段后，会发送ACK包确认到达，此时目的主机处于<strong>SYN-RCVD</strong>状态，发送的网络包延刚才的路径传回，浏览器在接收到目的主机发送的SYN,ACK后进入<strong>ESTABLISHED</strong>状态，同时再发出ACK，当目的主机接收到ACK后也进入<strong>ESTABLISHED</strong>状态，此时TCP三次握手完成。</p><p>​<br><strong>step10：TCP收到回复后，进行目的端口匹配，将包内容传给HTTP服务，RPC统筹处理请求，告诉相关进程</strong></p><p><strong>TCP</strong>三次握手完成后，进行目的端口匹配，之后将包内容传给上层的<strong>HTTP服务</strong>，<strong>RPC</strong>统筹处理，告诉相关进程（<strong>Soket</strong>可能是进程在维护也可能是线程在维护监听，并且<strong>TCP</strong>往往会创立两个<strong>Socket</strong>，一个叫做就<strong>监听Socket</strong>，一个是<strong>已连接Socket</strong>，这里不详细讲述)。</p><p>​<br><strong>step11：RPC处理完毕，会回复一个HTTP/HTTPS包告知操作成功，准备向接收端传输处理结果</strong></p><p>在<strong>RPC</strong>处理完毕后，目的主机开始向接收方发送数据。在连接建立的时候，两方已商定<strong>起始ID</strong>，但数据的发送不是一个发送完等回复后再发送另一个，而是通过<strong>累计确认</strong>或者叫<strong>累计应答（cumulative acknowledgment）</strong> 的模式进行传输，即在应答某个之前的ID表示都收到了。这样<strong>TCP</strong>需要双方有缓存进行记录，发送方的记录分四部分：第一部分是<strong>发送了并且已确认</strong>，第二部分是<strong>发送了并且尚未确认</strong>，第三部分是<strong>没有发送但在等待发送</strong>，第四部分是<strong>没有发送暂时也不会发送</strong>。第一部分和第二部分的分界线是<strong>lastByteAcked</strong>，第二部分和第三部分的分界线是<strong>lastByteSent</strong>，整个第二部分和第三部分的和 <strong>Advertised window</strong> 。 浏览器作为接收端在TCP报文里是会告诉发送端这个窗口大小的，超过了这个窗口的包，接收端无法接收就会丢弃。（有关接收方的窗口说明详情可自行查询）</p><p>​<br><strong>step 12: TCP慢启动，之后开始进行数据传输，并随时监测窗口大小进行流量控制和拥塞控制</strong></p><p>虽然浏览器作为接收方告诉了发送方窗口大小，但网络是瞬息万变的，也许这会网络变差了或者网段了，那么<strong>TCP</strong>在一开始的时候，为了避免造成通道容量溢出，一条<strong>TCP</strong>连接后，设置只能发送一个报文段<strong>cwnd</strong>(congestion window 拥塞窗口)设置为1，在收到一个确认后，<strong>cwnd</strong>加一，一次能够发送两个，当这两个报文段的确认到来的时候，每个<strong>cwnd</strong>都加一，这样两个<strong>cwnd</strong>就加二，一次就能发四个，开始呈现指数级增长。当一次发送超过<strong>ssthresh</strong>的值时代表快要溢出，此时<strong>cwnd</strong>改为增加1/<strong>cwnd</strong>，一轮下来增长一个……这是有关传输过程中的拥塞控制，关于拥塞控制仍有一些问题存在，具体的流程可自查询相关的流量控制和拥塞控制。</p><p>​<br><strong>step 13:接收方浏览器接收到数据后，开始进行处理，逐渐在浏览器上显示</strong></p><p>通过数据的传输，接收端接收到了来自发送方的网络包，当接收到一个网络包时，<strong>TCP</strong>最终将包传递给浏览器，让浏览器处理<strong>HTTP应答报文</strong>，这样随着应答报文的数量增加，网页中的内容也会逐渐的显示在浏览器上。</p><p>​<br><strong>step 14: 数据传输完成，进行连接断开，四次挥手说再见</strong></p><p>数据终于传输完成，到了该断开的时候。但我们知道<strong>TCP</strong>是可靠的传输连接，是相对靠谱的，那作为靠谱的协议在断开的时候不能说断开就断开，并且<strong>TCP</strong>是全双工的，所以接收端和发送端需要各自断开。数据传输完毕时，服务器和浏览器作为发送方和接收方都处于<strong>ESTABLISHED</strong>状态，此时服务器知道数据已传输完毕，准备断开，就向接收方发送<strong>FIN</strong>报文，进入<strong>FIN-WAIT-1</strong>状态；接收方收到<strong>FIN</strong>报文后，向发送方发送<strong>ACK</strong>，进入<strong>CLOSED-WAIT</strong>状态；服务端收到<strong>ACK</strong>后从<strong>FIN-WAIT-1</strong>状态进入<strong>FIN-WAIT-2</strong>状态；接收方进入<strong>CLOSED-WAIT</strong>状态结束后再向发送方发送<strong>FIN,ACK</strong> ,并进入<strong>LAST-ACK</strong>状态；发送方接收到<strong>FIN、ACK</strong>后从<strong>FIN-WAIT-2</strong>状态进入<strong>TIME-WAIT</strong>状态(等待<strong>2MSL</strong>)，并且发送<strong>ACK</strong>；接收方接收到<strong>ACK</strong>后进入<strong>CLOSED</strong>状态；服务端等待2<strong>MSL(MSL: Maximum Segment Lifetime ,报文最大生成时间)</strong>后也进入<strong>CLOSED</strong>状态。至此，建立的连接已经各自断开，整个连接过程结束。  </p><p>为了更好的理解<strong>TCP三次握手</strong>和<strong>四次挥手</strong>，附上<strong>TCP状态机</strong><br><img src="/computerIntnet/intnetlink/TCP状态机.jpg" alt><br>以<strong>HTTP</strong>为例讲述了网络的连接过程，其它协议与此大同小异，若是基于<strong>UDP</strong>的协议会在上述步骤中简化很多，数据传输中的<strong>socket</strong>维护也相对简单。以上就是网络的连接过程。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;讲解连接过程之前，先解释几点，给后面的阐述做铺垫。在我们的电脑启动时，会通过&lt;strong&gt;DHCP协议(也是属于应用层的协议，基于UDP协议，全程 Dynamic Host Configuration Protocol ：动态主机配置协议)&lt;/strong&gt; 进行动态配置
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://onlyangelia.github.io/categories/computerIntnet/"/>
    
    
      <category term="网络连接" scheme="https://onlyangelia.github.io/tags/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Block自动截获变量</title>
    <link href="https://onlyangelia.github.io/Objective-C/blockbrief/"/>
    <id>https://onlyangelia.github.io/Objective-C/blockbrief/</id>
    <published>2017-05-07T14:55:08.000Z</published>
    <updated>2019-04-30T15:09:34.656Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://onlyangelia.github.io/Objective-C/blockindex/">《Block前言》</a>中讲到，不论何种类型的Block都自带截获变量这一技能，而针对不同的变量类型和不同的情况，自动截获分为以下情况</p><p><strong><br>1.截获变量的值<br>2.截获对象,将对象指针传递进去<br>3.将变量拷贝到堆区域，并持有变量<br>4.截获变量内存地址</strong><br>现针对以上内容进行详细分析。</p><h1 id="截获变量的值"><a href="#截获变量的值" class="headerlink" title="截获变量的值"></a>截获变量的值</h1><p>这一情况主要发生在<br>1.<strong>对基本数据类型的引用</strong>（局部参数）<br>其实说白了，对于所有类型，Block自动截获的皆为在Block截获之前的变量的瞬间值，唯一不同的是如果是Object类型，Block会多一步copy操作。先来看基本数据常量</p><pre><code>int a = 0;void (^lockBlock)(void) = ^{        NSLog(@&quot;a = %d&quot;,a);};++a;lockBlock();NSLog(@&quot;%@&quot;, lockBlock);</code></pre><p>以上代码最后输出</p><pre><code>YAObjectTest[7397:1142111] a = 0 YAObjectTest[7397:1142111] &lt;__NSMallocBlock__: 0x604000443e10&gt;</code></pre><p>发现a的值在执行block之前做了修改，执行block后获取到的还是a的原来值。<br>查看编译后的cpp文件</p><pre><code>void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__testBlockAutomaticInterceptVar_block_impl_0((void *)__BlockObject__testBlockAutomaticInterceptVar_block_func_0, &amp;__BlockObject__testBlockAutomaticInterceptVar_block_desc_0_DATA, a));</code></pre><p>可以看到传入lockBlock结构体中的仅有a的值，再看_block_impl_0中</p><pre><code>struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0{  struct __block_impl impl;  struct __BlockObject__testBlockAutomaticInterceptVar_block_desc_0* Desc;  int a;  __BlockObject__testBlockAutomaticInterceptVar_block_impl_0(void *fp, struct __BlockObject__testBlockAutomaticInterceptVar_block_desc_0 *desc, int _a, int flags=0) : a(_a) {    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }};</code></pre><p>该部分的第五行<code>int a；</code>可以明确的看到a 是值的形式存在。</p><p>为何会是引入a的值而不是a的内存地址呢？主要原因是<strong>int a 和LockBlock的存储区域不同，因int a = 0的声明是在函数内，所以是在栈区，而lockBlock在引用了局部变量后转换为MallocBlock存放在堆区</strong>。</p><p>在上述Block的实现函数<code>__BlockObject__testBlockAutomaticInterceptVar_block_func_0</code>中，我们可以看到如下部分</p><pre><code>int a = __cself-&gt;a; // bound by copy</code></pre><p>系统自动给我们加上了注释，<code>bound by copy</code>，变量<code>int a</code> ，是用 <code>__cself-&gt;</code> 来访问的,Block仅仅捕获了 <code>a</code> 的值，并没有捕获<code>a</code>的内存地址。<br>所以在testBlockAutomaticInterceptVar`这个函数中后来即使我们重写int a 的值，依旧无法去改变Block外面变量a的值</p><hr><hr><p>也正是基于以上原因，我们无法在Block内部更改自动截获的变量，更改截获的自动变量编译器会报以下错误</p><pre><code>Variable is not assignable (missing __block type specifier)</code></pre><p>变量无法在Block中改变外部变量的值，所以编译过程中就报编译错误</p><hr><hr><h1 id="截获对象-将对象指针传递进去，并持有变量"><a href="#截获对象-将对象指针传递进去，并持有变量" class="headerlink" title="截获对象,将对象指针传递进去，并持有变量"></a>截获对象,将对象指针传递进去，并持有变量</h1><p>相比较于基本数据常量而言，Block截获Object上，会有区分，Block截获的是对象，传入的是对象的指针，但是会多传入一部分内容，而且会多一步copy操作</p><pre><code> NSString *testString = @&quot;It is just a joke&quot;; void (^lockBlock)(void) = ^{        [testString stringByAppendingString:@&quot;Yeah, I&#39;m sure&quot;];  };   lockBlock();  NSLog(@&quot;%@&quot;,testString);  NSLog(@&quot;%@&quot;, lockBlock);</code></pre><p>用以上OC代码运行会发现testString的内存地址是一样的<code>&lt;__NSArrayM 0x604000240090&gt;</code>，同样不能在Block内部进行初始化操作（因为重新初始化Block内部的引用对象内存地址会发生变化这是不允许的）。</p><p>查看clang后的cpp文件，我们发现lockBlock声明赋值的部分编译后的代码如下</p><pre><code>void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__testBlockAutomaticInterceptVar_block_impl_0((void *)__BlockObject__testBlockAutomaticInterceptVar_block_func_0, &amp;__BlockObject__testBlockAutomaticInterceptVar_block_desc_0_DATA, testString, 570425344));</code></pre><p>相比较于基本数据常量而言，<strong>传递参数多了后面的<code>570425344</code>（这一部分后面探讨）</strong>。其它和基本数据类型一样，直接以<code>NSString *testString;</code>出现在<code>__BlockObject__testBlockAutomaticInterceptVar_block_impl_0</code>结构体中，在<code>__BlockObject__testBlockAutomaticInterceptVar_block_func_0</code>结构体中以<br><code>NSString *testString = __cself-&gt;testString; // bound by copy</code>——cself-&gt; 形式调用。</p><p>引用对象不同的是会多出来以下函数</p><pre><code>static void __BlockObject__testBlockAutomaticInterceptVar_block_copy_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*dst, struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;testString, (void*)src-&gt;testString, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __BlockObject__testBlockAutomaticInterceptVar_block_dispose_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;testString, 3/*BLOCK_FIELD_IS_OBJECT*/);}</code></pre><p>在编译文件中看到引用对象时有_block_copy  和 _block_dispose函数。这两个函数的作用相当于内存管理MRC中的copy 和 release操作，调用_block_copy将引用对象进行copy操作，调用_block_dispose相当于对testString 进行release操作。<br>copy具体的执行操作是申请内存，将栈数据复制过去，将Class改一下，最后向捕获到的对象发送retain，增加block的引用计数，dispose函数正好相反。<br>copy和dsipose函数中最后一个参数代表截获的参数类型，3 代表是Block，编译后的代码中注释了BLOCK_FIELD_IS_OBJECT，其它形式如下<br>.BLOCK_FIELD_IS_BLOCK；<br>.BLOCK_FIELD_IS_WEAK;<br>.BLOCK_BYREF_CALLER<br>.BLOCK_FIELD_IS_BYREF</p><p>与截获基本数据类型相同，截获对象传递的是指针，所以在Block内不能再对对象进行初始化，但其本身自带的方法可以调用，MallocBlock会持有引用的变量。</p><p>#变量拷贝到堆区域，并持有变量<br>.__block 修饰符修饰</p><p>#<strong>block<br>对于对象，Block引用内部可以进行操作不能初始化，但对于基本数据类型如何进行更改呢，这个时候会用到`</strong>block`修饰符。该修饰符的主要作用是将基本数据常量写入结构体转变为对象，copy到堆上，持有变量。来看下代码和转换后的代码</p><pre><code> __block int a = 0; void (^lockBlock)(void) = ^{      a = 2; };</code></pre><p>编译后的代码</p><pre><code>__attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 0};  void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__testBlockAutomaticInterceptVar_block_impl_0((void *)__BlockObject__testBlockAutomaticInterceptVar_block_func_0, &amp;__BlockObject__testBlockAutomaticInterceptVar_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));</code></pre><p>可以看到int a 被转换为<code>_blocks__(byref）</code>类型，在Block使用时传入的<code>(__Block_byref_a_0 *)&amp;a</code>，而具体的a被转换后的结构体，</p><pre><code>struct __Block_byref_a_0 {  void *__isa;__Block_byref_a_0 *__forwarding; int __flags; int __size; int a;};</code></pre><p>和对象的结构体一样包含isa指针，并且还有一个<strong>forwarding指针，flags、size、和一个int a 。此时，发现int a作为结构体成员，而</strong>forwarding指针是指向其本身，这就保证了被拷贝到堆区之后依然能够找到该变量。<br>将参数转变成对象之后，其也会增加</p><pre><code>static void __BlockObject__testBlockAutomaticInterceptVar_block_copy_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*dst, struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __BlockObject__testBlockAutomaticInterceptVar_block_dispose_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}</code></pre><p>copy和dispose函数的最后一个参数变为8，意味截获的变量是<strong>block转换来的。<br>具体的关于copy和dispose 可以祥见[霜神博客《深入研究Block捕获外部变量和</strong>block实现原理》第二部分Block的copy和dispose](<a href="https://www.jianshu.com/p/ee9756f3d5f6">https://www.jianshu.com/p/ee9756f3d5f6</a>)</p><p>#截获内存地址<br>.对于静态变量，全局变量，Block截获的是内存地址，在Block内部可以直接修改值。<br>主要因为静态变量和全局变量的存储区域并不会发生改变，所以在Block截获时引用的是其内存地址，修改后仍旧是存储在静态区</p><pre><code>static int count = 100; typedef int (^blockStatic)(void); blockStatic blk = ^(){    count = 1000;   return count;  };</code></pre><p>转换后的函数实现如下</p><pre><code>static int __BlockObject__testBlockKinds_block_func_0(struct __BlockObject__testBlockKinds_block_impl_0 *__cself) {        count = 1000;        return count;  }</code></pre><p>在Block内部直接可以修改count的值，对count的引用直接获取的内存地址，且在__block _impl 结构体中并没有将count值引用或copy。</p><p>#结尾补充：”570425344”代表啥？<br>细心的大佬们肯定发现了在Block语法转换时候，若引用的是对象，则后面必跟一个数字<strong>570425344</strong> ，且不管是不同项目、不同类、不同Block，这个数值是固定的。为了这个问题也困惑了好久，开始以为这就是一个判断是否是对象的枚举类型。最后特不好意思的咨询霜大神，醍醐灌顶。可能和霜神之间隔了570425344光年的距离，这距离差在解决问题的思路和办法上，我是一直在编译后的cpp文件中查看，发现并没有解释，只能通过尝试来得出一个猜想。霜神是直接将这串数次Google ，而Google 告诉我们了答案（虽然这答案未必准备，但比我的想法好多了）。</p><pre><code>myBlock-&gt;impl.isa = &amp;_NSConcreteStackBlock;myBlock-&gt;impl.Flags = 570425344;</code></pre><p><code>570425344</code>为Flags的偏移量，这个偏移量是固定的。大家可以自己代码运行下查看GlobalBlock的Flags为10位数正数，StackBlock和MallocBlock的Flags为10位数负数，<br>这里暂时将”<code>570425344&quot;</code>理解为Flags的偏移量，若有大佬知道确切答案，希望能不吝赐教</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://onlyangelia.github.io/Objective-C/blockindex/&quot;&gt;《Block前言》&lt;/a&gt;中讲到，不论何种类型的Block都自带截获变量这一技能，而针对不同的变量类型和不同的情况，自动截获分为以下情况&lt;/p&gt;

      
    
    </summary>
    
      <category term="Objective-C" scheme="https://onlyangelia.github.io/categories/Objective-C/"/>
    
    
      <category term="Block" scheme="https://onlyangelia.github.io/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Block类型及内存区域</title>
    <link href="https://onlyangelia.github.io/Objective-C/blockmemory/"/>
    <id>https://onlyangelia.github.io/Objective-C/blockmemory/</id>
    <published>2017-04-10T14:55:08.000Z</published>
    <updated>2019-04-30T15:05:16.864Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://onlyangelia.github.io/Objective-C/blockindex/">Block前言</a>中，讲到Block 的isa指针六种类型，以及每种类型的存储区域。简单回顾一下最终结论</p><table><br>  <tr><br>    <th width="35%," bgcolor="#eeeeee">类型</th><br>    <th width="35%," bgcolor="#eeeeee">查看源</th><br>    <th width="30%," bgcolor="#eeeeee">存储区域</th><br>  </tr><br> <tr><br>    <td>_NSConcreteGlobalBlock</td><br>    <td> .cpp文件/Block.h </td><br>    <td> 全局变量/静态变量区</td><br>  </tr><br>  <tr><br>    <td>_NSConcreteStackBlock </td><br>    <td> .cpp文件/Block.h</td><br>    <td> 栈区 </td><br>  </tr><br> <tr><br>    <td>_NSConcreteMallocBlock </td><br>    <td> Block_private.h文件</td><br>    <td> 堆区</td><br>  </tr><br><tr><br>    <td>_NSConcreteAutoBlock </td><br>    <td> Block_private.h文件</td><br>    <td> 堆区</td><br>  </tr><br><tr><br>    <td>_NSConcreteFinalizingBlock </td><br>    <td> Block_private.h文件</td><br>    <td> 堆区</td><br>  </tr><br><tr><br>    <td>_NSConcreteWeakBlockVariable </td><br>    <td> Block_private.h文件</td><br>    <td> 堆区</td><br>  </tr><br></table><p>以上内容的查看在编译后的cpp文件以及runtime源码中都可以查看到相关信息<br><a href="https://github.com/onlyAngelia/YAObjectTest.git">code已上传到Github,点击下载</a><br><a href="https://opensource.apple.com/source/objc4/objc4-680/runtime/">runtime源码Apple官网</a><br><a href="https://github.com/onlyAngelia/objc-runtime">runtime源码Github</a></p><h1 id="特别注意点"><a href="#特别注意点" class="headerlink" title="特别注意点"></a>特别注意点</h1><p>Block前言中讲到默认创建的Block指针只有Global、Statck，其它四种是在运行时编译环境决定的，此根据也是根据runtime源码和注释得出结论。</p><pre><code class="cpp">// the raw data space for runtime classes for blocks// class+meta used for stack, malloc, and collectable based blocksBLOCK_EXPORT void * _NSConcreteMallocBlock[32]    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteAutoBlock[32]    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32]    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32]    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</code></pre><p>从以上runtime源码和注释中我们可以很好的解释该6种Block在Mac和iOS系统中都会出现，除Global、Statck，其它四种是在运行时编译环境决定。</p><h1 id="每种Block出现的情况"><a href="#每种Block出现的情况" class="headerlink" title="每种Block出现的情况"></a>每种Block出现的情况</h1><p>（最好复习一下基本数据结构）</p><h2 id="NSConcreteGlobalBlock"><a href="#NSConcreteGlobalBlock" class="headerlink" title="_NSConcreteGlobalBlock"></a>_NSConcreteGlobalBlock</h2><p>在以下情况下，Block为GlobalBlock (根据赋值情况会决定存储静态区的静态变量区域还是全局变量区域)<br><strong>1.Block声明为全局变量<br>2.函数区域内Block语法表达式没有使用外部变量<br>3.Block内部只引用了内部传递值或只引用了静态变量或全局变量</strong></p><p>第一种情况好理解,一般我们声明的全局变量都会放在静态区,当Block被声明为全局变量时也会存放在静态区域<br>如下将Block声明为全局变量,查看编译后的cpp文件,找到对应的编译代码<br>源码:</p><pre><code>#import &quot;BlockObject.h&quot;#import &lt;objc/runtime.h&gt;void (^globalBlock)(void)=^{};@interface BlockObject()</code></pre><p>编译后的部分代码:</p><pre><code>struct __globalBlock_block_impl_0 {  struct __block_impl impl;  struct __globalBlock_block_desc_0* Desc;  __globalBlock_block_impl_0(void *fp, struct __globalBlock_block_desc_0 *desc, int flags=0) {    impl.isa = &amp;_NSConcreteGlobalBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }};</code></pre><p>`impl.isa = &amp;_NSConcreteGlobalBlock;可以看到我们声明的<strong>全局变量block为NSConcreteGlobalBlock</strong>。</p><p>第二种情况我们可以看如下代码</p><pre><code> typedef int (^blockStatic)(void);blockStatic secondBlk = ^(){        return 1; };NSLog(@&quot;%@&quot;,secondBlk);</code></pre><p>最后查看到输出结果如下</p><pre><code>YAObjectTest[8834:1196308] &lt;__NSGlobalBlock__: 0x10de381c8&gt;</code></pre><p>所以，<strong>未引用外部变量时，最终得到的block也是NSConcreteGlobalBlock</strong>。</p><p>第三种情况我看可以看如下代码</p><pre><code>static int count = 100;typedef int (^blockStatic)(void);blockStatic blk = ^(){        return count;    };     NSLog(@&quot;%@&quot;,blk);</code></pre><p>最后的输出结果如下：</p><pre><code>YAObjectTest[8719:1185296] &lt;__NSGlobalBlock__: 0x108320188&gt;</code></pre><p>最后的输出也是GlobalBlock，所以，<strong>只引用静态变量或全局变量时，Block仍为NSConcreteGlobalBlock</strong>。</p><hr><p>解惑：第二种情况和第三种情况我们最终查看的是输出情况，而不是clang后的源文件。查看clang后的源文件该两种情况得到的是StackBlock。编译器根据编译特性会把后两种情况默认编译后定义为StackBlock，但是我们知道OC是动态语言，所以最终还是以运行时或最终输出结果为准。</p><hr><h1 id="NSConcreteStackBlock"><a href="#NSConcreteStackBlock" class="headerlink" title="_NSConcreteStackBlock"></a>_NSConcreteStackBlock</h1><p><strong>1.使用到外部局部变量、成员属性变量（非静态变量值）&amp; 2.未使用strong或copy修饰符修饰</strong><br><strong>以上条件缺一不可，只有这两个条件同时成立时，Block才为_NSConcreteStackBlock</strong><br>如果在函数内，Block只是引用了外部局部变量或成员属性变量，最终会被copy到堆上变为MallocBlock。而对于声明为属性的Block，如果修饰符为strong或copy，则也会copy到堆上，而不是StackBlock。<br>查看以下代码的最终输出（不能同时满足上述两种条件的情况下）</p><pre><code>@interface BlockObject()@property (nonatomic, strong)void(^proBlock)(void);@property (nonatomic, assign)NSInteger outsideCount;@end     int a = 1;    //使用外部局部变量情况    void (^blockVariable)(void) = ^(){        NSLog(@&quot;%ld&quot;,(long)_outsideCount);    };    NSLog(@&quot;%@&quot;,blockVariable);    _proBlock = ^(){        NSLog(@&quot;%d&quot;,a);    };    NSLog(@&quot;%@&quot;,_proBlock);</code></pre><p>最终控制台输出如下</p><pre><code> &lt;__NSMallocBlock__: 0x600000447c50&gt; &lt;__NSMallocBlock__: 0x6040002557b0&gt;</code></pre><p>将proBlock的修饰符换成weak，</p><pre><code>@property (nonatomic, weak)void(^proBlock)(void);</code></pre><p>同样的代码，会得到如下结果，proBlock会是StackBlock</p><pre><code>YAObjectTest[10461:1384618] &lt;__NSMallocBlock__: 0x60400025d1f0&gt;YAObjectTest[10461:1384618] &lt;__NSStackBlock__: 0x7ffee9f07930&gt;</code></pre><p>所以，<strong>在引用了外部变量并且没有强指针引用的情况下的Block为_NSConcreteStackBlock</strong>。</p><h1 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="_NSConcreteMallocBlock"></a>_NSConcreteMallocBlock</h1><p>1.引用了外部变量，有strong或copy修饰符修饰<br>2.block内部需要修改引用变量的值，外部变量被<strong>block修饰<br>第一种情况在求证StackBlock的情况下已经得到验证，有strong或copy修饰后并且引用了外部变量的情况下，为** &lt;</strong>NSMallocBlock__: 0x6040002557b0&gt;**<br>有关第二种情况，在该文只做验证，后续深入解析，详见Block截获变量中的__block修饰符深入解析</p><pre><code>    __block int a = 0;    void (^lockBlock)(void) = ^{        a++;    };    lockBlock();    NSLog(@&quot;%@&quot;, lockBlock);</code></pre><p>最后的输出结果为</p><pre><code>YAObjectTest[10853:1425358] &lt;__NSMallocBlock__: 0x60000024e610&gt;</code></pre><p>在此就求证了以上两种结果最后Block为_NSConcreteMallocBlock。</p><hr><p>接下来的三种类型Block，因对有GC回收机制的语言不是太熟悉，在Xcode中编写的C++代码 最终查看运行时的isa指针皆为—NSStackBlock，在Xcode中并没有按照预想的查看到以下三种类型，Terminal终端g++ 编译后的可执行文件也未见以下类型，查阅资料发现以下三种出现的情况大致如下，若有对C++ 熟悉的人员 ，请不吝赐教😉</p><hr><h1 id="NSConcreteFinalizingBlock"><a href="#NSConcreteFinalizingBlock" class="headerlink" title="_NSConcreteFinalizingBlock"></a>_NSConcreteFinalizingBlock</h1><p>.Block需要copy到堆上，但是Block内部有ctors 和 dtors时，block会是NSFinalizingBlock</p><h1 id="NSConcreteAutoBlock"><a href="#NSConcreteAutoBlock" class="headerlink" title="_NSConcreteAutoBlock"></a>_NSConcreteAutoBlock</h1><p>.Block需要copy到堆上若未引用到ctors和 dtors 则是NSAutoBlock<br>以上是AutoBlock和FinalizingBlock的出现情况。而对于ctors和dtors，<br>ctors中保存着程序全部构造函数的指针数组，dtors中保存着程序全部析构函数的指针数组，从两者的存储内容来看，若block引用了该两种类型，势必block会在程序运行结束时回收内存，所以会被转换为FinalizingBlock，而未引用的block则会根据情况自动回收，转换为AutoBlock。</p><p>以下是写在cpp文件中的代码</p><pre><code>void testAutoBlock(){  int * b=new int[4];   __block int testCount = 100;   int (^myBlock)() = ^() {        b[0] = testCount;        b[1] = testCount + 1;        b[2] = testCount + 2;        b[3] = testCount + 3;        std::cout&lt;&lt;b&lt;&lt;std::endl;       return 0;    };    std::cout&lt;&lt;myBlock&lt;&lt;std::endl;   }；</code></pre><h1 id="NSConcreteWeakBlockVariable"><a href="#NSConcreteWeakBlockVariable" class="headerlink" title="_NSConcreteWeakBlockVariable"></a>_NSConcreteWeakBlockVariable</h1><p>.GC回收机制下，用_weak 或<strong>block修饰的block 会转变成NSWeakBlockVariable<br>具体的对于</strong>weak 和__blcok修饰符，在后面截获变量和循环引用中具体详解。<br>以上是个人对于Block类型和存储区域的总结。中间为探究后三种类型浪费了很多时间，导致文章延迟。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://onlyangelia.github.io/Objective-C/blockindex/&quot;&gt;Block前言&lt;/a&gt;中，讲到Block 的isa指针六种类型，以及每种类型的存储区域。简单回顾一下最终结论&lt;/p&gt;
&lt;table&gt;&lt;br&gt;  
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://onlyangelia.github.io/categories/Objective-C/"/>
    
    
      <category term="Block" scheme="https://onlyangelia.github.io/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Block实质</title>
    <link href="https://onlyangelia.github.io/Objective-C/blocknature/"/>
    <id>https://onlyangelia.github.io/Objective-C/blocknature/</id>
    <published>2017-04-09T14:55:08.000Z</published>
    <updated>2019-04-30T15:09:06.141Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://onlyangelia.github.io/Objective-C/blockindex/">《Block前言》</a>中讲到，<strong>Block</strong>是对C语言的扩充，<strong>Block为带有自动变量（局部变量）的匿名函数</strong>。查看源码得知OC中，<strong>Block是作为对象存在</strong>。该篇文章针对这两点展开细节。</p><p>#Block为带有自动变量（局部变量）的匿名函数<br>接下来，根据clang命令<code>clang -rewrite-objc BlockObject.m</code> 得到的cpp文件查看Block具体的结构<a href="https://github.com/onlyAngelia/YAObjectTest.git">code已上传到Github,点击下载</a></p><pre><code class="objc:n"> void (^lockBlock)(void) = ^{ }; lockBlock();</code></pre><p>执行clang命令后对应代码会有如下结果</p><pre><code class="cpp:n">void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__init_block_impl_0((void *)__BlockObject__init_block_func_0, &amp;__BlockObject__init_block_desc_0_DATA));        ((void (*)(__block_impl *))((__block_impl *)lockBlock)-&gt;FuncPtr)((__block_impl *)lockBlock);</code></pre><p>第一行代码Block的定义<code>void (^lockBlock)(void) = ^{ }</code>;被解析成</p><pre><code class="cpp">void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__init_block_impl_0((void *)__BlockObject__init_block_func_0, &amp;__BlockObject__init_block_desc_0_DATA));</code></pre><p>我们主要看<code>=</code>后面的部分。大家有没有对<code>void (*)()</code>这一部分有种似曾相识的感觉，没错，这和我们C语言中的函数格式一样，唯一的区别是没有函数名称，所以这就是为何称 <code>**Block为匿名函数**</code>的原因。<br> 我们知道<code>^{ }</code>该部分才是Block语法，然而该部分在编译之后，我们单纯看上面部分编译后的内容可能会觉得<code>__BlockObject__init_block_impl_0</code>这是对应的转换，其实也没错，只不过为了理解自动变量这一概念，我们看<code>__BlockObject__init_block_impl_0</code>的第一个参数<code>__BlockObject__init_block_func_0</code>。为了方便大家更好的理解以及查找，在Block语法中我们增添一部分内容<code>^{ NSLog(@&quot;lockBlock&quot;); }</code>，该部分block语法块的单独对应编译部分(即<code>__BlockObject__init_block_impl_0</code>对应的第一参数)为</p><pre><code class="cpp">static void __BlockObject__init_block_func_0(struct __BlockObject__init_block_impl_0 *__cself) {            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n__p6qtc6t91tgcqk06x_s9b84w0000gn_T_BlockObject_2304d0_mi_0);        }</code></pre><p>来看<code>struct __BlockObject__init_block_impl_0 *__cself</code>该部分，<code>__cself</code>这里暂时不做深入讲解，只要明白这行代码的意思是<code>struct __BlockObject__init_block_impl_0</code>代表的是当前Block语法即可。那么我们<strong>回归正题</strong>在最初提到的编译后如下代码，</p><pre><code class="cpp">void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__init_block_impl_0((void *)__BlockObject__init_block_func_0, &amp;__BlockObject__init_block_desc_0_DATA));</code></pre><p>我们关注<code>((void (*)())&amp;__BlockObject__init_block_impl_0</code>这一部分，上述讲到在该编译代码中<code>__BlockObject__init_block_impl_0</code>代表的是当前Block语法，查看<code>__BlockObject__init_block_impl_0</code>的编译源码我们知道其实是一个结构体类型的变量（该切入点放第二部分讲解），那么<code>&amp;__BlockObject__init_block_impl_0</code>便是结构体的实例指针，所以整个转换后的操作是将生成的<strong><code>结构体自动变量</code></strong>转换为结构体实例指针赋值给变量<code>lockBlock</code>。至此，我们可以清晰的知道<strong><code>Block为带有自动变量（局部变量）的匿名函数</code></strong>。</p><p>也许大多数跟本人一样，对C语言已经不太熟悉。那接下来的小插曲便是简单写C语言的函数声明和调用，帮助大家更好的理解(这里使用函数指针代替直接调用)</p><pre><code class="s:n">void func(int count);void (*funcptr)(int) = &amp;func;void conclusion = (*funcptr)(100);</code></pre><p>对应的第二行调用代码 <code>lockBlock();</code> 编译后对应的转换我们可以清晰的看到<code>((__block_impl *)lockBlock)-&gt;FuncPtr)((__block_impl *)lockBlock)</code>，简化后为<code>（*lockBlock-&gt;impl.FuncPtr)(lockBlock)</code>，至此我们看到函数调用采用的是函数指针。<br>以上简单的介绍，相信大家对Block是对C语言的扩充，是匿名函数有了明确的认知。</p><p>#Block作为对象存在（OC语言中）<br>上一部分中，为了更好的帮助大家理解，简化了很大一部分。我们留下几个点放在这部分来讲。首先大家最关心的应该是<code>__BlockObject__init_block_impl_0</code>问题。在此，有一点要向大家说明：<strong>BlockObject是本人代码中的类名，</strong>init是函数名，会有这两部分前缀仅仅是因为本人在类BlockObject的初始化方法init里面写的Block，所以每个人创建的类不同，方法不同，<code>__BlockObject__init</code>这一部分前缀便会不同。下面，我们来看下其结构体本身</p><pre><code class="cpp">struct __BlockObject__init_block_impl_0 {  struct __block_impl impl;  struct __BlockObject__init_block_desc_0* Desc;  __BlockObject__init_block_impl_0(void *fp, struct __BlockObject__init_block_desc_0 *desc, int flags=0) {    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }};</code></pre><p>编译后的源码将构造函数和结构体一块合并，接下来我们将其拆分，其实<code>__BlockObject__init_block_impl_0</code>最核心的本质便是如下：</p><pre><code class="cpp">struct __BlockObject__init_block_impl_0 {  struct __block_impl impl;  struct __BlockObject__init_block_desc_0* Desc;}</code></pre><p>观察到<code>__BlockObject__init_block_impl_0</code> 本质是结构体，结构体中又包含结构体<code>struct __block_impl</code>和<code>__BlockObject__init_block_desc_0</code>指针，接下来我们再一步步探究这两部分的具体内容，而构造函数放在后序进行分析。</p><pre><code class="cpp">struct __block_impl {  void *isa;  int Flags;  int Reserved;  void *FuncPtr;}</code></pre><p>此结构体是我们探究到的Block最原始结构，看到isa指针，松口气，推断<strong>Block在OC语言中作为对象存在</strong>。</p><hr><p>以上内容作为简单理解<strong>Block为带有自动变量（局部变量）的匿名函数</strong>以及<strong>Block在OC语言中作为对象存在</strong>，以下部分有兴趣可继续了解</p><hr><p>既然我们知道Block是作为对象存在的，其肯定存在内存大小，而具体的内存大小便在其如下结构中可以清晰的看到<code>Block_size</code></p><pre><code class="cpp">static struct __BlockObject__init_block_desc_0 {  size_t reserved;  size_t Block_size;}</code></pre><p>在<code>__BlockObject__init_block_impl_0((void *)__BlockObject__init_block_func_0, &amp;__BlockObject__init_block_desc_0_DATA))</code>的两个初始化参数中，我们看到<code>__BlockObject__init_block_func_0</code> 该参数第一部分有讲到，是转换的c函数指针，第二个参数<code>&amp;__BlockObject__init_block_desc_0_DATA</code>转换后的编译代码为</p><pre><code class="cpp">__BlockObject__init_block_desc_0_DATA = { 0, sizeof(struct __BlockObject__init_block_impl_0)};</code></pre><p>所以第二个参数是初始化<code>__BlockObject__init_block_impl_0</code>实例的大小。<br>再讲下构造函数</p><pre><code class="cpp">  __BlockObject__init_block_impl_0(void *fp, struct __BlockObject__init_block_desc_0 *desc, int flags=0) {    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }</code></pre><p>从构造函数中我们可以看到fp被赋值给了结构体成员变量FuncPtr，那fp是何玩意呢，联想到<code>__BlockObject__init_block_impl_0</code>的第一个参数，便知fp即为<strong>BlockObject</strong>init_block_func_0，所以成员变量FuncPtr被赋值<strong>BlockObject</strong>init_block_func_0的函数指针。这就是为什么在第一部分讲<code>((__block_impl *)lockBlock)-&gt;FuncPtr)((__block_impl *)lockBlock)</code>采用函数指针调用函数。<br>有关Block实质大致讲到这里，后续发现问题再修正。若有任何问题，也请指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://onlyangelia.github.io/Objective-C/blockindex/&quot;&gt;《Block前言》&lt;/a&gt;中讲到，&lt;strong&gt;Block&lt;/strong&gt;是对C语言的扩充，&lt;strong&gt;Block为带有自动变量（局部变量
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://onlyangelia.github.io/categories/Objective-C/"/>
    
    
      <category term="Block" scheme="https://onlyangelia.github.io/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Block前言</title>
    <link href="https://onlyangelia.github.io/Objective-C/blockindex/"/>
    <id>https://onlyangelia.github.io/Objective-C/blockindex/</id>
    <published>2017-04-08T14:55:08.000Z</published>
    <updated>2019-04-30T15:04:30.007Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Block</strong>可能已经是被大家讨论的滚瓜烂熟的话题了，却经久不衰。总结这篇文章的起因是在一个开发群里许多iOSer咨询block问题，于是写该系列Block文章系统梳理一下有关Block的知识体系。该系列文章会从<code>Block实质</code>、<code>Block类型及内存区域</code>、<code>Block截获自动变量</code>、<code>Block循环引用问题</code>深入理解Block。</p><h1 id="Block实质"><a href="#Block实质" class="headerlink" title="Block实质"></a>Block实质</h1><p>在OC语言中，<strong>Block</strong>从OS X Snow Leopard 和 iOS 4起开始引入，才被众多OC语言使用者周知。OC是基于C语言编写，Block也是基于C语言的扩充，那Block是扩充的何种功能呢？简而言之，Block是<strong><code>带有自动变量（局部变量）的匿名函数</code></strong>。但OC语言又是对C语言的扩展，是OOL，所以Block在OC中的存在绝不仅仅是一段函数。我们可以使用<strong>clang</strong>命令，查看Block在OC中的实现。(clang -rewrite-objc 源文件名 note：具体如何clang，详情Google )<br>具体沿着编译后的cpp文件查找，会查找到如下最<strong>原始结构</strong></p><pre><code class="cpp">struct __block_impl {void *isa;int Flags;int Reserved;void *FuncPtr;}</code></pre><p>可以看到，结构体中有isa指针,Block的实质是与OC中常见objc_object结构体类似,由此可见<strong>Block在OC中是作为对象存在</strong>。<br><a href="https://onlyangelia.github.io/Objective-C/blocknature/">Block实质详解</a></p><h1 id="Block类型及内存区域"><a href="#Block类型及内存区域" class="headerlink" title="Block类型及内存区域"></a>Block类型及内存区域</h1><p>在Block实质中，我们探究到了Block的最原始结构，那么Block<br>有哪几种类型呢，接下来看Block结构体中的<strong>isa指针</strong>。<br>在编译后的cpp文件中，我们可以看到构造函数中会有如下赋值</p><pre><code class="cpp">__BlockObject__init_block_impl_0(void *fp, struct __BlockObject__init_block_desc_0 *desc, int flags=0) {    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }</code></pre><p>可以看到 <code>**impl.isa = &amp;_NSConcreteStackBlock**</code>,<code>_NSConcreteStackBlock</code>就代表了Block类型。<br>类似_NSConcreteStackBlock这样的结构还有以下几种</p><p>|类型|查看源|存储区域<br>_NSConcreteGlobalBlock    | .cpp文件/Block.h | 全局变量/静态变量区<br>_NSConcreteStackBlock      | .cpp文件/Block.h|栈区<br>_NSConcreteMallocBlock     |Block_private.h文件|堆区<br>_NSConcreteAutoBlock |Block_private.h文件|堆区<br>_NSConcreteFinalizingBlock |Block_private.h文件|堆区<br>_NSConcreteWeakBlockVariable |Block_private.h文件|堆区</p><p>通过编译后cpp文件以及查看runtime中与Block相关文件，找到以上六种类型。我们创建的Block默认赋值的isa指针会有<code>_NSConcreteGlobalBlock</code>和<code>_NSConcreteStackBlock 两种类型，</code>，其它四种是在运行期间，编译器根据情况生成。<br>有关各Block类型、存储区域 以及各类型和存储区域和各种场景的对应详情点击<br> <a href="https://onlyangelia.github.io/Objective-C/blockmemory/">Block类型及内存区域</a></p><h1 id="Block截获变量"><a href="#Block截获变量" class="headerlink" title="Block截获变量"></a>Block截获变量</h1><p>使用Block期间，不可避免要使用一些外部变量或全局变量以及对象等。而Block对于引用的变量或对象有自动截获的能力。对于Global、Stack、Malloc 类型的Block都有自动截获的能力，但对于不同的变量或者是在不同情况下，Block截获变量会出现以下情况：<br>1.截获变量的值<br>2.截获变量的指针<br>3.将变量拷贝到堆区域，并持有变量<br>对于每种情况的具体分析，详见<a href="https://onlyangelia.github.io/Objective-C/blockbrief/">《Block自动截获变量》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Block&lt;/strong&gt;可能已经是被大家讨论的滚瓜烂熟的话题了，却经久不衰。总结这篇文章的起因是在一个开发群里许多iOSer咨询block问题，于是写该系列Block文章系统梳理一下有关Block的知识体系。该系列文章会从&lt;code&gt;Block实质&lt;/c
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://onlyangelia.github.io/categories/Objective-C/"/>
    
    
      <category term="Block" scheme="https://onlyangelia.github.io/tags/Block/"/>
    
  </entry>
  
</feed>
