<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>莯滢</title>
  
  <subtitle>不念过往、不负当下、不畏将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://onlyangelia.github.io/"/>
  <updated>2019-05-17T13:11:55.917Z</updated>
  <id>https://onlyangelia.github.io/</id>
  
  <author>
    <name>莯滢</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python文本处理(-)正则表达式操作-re模块 &amp; regex模块</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonStringRegularExpressionOperations/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonStringRegularExpressionOperations/</id>
    <published>2017-05-04T16:39:21.000Z</published>
    <updated>2019-05-17T13:11:55.917Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式（称为RE，或正则，或正则表达式模式）本质上是嵌入在Python中的一种微小的、高度专业化的编程语言。<strong>re</strong>模块提供来正则表达式匹配操作，用来对文本进行一些处理优化。匹配模式和被搜索的字符串既可以是<strong>Unicode</strong>字符串(<strong>str</strong>)，也可以是8位字节串(<strong>bytes</strong>)，不过两者不能混用。绝大多数正则表达式操作都提供了相应的函数，函数不需要先编译一个对象，但损失来一些优化参数。另外，第三方模块<strong>regex</strong>提供来与<strong>Python</strong>内置标准库<strong>re</strong>模块兼容的<strong>API</strong>接口，同时提供来额外的功能和更全面的<strong>Unicode</strong>支持。</p><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p>正则表达式可以包含：<strong>普通字符</strong>、<strong>特殊字符</strong>、<strong>修饰符</strong>。</p><p><strong>普通字符</strong>就是平常使用的绝大多数字符’ABC’、’0’等；<strong>特殊字符</strong>是既可以表示普通含义，也可以影响其左右字符或表达式的含义，如’(‘，’|’等；<strong>修饰符</strong>是指用来修饰表达式的字符，其中修饰字符中的<strong>重复修饰符</strong>(<code>*</code>, <code>+</code>, <code>?</code>, <code>{m,n}</code>, 等)不能直接套用以此避免与其它修饰符产生的多义性，但可以使用括号来应用内层重复嵌套。</p><h3 id="常用的特殊字符和修饰符"><a href="#常用的特殊字符和修饰符" class="headerlink" title="常用的特殊字符和修饰符"></a>常用的特殊字符和修饰符</h3><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>.</code></td><td>默认模式匹配除了换行的任意字符；如果指定了DOTALL标签，则可以匹配换行字符</td></tr><tr><td><code>^</code></td><td>默认模式匹配字符串开头；在MULTILINE模式下也会匹配换行后首个字符</td></tr><tr><td><code>$</code></td><td>匹配字符串尾或者换行符的前一个字符；在MULTILINE模式下匹配换行符的前一个字符</td></tr><tr><td><code>*</code></td><td>对前面的正则表达式匹配0到任意次重复，如<code>ab*</code>匹配的组合有<code>a</code>、<code>ab</code>、<code>abb</code>或者其它a后面跟着n个b字符的组合</td></tr><tr><td><code>+</code></td><td>对前面的正则表达式匹配1到任意次重复，如同样是ab组合，<code>ab+</code>匹配的组合有<code>ab</code> 、<code>abb</code>或者其它a后面跟着n个b字符的组合，但不会匹配<code>a</code></td></tr><tr><td><code>?</code></td><td>对前面的表达式匹配0到1次重复，如<code>ab?</code>会匹配<code>a</code>、<code>ab</code></td></tr><tr><td><code>*?</code>、<code>+?</code>、<code>??</code></td><td><code>&#39;*&#39;</code>, <code>&#39;+&#39;</code>，和 <code>&#39;?&#39;</code> 修饰符都是<strong>重复修饰符</strong>，在字符串后面修饰符之后添加 <code>?</code> 将使样式最小 方式进行匹配； 匹配的字符要尽量少，如 <code>ab*?</code>会按照<code>*</code>字符最小匹配次数0次进行匹配，也就是智能匹配<code>a</code>这一种情况。</td></tr><tr><td><code>{m}</code></td><td>对之前的正则表达式指定匹配m个重复，若少于m则不会匹配成功，如<code>f{5}</code>只能匹配<code>fffff</code>，</td></tr><tr><td><code>{m,n}</code></td><td>对之前的正则表达式指定匹配m到n次匹配，在m到n之间尽可能多，如<code>f{4,6}</code>则可能匹配的值有<code>ffff</code>、<code>fffff</code>、<code>ffffff</code></td></tr><tr><td><code>{m,n}?</code></td><td><code>{m,n}</code>模式下匹配尽量少的字符，如对于<code>ffffff</code>字符<code>f{4,6}?</code>只匹配前四个</td></tr><tr><td><code>\</code></td><td>转义特殊字符；如果转义序列不被Python分析器识别，反斜杠和字符才能出现在字符串中，如果Python可以识别这个序列，那么反斜杠就要写两个</td></tr><tr><td><code>[]</code></td><td>用于表示一个字符集合；字符在<code>[]</code>可以单独列出，比如<code>[ab]</code>匹配<code>a</code>或者<code>b</code>；通过用<code>-</code>将两个数字连接表示字符范围，如<code>[0-9]</code>表示匹配数字0到数字9之间的数字；特殊字符在集合中会失去它本来的匹配含义，如<code>[+*]</code>只会匹配<code>+</code>或者<code>*</code>字符；字符类如 <code>\w</code> 或者 <code>\S</code> (如下定义) 在集合内可以接受；不在集合范围内的字符可以通过取反来进行匹配，如果集合首字符是<code>^</code>则所有不在集合内的字符会被匹配，如<code>[^8]</code>代表除了数字8之外将匹配所有的字符；若要在集合内匹配字符<code>]</code>要么放在集合的首位字符，要么加反斜杠<code>\</code>进行转义</td></tr><tr><td>`</td><td>`</td><td>连接任意两个正则表达式，如A\</td><td>B，将会匹配满足A表达式或满足B表达式的字符串</td></tr><tr><td><code>(...)</code></td><td>匹配括号内的任意正则表达式，并标识出组合的开始和结尾</td></tr><tr><td><code>(?...)</code></td><td>扩展类标记，<code>&#39;?&#39;</code> 后面的第一个字符决定了这个构建采用什么样的语法。</td></tr><tr><td><code>(?aiLmsux)</code></td><td><code>(?…)</code>支持的扩展类型，( <code>&#39;a&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;L&#39;</code>, <code>&#39;m&#39;</code>, <code>&#39;s&#39;</code>, <code>&#39;u&#39;</code>, <code>&#39;x&#39;</code> 中的一个或多个) 这个组合匹配一个空字符串；这些字符对正则表达式设置以下标记 <code>re.A</code> (只匹配ASCII字符), <code>re.I</code>(忽略大小写), <code>re.L</code>(语言依赖), <code>re.M</code> (多行模式), <code>re.S</code> (点dot匹配全部字符), <code>re.U</code> (Unicode匹配), and <code>re.X</code> (冗长模式)</td></tr><tr><td><code>(?:...)</code></td><td>匹配在括号内的任何正则表达式，但该分组所匹配的子字符串 <em>不能</em> 在执行匹配后被获取或是之后在模式中被引用。</td></tr><tr><td><code>(?imsx-imsx:...)</code></td><td></td></tr><tr><td><code>(?P&lt;name&gt;...)</code></td><td>（命名组合）类似正则组合，但是匹配到的子串组在外部是通过定义的 <em>name</em> 来获取的。组合名必须是有效的Python标识符，并且每个组合名只能用一个正则表达式定义，只能定义一次。</td></tr><tr><td><code>(?P=name)</code></td><td>反向引用一个命名组合；它匹配前面那个叫 <em>name</em> 的命名组中匹配到的串同样的字串</td></tr><tr><td><code>(?#...)</code></td><td>注释；里面的内容会被忽略。</td></tr><tr><td><code>(?=...)</code></td><td>匹配 … 的内容，但是并不匹配除完全样式的内容。这个叫做 lookahead assertion。比如， Isaac (?=Asimov) 匹配 ‘Isaac ‘ 只有在后面是  ‘Asimov’ 的时候才会被匹配到。</td></tr><tr><td><code>(?!...)</code></td><td>匹配 … 不符合的情况。这个叫 negative lookahead assertion （前视取反）。比如说， Isaac (?!Asimov)只有后面 不 是 ‘Asimov’ 的时候才匹配 ‘Isaac ‘ 。</td></tr><tr><td><code>(?&lt;=...)</code></td><td>匹配字符串的当前位置，它的前面匹配 <code>…</code> 的内容到当前位置。这叫:dfn:positive lookbehind assertion（正向后视断定）</td></tr><tr><td><code>(?&lt;!...)</code></td><td>匹配当前位置之前不是 <code>…</code> 的样式。这个叫:dfn:negative lookbehind assertion （后视断定取非）。类似正向后视断定，包含的样式匹配必须是定长的。</td></tr><tr><td>`(?(id/name)yes-pattern</td><td>no-pattern)`</td><td>如果给定的  id 或 name 存在，将会尝试匹配 yes-pattern ，否则就尝试匹配 no-pattern，no-pattern 可选，也可以被忽略。比如， (&lt;)?(\w+@\w+(?:.\w+)+)(?(1)&gt;</td></tr></tbody></table><h3 id="反斜杠符号-与普通字符组成的特殊序列"><a href="#反斜杠符号-与普通字符组成的特殊序列" class="headerlink" title="反斜杠符号\与普通字符组成的特殊序列"></a>反斜杠符号\与普通字符组成的特殊序列</h3><p>由<code>\</code>和字符组成的特殊序列情况，如果普通字符不是ASCII数位或者ASCII字母，正则表达式将匹配第二个字符，此外构成的特殊序列有:</p><table><thead><tr><th>特殊序列</th><th>含义</th></tr></thead><tbody><tr><td><code>\d</code></td><td>匹配任何十进制数字，等价于<code>[0-9]</code></td></tr><tr><td><code>\D</code></td><td>匹配任何非数字字符，等价于<code>[^0-9]</code></td></tr><tr><td><code>\s</code></td><td>匹配任何空白字符，等价于<code>[ \t\n\r\f\v]</code></td></tr><tr><td><code>\S</code></td><td>匹配任何非空白字符，等价于<code>[^ \t\n\r\f\v]</code></td></tr><tr><td><code>\w</code></td><td>匹配任何字母与数字字符，等价于<code>[a-zA-Z0-9_]</code></td></tr><tr><td><code>\W</code></td><td>匹配任何非字母与数字字符，等价于<code>[^a-zA-Z0-9_]</code></td></tr><tr><td><code>\A</code></td><td>只匹配字符串开始</td></tr><tr><td><code>\Z</code></td><td>只匹配字符串结束</td></tr><tr><td><code>\b</code></td><td>匹配空字符串，但只在单词开始或结尾的位置。通常 <code>\b</code> 定义为 <code>\w</code> 和 <code>\W</code> 字符之间，或者 <code>\w</code> 和字符串开始/结尾的边界</td></tr><tr><td><code>\B</code></td><td>匹配空字符串，但 <em>不</em> 能在词的开头或者结尾</td></tr></tbody></table><h2 id="正则表达式使用"><a href="#正则表达式使用" class="headerlink" title="正则表达式使用"></a>正则表达式使用</h2><p><strong>re</strong>模块提供了API接口<code>re.compile()</code>来将正则编译为对象，然后用来进行匹配。</p><p>示例代码:</p><pre><code class="python">&gt;&gt;&gt; import re&gt;&gt;&gt; res = re.compile(&#39;ab+&#39;)&gt;&gt;&gt; resre.compile(&#39;ab+&#39;)</code></pre><p>其中<code>re.compile()</code>也可以接收可选的<em>flags</em>参数,具体的参数值后面单独模块介绍</p><pre><code class="python">&gt;&gt;&gt; res = re.compile(&#39;ab+&#39;, re.IGNORECASE)</code></pre><p><strong>re</strong>模块是Python附带的C扩展模块，正则被处理称为了字符串，并没有创建用于表达式正则的特殊语法。</p><h2 id="反斜杠特别注意问题-amp-解决方法"><a href="#反斜杠特别注意问题-amp-解决方法" class="headerlink" title="反斜杠特别注意问题&amp;解决方法"></a>反斜杠特别注意问题&amp;解决方法</h2><p><code>\</code>可以用来表示特殊形式或不调用特殊含义，又因为Python将正则表达式处理成来字符串来处理， 而反斜杠在普通的 Python 字符串里也有相同的作用，所以就产生了冲突。比如说要匹配一个字母上的反斜杠，其正则表达式要写成<code>\\\\</code>，因为正则表达式力匹配一个反斜杠必须是<code>\\</code>，而每个反斜杠在普通Python字符中也要写成<code>\\</code>，所以造成如果正则表达式匹配一个反斜杠，必须要写成<code>\\\\</code>的问题。</p><p>问题的解决办法是：对于正则表达式样式使用Python的原始字符串表示，使用字符前面带<code>r</code>字符表示法用Python代码编写正则表达式。这么做的原因是在带有 <code>&#39;r&#39;</code> 前缀的字符串字面值中，反斜杠不必做任何特殊处理。 因此 <code>r&quot;\n&quot;</code> 表示包含 <code>&#39;\&#39;</code> 和 <code>&#39;n&#39;</code> 两个字符的字符串，而 <code>&quot;\n&quot;</code> 则表示只包含一个换行符的字符串。</p><h2 id="re模块内容编译标志"><a href="#re模块内容编译标志" class="headerlink" title="re模块内容编译标志"></a>re模块内容编译标志</h2><p><strong>re</strong>模块定义了一些<em>常量</em>作为内容编译标志，编译标志允许修改正则表达式的工作方式，例如前面<code>re.compile()</code>函数中使用的<em>flag</em>参数就是<strong>re</strong>模块的内容编译标志。</p><p><strong>re模块内容编译标志有</strong>：</p><table><thead><tr><th>编译标志</th><th>含义</th></tr></thead><tbody><tr><td>re.A / re.ASCII</td><td>让 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\d</code>, <code>\D</code>, <code>\s</code> 和 <code>\S</code> 只匹配ASCII，而不是Unicode。这只对Unicode样式有效，会被byte样式忽略。相当于前面语法中的内联标志 <code>(?a)</code>；为了保持向后兼容， <code>re.U</code> 标记依然存在（还有他的同义  <code>re.UNICODE</code> 和嵌入形式 <code>(?u)</code> ) ， 但是这些在 Python 3 是冗余的，因为默认字符串已经是Unicode了（并且Unicode匹配不允许byte出现)</td></tr><tr><td>re.DEBUG</td><td>显示编译时的debug信息，没有内联标记</td></tr><tr><td>re.I /re.IGNORECASE</td><td>进行忽略大小写匹配；表达式如 <code>[A-Z]</code> 也会匹配小写字符。Unicode匹配（比如 <code>Ü</code> 匹配 <code>ü</code>）同样有用，除非设置了 <code>re.ASCII</code> 标记来禁用非ASCII匹配。当前语言区域不会改变这个标记，除非设置了 <code>re.LOCALE</code> 标记，相当于内联标记 <code>(?i)</code> 。</td></tr><tr><td>re.L / re.LOCALE</td><td>由当前语言区域决定 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code> 和大小写敏感匹配。这个标记只能对byte样式有效。这个标记不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 语句，而且只对8位字节有效。Unicode匹配在Python 3 里默认启用，并可以处理不同语言。 这个对应内联标记 <code>(?L)</code>；Python3.6改版后re.LOCALE只能用于byte样式，并且不能与re.ASCII一起用</td></tr><tr><td>re.M / re.MULTILINE</td><td>设置以后，样式字符 ‘^’ 匹配字符串的开始，和每一行的开始（换行符后面紧跟的符号）；样式字符 ‘\$’ 匹配字符串尾，和每一行的结尾（换行符前面那个符号）。默认情况下，’^’ 匹配字符串头，’\$’ 匹配字符串尾。对应内联标记 <code>(?m)</code> 。</td></tr><tr><td>re.S / re.DOTALL</td><td>让 ‘.’ 特殊字符匹配任何字符，包括换行符；如果没有这个标记，’.’ 就匹配 除了 换行符的其他任意字符。对应内联标记<code>(?s)</code> 。</td></tr><tr><td>re.X / re.VERBOSE</td><td>这个标记使得正则表达式具备更友好的可读性。通过分段和添加注释。空白符号会被忽略，除非在一个字符集合当中或者由反斜杠转义，或者在 <code>*?</code>, <code>(?:</code> or <code>(?P&lt;…&gt;</code> 分组之内。当一个行内有 <code>#</code> 不在字符集和转义序列，那么它之后的所有字符都是注释。对应内联标记 <code>(?x)</code> 。</td></tr></tbody></table><p>以下两种表达式等价,匹配一个十进制数字</p><pre><code class="python">&gt;&gt;&gt; a = re.compile(r&quot;&quot;&quot;\d +  # the integral part                   \.    # the decimal point                   \d *  # some fractional digits&quot;&quot;&quot;, re.X)&gt;&gt;&gt; b = re.compile(r&quot;\d+\.\d*&quot;)</code></pre><h2 id="字符比较"><a href="#字符比较" class="headerlink" title="字符比较"></a>字符比较</h2><p>利用<code>re.compile()</code>函数将正则表达式编译为字符串后，若要将被匹配的字符串与其比较，则需要调用其内置的函数，但<strong>re</strong>模块提供了相同功能的函数，其效果等同。</p><p>如:</p><pre><code class="python">prog = re.compile(pattern)result = prog.match(string)</code></pre><p>等价于：</p><pre><code class="python">result = re.match(pattern, string)</code></pre><p>虽然以上两种方式等同，但模块级的函数会被缓存，所以不用考虑编译问题；如果需要多次使用同一个正则表达式，保存这个正则对象以便复用，可以让程序更加高效。其它函数也与上面的情况相同。</p><p><strong>re</strong>模块的字符比较函数有:</p><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td>re.match(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</td><td>如果 <em>string</em> 开始的0个或者多个字符匹配到了正则表达式样式，就返回一个相应的 匹配对象(后面模块介绍)。 如果不匹配，就返回 <code>None</code> ；值的注意的是该比较函数跟零长度匹配不同</td></tr><tr><td>re.search(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</td><td>扫描整个 字符串 找到匹配样式的第一个位置，并返回一个相应的 匹配对象。如果不匹配，就返回一个 None ； 同样值的注意的是该函数与找到一个零长度匹配不同。</td></tr><tr><td>re.fullmatch(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</td><td>确定正则是否从字符串的开头到结尾是否完全匹配。如果整个 <em>string</em> 匹配到正则表达式样式，就返回一个相应的 匹配对象 。 否则就返回一个 <code>None</code>。Python3.4之后版本功能</td></tr><tr><td>re.findall(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</td><td>对 <em>string</em> 返回一个与<em>pattern</em>表达式式规则匹配的不重复 列表， <em>string</em> 从左到右进行扫描，按找到的匹配顺序返回。如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表，空匹配也会包含在结果里。</td></tr><tr><td>re.finditer(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</td><td>找到正则匹配的所有子字符串，并将它们返回为一个 迭代器类型，<em>string</em> 从左到右进行扫描，按找到的匹配顺序返回，空匹配也会包含在结果里。</td></tr></tbody></table><h2 id="字符串修改"><a href="#字符串修改" class="headerlink" title="字符串修改"></a>字符串修改</h2><p>re模块同样提供了对字符串截取、替换等字符串操作。提供的函数有：</p><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>re.split(<em>pattern</em>, <em>string</em>, <em>maxsplit=0</em>, <em>flags=0</em>)</td><td>用 <em>pattern</em> 分开  <em>string</em> 。 如果在 <em>pattern</em> 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 <em>maxsplit</em> 非零， 最多进行 <em>maxsplit</em> 次分隔， 剩下的字符全部返回到列表的最后一个元素</td></tr><tr><td>re.sub(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em>)</td><td>返回通过替换 <em>replacement</em> 替换 <em>string</em> 中正则的最左边非重叠出现而获得的字符串。 如果未找到模式，则 <em>string</em> 将保持不变。可选参数 <em>count</em> 是要替换的模式最大的出现次数；<em>count</em> 必须是非负整数。 默认值 0 表示替换所有。</td></tr><tr><td>re.subn(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em>)</td><td>行为与 sub()相同，但是返回一个元组 <code>(字符串, 替换次数)</code>.</td></tr><tr><td>re.escape(<em>pattern</em>)</td><td>匹配除ASCII、数字和’_’以外的所有字符。如果要匹配可能包含正则表达式元字符的任意文本字符串，该函数比较适用。</td></tr><tr><td>re.purge()</td><td>清除正则表达式缓存</td></tr><tr><td>re.error(<em>msg</em>, <em>pattern=None</em>, <em>pos=None</em>)</td><td>当传递到函数的字符串不是一个有效正则表达式的时候（比如，包含一个不匹配的括号）或者其他错误在编译时或匹配时产生。如果字符串不包含样式匹配，是不会被视为错误的。错误实例有以下附加属性，msg:未格式化的错误消息； pattern：正则表达式样式；pos：编译失败的pattern位置索引； lineno：对应pos的行号；colno：对应pos的列号</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import re&gt;&gt;&gt; resplit = re.compile(r&#39;\W+&#39;)&gt;&gt;&gt; resplit.split(&#39;This is a test, short and sweet, of split().&#39;)[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;, &#39;short&#39;, &#39;and&#39;, &#39;sweet&#39;, &#39;of&#39;, &#39;split&#39;, &#39;&#39;]#上面的方式与下面调用re模块函数等价&gt;&gt;&gt; re.split(r&#39;\W+&#39;, &#39;This is a test, short and sweet, of split().&#39;)[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;, &#39;short&#39;, &#39;and&#39;, &#39;sweet&#39;, &#39;of&#39;, &#39;split&#39;, &#39;&#39;]&gt;&gt;&gt; re.split(r&#39;\W+&#39;, &#39;This is a test, short and sweet, of split().&#39;, 1)[&#39;This&#39;, &#39;is a test, short and sweet, of split().&#39;]&gt;&gt;&gt; re.split(r&#39;\W+&#39;,&#39;This is a test,short and sweet, of spilt().&#39;, 3)[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test,short and sweet, of spilt().&#39;]#如果分隔符里有捕获组合，并且匹配到字符串的开始，结果将返回一个以空字符开头的列表&gt;&gt;&gt; re.split(r&#39;\W+&#39;, &#39;...This is a test, short and sweet, of spilt()&#39;, 3)[&#39;&#39;, &#39;This&#39;, &#39;is&#39;, &#39;a test, short and sweet, of spilt()&#39;]#sub函数&gt;&gt;&gt; resubs = re.compile(&#39;(blue|white|red)&#39;)&gt;&gt;&gt; resubs.sub(&#39;color&#39;, &#39;blue T-shirt and red T-shirt&#39;)&#39;color T-shirt and color T-shirt&#39;&gt;&gt;&gt; resubs.sub(&#39;color&#39;, &#39;blue T-shirt and red T-shirt&#39;, count=1)&#39;color T-shirt and red T-shirt&#39;#re模块等价函数&gt;&gt;&gt; re.sub(&#39;(blue|white|red)&#39;, &#39;color&#39;, &#39;blue T-shirt and red T-shirt&#39;, 2)&#39;color T-shirt and color T-shirt&#39;#subn函数&gt;&gt;&gt; p = re.compile(&#39;(blue|white|red)&#39;)&gt;&gt;&gt; p.subn(&#39;color&#39;, &#39;blue socks and red shoes&#39;)(&#39;color socks and color shoes&#39;, 2)&gt;&gt;&gt; p.subn(&#39;color&#39;, &#39;no colors at all&#39;)(&#39;no colors at all&#39;, 0)&gt;&gt;&gt; re.subn(&#39;(blue|white|red)&#39;, &#39;color&#39;, &#39;blue socks and red shoes&#39;)(&#39;color socks and color shoes&#39;, 2)&gt;&gt;&gt; re.subn(&#39;(blue|white|red)&#39;,&#39;color&#39;,&#39;no colors at all&#39;)(&#39;no colors at all&#39;, 0)# sub函数只有当空匹配项与前一个匹配项不相邻时，才会替换&gt;&gt;&gt; re.sub(&#39;x*&#39;, &#39;-&#39;, &#39;abxd&#39;)&#39;-a-b-d-&#39;</code></pre><h2 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h2><p>match()和search()两个函数会返回一个匹配对象，匹配对象总是有个Bool值，如果能够匹配则返回结果有值，如果不匹配，则匹配对象不存在，可以用以下方式进行检验</p><pre><code class="python">match = re.search(pattern, string)if match:    print (match)#实例如下：&gt;&gt;&gt; match = re.match(&#39;ab*&#39;, &#39;abb&#39;)&gt;&gt;&gt; if match:       print (match)&lt;_sre.SRE_Match object; span=(0, 3), match=&#39;abb&#39;&gt;&gt;&gt;&gt;</code></pre><p>匹配对象具有一些方法和属性可以进行后续操作：</p><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>match.expand(<em>template</em>)</td><td></td></tr><tr><td>math.group([<em>group1</em>,….])</td><td>返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）。 如果一个组N 参数值为 0，相应的返回值就是整个匹配字符串；如果它是一个范围 [1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，一个 <a href="https://docs.python.org/English/3.6/library/exceptions.html#IndexError"><code>IndexError</code></a> 索引错误就 会产生。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。</td></tr><tr><td>math.getitem(<em>g</em>)</td><td>等价于 <code>m.group(g)</code></td></tr><tr><td>match.groups(<em>default=None</em>)</td><td>回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。 <em>default</em> 参数用于不参与匹配的情况，默认为 <code>None</code>。</td></tr><tr><td>match.groupdic(<em>default=None</em>)</td><td>返回一个字典，包含了所有的 <em>命名</em> 子组。key就是组名。 <em>default</em> 参数用于不参与匹配的组合；默认为 <code>None</code>。</td></tr><tr><td>match.start(g)</td><td>返回 <em>group</em> 匹配到的字串的开始标号。<em>group</em> 默认为0（意思是整个匹配的子串）。如果  <em>group</em> 存在，但未产生匹配，就返回 <code>-1</code></td></tr><tr><td>match.end(g)</td><td>返回 <em>group</em> 匹配到的字串的结束标号。<em>group</em> 默认为0（意思是整个匹配的子串）。如果  <em>group</em> 存在，但未产生匹配，就返回 <code>-1</code></td></tr><tr><td>match.span(g)</td><td>对于一个匹配 <em>m</em> ， 返回一个二元组 <code>(m.start(group), m.end(group))</code> 。 注意如果 <em>group</em> 没有在这个匹配中，就返回 <code>(-1, -1)</code> 。<em>group</em> 默认为0，就是整个匹配</td></tr><tr><td>match.pos</td><td>search()或match()函数进行匹配时设置的pos值</td></tr><tr><td>match.endpos</td><td>search()或match()函数进行匹配时设置的endpos值</td></tr><tr><td>match.lastindex</td><td>捕获组的最后一个匹配的整数索引值，或者 <code>None</code> 如果没有匹配产生的话。比如，对于字符串 <code>&#39;ab&#39;</code>，表达式 <code>(a)b</code>, <code>((a)(b))</code>, 和 <code>((ab))</code> 将得到 <code>lastindex == 1</code> ， 而 <code>(a)(b)</code> 会得到 <code>lastindex == 2</code></td></tr><tr><td>match.lastgroup</td><td>最后一个匹配的命名组名字，或者 <code>None</code> 如果没有产生匹配的话</td></tr><tr><td>mathc.re</td><td>match（）或search（）方法生成匹配实例的正则表达式对象</td></tr><tr><td>match.string</td><td>传递给match()或search()的字符串</td></tr></tbody></table><h2 id="match-与search-对比"><a href="#match-与search-对比" class="headerlink" title="match()与search() 对比"></a>match()与search() 对比</h2><p><code>re.match(</code>)函数和<code>re.search()</code>函数是Python提供的两种不同操作，<code>re.match()</code>检查字符串开头，而<code>re.search()</code>检查字符串中的任意位置</p><p>如下情况，match不匹配，但search进行匹配</p><pre><code class="python">&gt;&gt;&gt; re.match(&#39;super&#39;, &#39;insuper&#39;)&gt;&gt;&gt; re.search(&#39;super&#39;, &#39;insuper&#39;)&lt;_sre.SRE_Match object; span=(2, 7), match=&#39;super&#39;&gt;</code></pre><p>可以用’^’作为限制让<code>search()</code>函数从首位开始匹配</p><pre><code class="python">&gt;&gt;&gt; re.search(&#39;super&#39;, &#39;insuper&#39;)&lt;_sre.SRE_Match object; span=(2, 7), match=&#39;super&#39;&gt;&gt;&gt;&gt; re.search(&#39;^super&#39;, &#39;insuper&#39;)</code></pre><p><code>MULTILINE</code>多行模式中函数<code>match()</code>只匹配字符串的开始，但使用<code>search()</code>和以 <code>&#39;^&#39;</code> 开始的正则表达式会匹配每行的开始</p><pre><code class="python">&gt;&gt;&gt; re.match(&#39;^X&#39;, &#39;A\nB\nX&#39;, re.MULTILINE)&gt;&gt;&gt; re.search(&#39;^X&#39;, &#39;A\nB\nX&#39;, re.MULTILINE)&lt;_sre.SRE_Match object; span=(4, 5), match=&#39;X&#39;&gt;</code></pre><h2 id="regex模块"><a href="#regex模块" class="headerlink" title="regex模块"></a>regex模块</h2><p><strong>regex</strong>模块实现是在<strong>re</strong>模块的基础上，但提供了额外的功能。<strong>re</strong>模块在Python3.7中对零长度匹配做了修改，regex模块在Python3.7中也会遵循<strong>re</strong>模块的设定。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p><strong>regex</strong>模块支持Unicode11.0，并且中Unicode匹配不区分大小写。<strong>regex</strong>模块支持简单和完整的大小写折叠，用于<strong>Unicode</strong>中不区分大小写的匹配。匹配模式可以使用 <code>FULLCASE</code> 、 <code>F</code>标志，或<code>(?f)</code>，但这些标志会影响<code>IGNORECASE</code>标志的工作，<code>FULLCASE</code>标志本身不会启用不区分大小写的匹配。在V.0版本中，该标志默认是关闭的；在V1.0中，该标志默认开启。</p><p>###嵌套集合和集合操作</p><p>在最初始版本中因为<strong>regex</strong>模块中对为转义的 <code>[</code> 字符设定含义不同，所以<strong>regex</strong>模块不能支持<strong>re</strong>模块中由<code>[]</code>定义的嵌套集合。举例来说， <code>[[a-z]--[aeiou]]</code> 在V.0中被解读为：</p><p>1.包含“[”和字母“A”到“Z”的集合</p><p>2.字面量<code>-</code></p><p>3.包含字母 “a”, “e”, “i”, “o”, “u”</p><p>4.字母量<code>]</code></p><p>但在V.1中解读为：</p><p>1.包含字母’a’到’z’的集合</p><p>2.但是不包括字母“a”, “e”, “i”, “o”, “u”</p><p>这是英文V.0只支持简单集合，直到V.1才支持嵌套集合和集合操作。</p><h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>regex模块中有两大类型标志：范围标志和全局标志。范围标志应用于局部正则表达式，可设置为True或False；全局标志被应用于全局变量，但只可设置为True。</p><p>范围标志有: <code>FULLCASE</code>、<code>IGNORECASE</code>、<code>MULTILINE</code>、 <code>DOTALL</code>、 <code>VERBOSE</code>、<code>WORD</code></p><p>全局标志有: <code>ASCII</code>、<code>BESTMATCH</code>、 <code>ENHANCEMATCH</code>、<code>LOCALE</code>、<code>POSIX</code>、<code>REVERSE</code>、 <code>UNICODE</code>、 <code>VERSION0</code>、<code>VERSION1</code></p><p>如果 <code>ASCII</code>、<code>LOCALE</code>、<code>UNICODE</code> 三个标志都没有被明确定义，正则表达式匹配的是Unicode字符的情况下，默认开启 <code>UNICODE</code> 标志；正则表达式匹配的是bytes类型，默认开启 <code>ASCII</code>标志。</p><p><code>ENHANCEMATCH</code>开始的是模糊匹配模式，会尝试改进找到下一个匹配项。</p><p><code>BESTMATCH</code>标志使模糊匹配尝试找到最佳结果。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>regex模块在匹配内置（不可变）字符串类型对象时会及时释放GIL，这样其它的Python线程可以并发运行。此外可以通过设置关键字参数concurrent=True调用匹配方法，可以强制释放GIL，但这种情况的使用只能在保证字符串在匹配过程中不会发生改变的情况下才可以使用。</p><h3 id="regex正则表达式对象函数"><a href="#regex正则表达式对象函数" class="headerlink" title="regex正则表达式对象函数"></a>regex正则表达式对象函数</h3><p>regex模块提供的方法和属性有：</p><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>regex.match(<em>string, pos, endpos</em>)</td><td>如果 <em>string</em> 的 <em>开始位置</em> 能够找到这个正则样式的任意个匹配，就返回一个相应的匹配对象，否则就返回 <code>None</code>；可选的第二个参数 <em>pos</em> 给出了字符串中开始搜索的位置索引；默认为 <code>0</code>；可选参数 <em>endpos</em> 限定了字符串搜索的结束；它假定字符串长度到 <em>endpos</em> ， 所以只有从 <code>pos</code> 到 <code>endpos -1</code> 的字符会被匹配。如果 <em>endpos</em> 小于 <em>pos</em>，就不会有匹配产生</td></tr><tr><td>regex.search(<em>string, pos, endpos</em>)</td><td>扫描整个 <em>string</em> 寻找第一个匹配的位置， 并返回一个相应的匹配对象，否则就返回 <code>None</code>；可以接收可选参数 <em>pos</em> 和 <em>endpos</em> 来确定操作的开始字符和结束字符来限制范围</td></tr><tr><td>regex.fullmatch(<em>string, pos, endpos</em>)</td><td>如果整个 <em>string</em> 匹配这个正则表达式，就返回一个相应的匹配对象，否则就返回 <code>None</code>；可以接收可选参数 <em>pos</em> 和 <em>endpos</em> 来确定操作的开始字符和结束字符来限制范围</td></tr><tr><td>regex.split(<em>string, maxsplit=0</em>)</td><td>等价于re.spilt()函数</td></tr><tr><td>regex.findall(<em>string, pos, endpos</em>)</td><td>类似函数 findall() ，可以接收可选参数 <em>pos</em> 和 <em>endpos</em> 来确定操作的开始字符和结束字符来限制范围</td></tr><tr><td>regex.finditer(<em>string, pos, endpos</em>)</td><td>类似函数 <code>finiter()</code> ，可以接收可选参数 <em>pos</em> 和 <em>endpos</em> 来确定操作的开始字符和结束字符来限制范围</td></tr><tr><td>regex.sub(<em>repl, string, count=0</em>)</td><td>等价于 re模块中的re.sub()函数</td></tr><tr><td>regex.subn(*repl, strring, count=0)</td><td>等价于 re模块中的re.subn()函数</td></tr><tr><td>regex.flags</td><td>正则匹配标记</td></tr><tr><td>regex.groups</td><td>捕获组合的数量。</td></tr><tr><td>regex.groupindex</td><td>映射由 <code>(?P&lt;id&gt;)</code> 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的</td></tr><tr><td>regex.pattern</td><td>编译的RE对象的字符串模式</td></tr></tbody></table><p><strong>代码示例</strong>:</p><pre><code class="python">&gt;&gt;&gt; import regex&gt;&gt;&gt;#设定的匹配规则是：匹配以十进制数字开头对十进制数字匹配超过1次 或者满足匹配字母和数字超过1次；其中 ？= 代表lookahead assertion&gt;&gt;&gt; regex.match(r&#39;(?(?=\d)\d+|\w+)&#39;, &#39;123abc&#39;)&lt;regex.Match object; span=(0, 3), match=&#39;123&#39;&gt;&gt;&gt;&gt; regex.match(r&#39;(?(?=\d)\d+|\w+)&#39;, &#39;abc123&#39;)&lt;regex.Match object; span=(0, 6), match=&#39;abc123&#39;&gt;&gt;&gt;&gt;#对于上面的匹配规则可以看出|匹配符 若满足第一个正则表达式则不判断第二个表达式，例如第一个例子中给出的字符是&#39;123abc&#39;然后前面的123 满足第一条匹配规则，所以看到匹配对象返回的span是(0，3)；而对于第二个例子中给出的字符&#39;abc123&#39;并不满足第一条匹配十进制数字说以进行第二项表达式的匹配，发现与第二条表达式匹配，匹配结果是&#39;abc123&#39;,所以返回的span是(0,6)&gt;&gt;&gt;&gt;&gt;&gt; print (regex.match(r&#39;(?(?=\d)\d+\b|\w+)&#39;, &#39;123abc&#39;))None&gt;&gt;&gt; print (regex.match(r&#39;(?:(?=\d)\d+\b|\w+)&#39;, &#39;123abc&#39;))&lt;regex.Match object; span=(0, 6), match=&#39;123abc&#39;&gt;&gt;&gt;#在上面的操作中修改了正则表达式，加入\b代表匹配的数字开始和结束必须是空字符;第一条语句在&#39;123abc&#39;不满足条件的时候没有进行第二条正则表达式的匹配；第二条语句因为?:代表后面的语句都要匹配一遍，所以在第一条正则表达式不满足条件的时候去匹配了第二条正则表达式</code></pre><hr><p><strong>使用POSIX返回最左边的最长匹配，可以使用POSIX标志(?P)</strong></p><pre><code class="python">&gt;&gt;&gt;#正常拼写规则&gt;&gt;&gt; regex.search(r&#39;Mr|Mrs&#39;, &#39;Mrs&#39;)&lt;regex.Match object; span=(0, 2), match=&#39;Mr&#39;&gt;&gt;&gt;&gt; regex.search(r&#39;one(self)?(selfsufficient)?&#39;, &#39;oneselfsufficient&#39;)&lt;regex.Match object; span=(0, 7), match=&#39;oneself&#39;&gt;&gt;&gt;&gt;#使用POSIX标志之后&gt;&gt;&gt; regex.search(r&#39;(?p)Mr|Mrs&#39;, &#39;Mrs&#39;)&lt;regex.Match object; span=(0, 3), match=&#39;Mrs&#39;&gt;&gt;&gt;&gt; regex.search(r&#39;(?p)one(self)?(selfsufficient)?&#39;, &#39;oneselfsufficient&#39;)&lt;regex.Match object; span=(0, 17), match=&#39;oneselfsufficient&#39;&gt;</code></pre><p>不过这样做的缺点是：耗时更长，因为在找到匹配项之后不会立即返回，而是继续查找看是否有更长的匹配项</p><hr><p><strong>使用<code>?(DEFINE)</code>在没有分组名为’DEDINE’的情况下，可以使用其在分组</strong></p><pre><code class="python">&gt;&gt;&gt; regex.search(r&#39;(?(DEFINE)(?P&lt;quant&gt;\d+)(?P&lt;item&gt;\w+))(?&amp;quant) (?&amp;item)&#39;, &#39;5 elephants&#39;)&lt;regex.Match object; span=(0, 11), match=&#39;5 elephants&#39;&gt;&gt;&gt;&gt; regex.search(r&#39;(?P&lt;quant&gt;\d+)(?P&lt;item&gt;\w+)(?&amp;quant) (?&amp;item)&#39;, &#39;5 elephants&#39;)&gt;&gt;&gt; </code></pre><hr><p>正则表达式中添加<code>(*PRUNE)</code> <code>(*SKIP)</code> and <code>(*FAIL)</code> 情况如下：</p><p><code>(*PRUNE)</code>能将回溯信息丢弃到该点，在原子组 或 lookaround中使用时不会影响封闭模式。</p><p><code>(*SKIP)</code> 与 <code>(*PRUNE)</code>类似，但是会设置文本中下次尝试匹配的起始位置，同样在原子组 或 lookaround中使用时不会影响封闭模式。</p><p><code>(*FAIL)</code>会导致立即回溯，<code>(*F)</code>是其缩写。</p><hr><p>使用<code>\K</code>则会整个在<code>K</code>位置出现之后的匹配部分，在<code>K</code>位置之前的将被舍弃，但是不会影响捕获组返回的内容。</p><pre><code class="python">&gt;&gt;&gt; m = regex.search(r&#39;(\w\w\K\w\w\w)&#39;, &#39;abcdef&#39;)&gt;&gt;&gt; print (m)&lt;regex.Match object; span=(2, 5), match=&#39;cde&#39;&gt;&gt;&gt;&gt; m[0]&#39;cde&#39;&gt;&gt;&gt; m[1]&#39;abcde&#39;&gt;&gt;&gt;&gt;&gt;&gt; m = regex.search(r&#39;(?r)(\w\w\K\w\w\w\w)&#39;, &#39;abcdef&#39;)&gt;&gt;&gt; m[0]&#39;ab&#39;&gt;&gt;&gt; m[1]&#39;abcdef&#39;</code></pre><hr><p><strong>可以使用订阅获取重复捕获组的捕获为expandf、subf、subfn添加捕获订阅</strong></p><pre><code class="python">&gt;&gt;&gt; m = regex.match(r&quot;(\w)+&quot;, &quot;abc&quot;)&gt;&gt;&gt; m.expandf(&quot;{1}&quot;)&#39;c&#39;&gt;&gt;&gt; m.expandf(&quot;{1[0]} {1[1]} {1[2]}&quot;)&#39;a b c&#39;&gt;&gt;&gt; m.expandf(&quot;{1[-1]} {1[-2]} {1[-3]}&quot;)&#39;c b a&#39;&gt;&gt;&gt;&gt;&gt;&gt; m = regex.match(r&quot;(?P&lt;letter&gt;\w)+&quot;, &quot;abc&quot;)&gt;&gt;&gt; m.expandf(&quot;{letter}&quot;)&#39;c&#39;&gt;&gt;&gt; m.expandf(&quot;{letter[0]} {letter[1]} {letter[2]}&quot;)&#39;a b c&#39;&gt;&gt;&gt; m.expandf(&quot;{letter[-1]} {letter[-2]} {letter[-3]}&quot;)&#39;c b a&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式（称为RE，或正则，或正则表达式模式）本质上是嵌入在Python中的一种微小的、高度专业化的编程语言。&lt;strong&gt;re&lt;/strong&gt;模块提供来正则表达式匹配操作，用来对文本进行一些处理优化。匹配模式和被搜索的字符串既可以是&lt;strong&gt;Unicode&lt;/
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数据类型(二)文本类型-str</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonDataTypeString/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonDataTypeString/</id>
    <published>2017-05-04T13:13:46.000Z</published>
    <updated>2019-05-17T11:17:01.733Z</updated>
    
    <content type="html"><![CDATA[<p>Python中处理文本数据使用由Unicode编码构成的不可变序列字符串—str对象。字符串表达形式如下:</p><p>.单引号 ‘This article describes information about str object’</p><p>.双引号 “This article describes information about str object”</p><p>.三重引号 ‘’‘ This article describes information about str object’’’</p><p>使用三重引号的字符串可以跨越多行，并且所有的空字符串都包含在字符串值中。</p><p>str类型同样是不可变类型，除了上面三种显式构建方式之外，也同样有构建函数进行构建</p><h2 id="字符串构建"><a href="#字符串构建" class="headerlink" title="字符串构建"></a>字符串构建</h2><p>构建函数：</p><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td><strong>str</strong>(object=b’’)</td><td>返回构建的字符串</td></tr><tr><td><strong>str</strong>(object=’’, encoding=’uft-8’, errors=’strict’)</td><td>返回由object构成的字符串，若object为空，则返回空字符串，如果encoding或errors均未设置<code>str(object)</code> 返回 <a href="https://docs.python.org/zh-cn/3.6/reference/datamodel.html#object.__str__"><code>object.__str__()</code></a>，这是 <em>object</em> 的“非正式”或格式良好的字符串表示。 对于字符串对象，这是该字符串本身。 如果 <em>object</em> 没有 <a href="https://docs.python.org/zh-cn/3.6/reference/datamodel.html#object.__str__"><code>__str__()</code></a> 方法，则 <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#str"><code>str()</code></a> 将回退为返回 <a href="https://docs.python.org/zh-cn/3.6/library/functions.html#repr"><code>repr(object)</code></a>。如果 <em>encoding</em> 或 <em>errors</em> 至少给出其中之一，则 <em>object</em> 应该是一个 <a href="https://docs.python.org/zh-cn/3.6/glossary.html#term-bytes-like-object">bytes-like object</a> (例如 <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#bytes"><code>bytes</code></a> 或 <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#bytearray"><code>bytearray</code></a>)。 在此情况下，如果 <em>object</em> 是一个 <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#bytes"><code>bytes</code></a> (或 <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#bytearray"><code>bytearray</code></a>) 对象，则 <code>str(bytes, encoding, errors)</code> 等价于 <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#bytes.decode"><code>bytes.decode(encoding, errors)</code></a>。 否则的话，会在调用 <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#bytes.decode"><code>bytes.decode()</code></a> 之前获取缓冲区对象下层的 bytes 对象。 请参阅 <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#binaryseq">二进制序列类型 — bytes, bytearray, memoryview</a> 与 <a href="https://docs.python.org/zh-cn/3.6/c-api/buffer.html#bufferobjects">缓冲协议</a> 了解有关缓冲区对象的信息。</td></tr><tr><td>io.<strong>StringIO</strong>()</td><td>Text I/O内存缓冲区，若调用close()方法则缓冲区结束</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; str(b&#39;Zoot!&#39;)&quot;b&#39;Zoot!&#39;&quot;</code></pre><h2 id="字符串访问"><a href="#字符串访问" class="headerlink" title="字符串访问"></a>字符串访问</h2><p>可以直接通过index的方式访问字符串中的字符，如字符串s = ‘abcdfdeff’, s[0] = ‘a’, s[0:3]=’abc’, s[0:3]也可以写成s[:3],代表从0个位置开始，取第3个字符之前的字节，第一个数字代表从第几个字符开始，：后面代表取到第几个字节（最后一个字节的字符不包含在内）。</p><p>因为不存在单独的字符类型，对字符串做索引操作的时候会产生长度为1的字符串，即<code>s[0] == s[0:1]</code></p><h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><p>字符串的字面值定义如下：</p><pre><code class="python">stringliteral   ::=  [stringprefix](shortstring | longstring)stringprefix    ::=  &quot;r&quot; | &quot;u&quot; | &quot;R&quot; | &quot;U&quot; | &quot;f&quot; | &quot;F&quot;                     | &quot;fr&quot; | &quot;Fr&quot; | &quot;fR&quot; | &quot;FR&quot; | &quot;rf&quot; | &quot;rF&quot; | &quot;Rf&quot; | &quot;RF&quot;shortstring     ::=  &quot;&#39;&quot; shortstringitem* &quot;&#39;&quot; | &#39;&quot;&#39; shortstringitem* &#39;&quot;&#39;longstring      ::=  &quot;&#39;&#39;&#39;&quot; longstringitem* &quot;&#39;&#39;&#39;&quot; | &#39;&quot;&quot;&quot;&#39; longstringitem* &#39;&quot;&quot;&quot;&#39;shortstringitem ::=  shortstringchar | stringescapeseqlongstringitem  ::=  longstringchar | stringescapeseqshortstringchar ::=  &lt;any source character except &quot;\&quot; or newline or the quote&gt;longstringchar  ::=  &lt;any source character except &quot;\&quot;&gt;stringescapeseq ::=  &quot;\&quot; &lt;any source character&gt;</code></pre><pre><code class="python">bytesliteral   ::=  bytesprefix(shortbytes | longbytes)bytesprefix    ::=  &quot;b&quot; | &quot;B&quot; | &quot;br&quot; | &quot;Br&quot; | &quot;bR&quot; | &quot;BR&quot; | &quot;rb&quot; | &quot;rB&quot; | &quot;Rb&quot; | &quot;RB&quot;shortbytes     ::=  &quot;&#39;&quot; shortbytesitem* &quot;&#39;&quot; | &#39;&quot;&#39; shortbytesitem* &#39;&quot;&#39;longbytes      ::=  &quot;&#39;&#39;&#39;&quot; longbytesitem* &quot;&#39;&#39;&#39;&quot; | &#39;&quot;&quot;&quot;&#39; longbytesitem* &#39;&quot;&quot;&quot;&#39;shortbytesitem ::=  shortbyteschar | bytesescapeseqlongbytesitem  ::=  longbyteschar | bytesescapeseqshortbyteschar ::=  &lt;any ASCII character except &quot;\&quot; or newline or the quote&gt;longbyteschar  ::=  &lt;any ASCII character except &quot;\&quot;&gt;bytesescapeseq ::=  &quot;\&quot; &lt;any ASCII character&gt;</code></pre><p>第一种字面值是描述str类型，第二种字面值是描述bytes类型。</p><p>如果字符串前面带有’b’或’B’ 等bytesprefix类型，则生成的是bytes类型；如果字符串前面带有’r’,’u’则生成的是str类型；如果字符串前面带有’r’或’R’，则代表字符串不会进行转义。</p><p>为了与 Python 2 系列的向下兼容，再次允许字符串字面值使用 <code>u</code> 前缀。 它对字符串字面值的含义没有影响，并且不能与 <code>r</code> 前缀同时出现。</p><h3 id="转义序列-amp-行边界"><a href="#转义序列-amp-行边界" class="headerlink" title="转义序列&amp;行边界"></a>转义序列&amp;行边界</h3><table><thead><tr><th>表示符</th><th>描述</th></tr></thead><tbody><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\r\n</td><td>回车+换行</td></tr><tr><td>\v 或\x0b</td><td>行制表符-纵向</td></tr><tr><td>\f或\x0c</td><td>换表单</td></tr><tr><td>\x1c</td><td>文件分隔符</td></tr><tr><td>\x1d</td><td>组分隔符</td></tr><tr><td>\x1e</td><td>记录分隔符</td></tr><tr><td>\x85</td><td>下一行</td></tr><tr><td>\u2018</td><td>行分隔符</td></tr><tr><td>\u2029</td><td>段分隔符</td></tr><tr><td>\</td><td>在行尾时为续行符</td></tr><tr><td>\</td><td>反斜扛符号</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\”</td><td>双引号</td></tr><tr><td>\a</td><td>响铃</td></tr><tr><td>\b</td><td>退格(Backspace)</td></tr><tr><td>\000</td><td>空</td></tr><tr><td>\t</td><td>横向制表符</td></tr><tr><td>\o</td><td>八进制数</td></tr><tr><td>\x</td><td>十六进制数</td></tr><tr><td>\other</td><td>其它的字符以普通格式输出</td></tr></tbody></table><h3 id="字面值拼接"><a href="#字面值拼接" class="headerlink" title="字面值拼接"></a>字面值拼接</h3><p>多个相邻的字符串或字节串字面值 (以空白符分隔)，所用的引号可以彼此不同，其含义等同于全部拼接为一体。因此， <code>&quot;hello&quot; &#39;world&#39;</code> 等同于 <code>&quot;helloworld&quot;</code>。此特性可以减少反斜杠的使用，以方便地将很长的字符串分成多个物理行，甚至每部分字符串还可分别加注释</p><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>字符串定义的常量有:</p><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td><strong>ascii_letters</strong></td><td>ascii_lowercase和asscii_uppercase的拼接组合</td></tr><tr><td><strong>ascii_lowercase</strong></td><td>26个小写字母’abcdefghijklmnopqrstuvwxyz’，不依赖本地，不可改变</td></tr><tr><td><strong>ascii_uppercase</strong></td><td>26个大写字母’ABCDEFGHIJKLMNOPQRSTUVWXYZ’，不依赖本地，不可改变</td></tr><tr><td><strong>digits</strong></td><td>字符串 <code>&#39;0123456789&#39;</code></td></tr><tr><td><strong>hexdigits</strong></td><td>字符串 <code>&#39;0123456789abcdefABCDEF&#39;</code></td></tr><tr><td><strong>octdigits</strong></td><td>字符串 <code>&#39;01234567&#39;</code></td></tr><tr><td><strong>punctuation</strong></td><td>c标准库中的ASCII标点符号</td></tr><tr><td><strong>printable</strong></td><td>可打印的ASCII常量，是digts、ascii_letters、punctuation、whitespace的组合</td></tr><tr><td><strong>whitespace</strong></td><td>所有空白符的ASCII字符，如空格， tab，换行，回车，换页，制表符等</td></tr></tbody></table><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><h3 id="一般字符格式化"><a href="#一般字符格式化" class="headerlink" title="一般字符格式化"></a>一般字符格式化</h3><p>string 模块中提供来一般字符格式化转换类，利用转换类中的转换函数可以格式化字符串。格式转换类为string模块中的<strong>Formatter</strong>类，<strong>Formatter</strong>类中的转换函数有：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><strong>format</strong>(format_string, *args, **kwargs) 3.5版本后已移除</td><td>返回一串字符串，format_string为输入的格式化字符，是vformat函数的包装</td></tr><tr><td><strong>vformat</strong>(format_string, args, kwargs)</td><td>完成字符格式化实际工作，虽然vformat()作为一个单独的函数使用，但是其实它是一些列函数的组合，vformat函数会调用表格后面的函数来完成字符串的格式化。</td></tr><tr><td><strong>parse</strong>(format_string)</td><td>循环检测fromat_string，并返回一个iterable格式的元组(literal_text, field_name, format_spec, conversion).vformat（）使用该函数将字符串拆分为文本或替换字段。概念上元组中的值表示一个后面跟着替换字符的文本，如果文本为空或文本后面跟着两个替换字符，则文本将是零长度字符串。如果文本不为空，但是后面没有跟着替换字符，则元组中的自断值都是None</td></tr><tr><td><strong>get_field</strong>(field_name, args, kwargs)</td><td>返回parse()返回的field_name，args和kwargs都是vformat()函数传入的参数</td></tr><tr><td><strong>get_value</strong>(key, args, kwargs)</td><td>检索给定的key值，给定的key值是整数或字符类型中的一种，如果是一个整数，则代表args参数中的位置坐标，如果是字符串则代表kwargs参数中的名称。args参数设置为vformat（）的位置参数列表，kwargs参数设置为关键字参数字典。</td></tr><tr><td><strong>check_unused_args</strong>(used_args, args, kwargs)</td><td>对未使用的参数进行检查，参数来源是传给vformat函数的参数，以及在上面步骤中未使用的args参数</td></tr><tr><td><strong>format_fiedl</strong>(value, format_spec)</td><td>format_field（）只调用内置的global format（）。提供方法以便子类可以重写。</td></tr><tr><td><strong>convert_field</strong>(value,conversion)</td><td>转换给定转换类型（如parse（）方法返回的元组）的值（由get_field（）返回）。默认的转换类型‘s’ (str), ‘r’ (repr) 和 ‘a’ (ascii)</td></tr></tbody></table><h3 id="格式化字符串语法"><a href="#格式化字符串语法" class="headerlink" title="格式化字符串语法"></a>格式化字符串语法</h3><p>str.format()方法和Formatter类为格式化字符串提供相同的语法，但是仍有一些不同。</p><p>格式字符串包含由大括号包围的“替换字段”{替换值}。不包含在大括号中的任何内容都被视为文本，它将原封不动地复制到输出中。如果需要在文本中包含大括号字符，则可以通过加倍对其进行转义： 。在一些比较正式的语法中，替换字段可以以字段名开始，该字段名指定要格式化其值并插入到输出中而不是替换字段中的对象。字段“名称”后面可选跟一个转换字段，转换字段前面加一个感叹号“！”和格式“spec”，前面是冒号“：”。它们为替换值指定非默认格式。</p><p>字段“名称”本身以数字或关键字的参数开头。如果是数字，则表示位置参数；如果是关键字，则表示命名关键字参数。如果格式字符串中的数字arg_名称按顺序是0、1、2，…，则可以全部省略，数字0、1、2，…）将自动按该顺序插入。因为arg_名称不是用引号分隔的，所以不能在格式字符串中指定任意字典键（例如字符串“10”或“：-]”）。参数名后面可以跟任意数量的索引或属性表达式。表单的表达式“.name”使用getattr（）选择命名属性，而表单的表达式“[index]”使用getitem()进行索引查找。</p><p>3.1版本中 str.<strong>format</strong>（）可以省略位置参数说明符，因此’{}{}’.<strong>format</strong>（a，b）等同于“0 1”格式 ‘{0} {1}’.<strong>format</strong>(a, b)。 3.5版本之后格式化程序可以省略位置参数说明符。</p><p>转换字段在格式化前导致类型强制。通常，格式化值的工作是由值本身的<strong>format()</strong>方法完成。但是，在某些情况下，需要强制将类型格式化为字符串，从而覆盖其自己的格式化定义。通过在调用<strong>format()</strong>之前将值转换为字符串，可以绕过正常的格式化逻辑。例如<code>&#39;!s&#39;</code> 会先调用 <strong>str()</strong>函数进行转换 , <code>&#39;!r&#39;</code> 会先调用<strong>repr()</strong>函数进行转换以及<code>!a</code>会先调用<strong>ascii()</strong>函数进行转换。</p><p><code>format_spec</code>字段包含如何显示值的说明，包括字段宽度、对齐方式、填充、小数精度等详细信息。每个值类型都可以定义自己的<strong>Mini-Language</strong>或格式说明。<code>format_spec</code>字段还可以包含嵌套的替换字段。这些嵌套的替换字段可能包含字段名、转换标志和格式规范，但不允许进行更深层次的嵌套。<code>format_spec</code>中的替换字段在格式化format_spec字符串之前被替换。这样造成可以允许动态指定值的格式。</p><p>通过位置访问参数进行替换:</p><pre><code class="python">&gt;&gt;&gt; &#39;{0},{1},{2}&#39;.format(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)&#39;a,b,c&#39;&gt;&gt;&gt; &#39;{},{},{}&#39;.format(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)&#39;a,b,c&#39;&gt;&gt;&gt; &#39;{2},{1},{0}&#39;.format(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)&#39;c,b,a&#39;&gt;&gt;&gt; &#39;{},{},{}&#39;.format(*&#39;abc&#39;)&#39;a,b,c&#39;&gt;&gt;&gt; &#39;{2},{1},{0}&#39;.format(*&#39;abc&#39;)&#39;c,b,a&#39;&gt;&gt;&gt; &#39;{0},{1},{0}&#39;.format(&#39;abra&#39;, &#39;cad&#39;)&#39;abra,cad,abra&#39;</code></pre><p>通过name访问参数进行替换：</p><pre><code class="python">&gt;&gt;&gt; &#39;Coordinates: {latitude},{longitude}&#39;.format(latitude=&#39;37.24N&#39;, longitude=&#39;-115.81W&#39;)&#39;Coordinates: 37.24N,-115.81W&#39;&gt;&gt;&gt; &quot;I&#39;m a girl and my job is {jobname}&quot;.format(jobname=&#39;Data Analysistic&#39;)&quot;I&#39;m a girl and my job is Data Analysistic&quot;</code></pre><p>通过属性访问参数进行替换：</p><pre><code class="python">&gt;&gt;&gt; c = 3-5j&gt;&gt;&gt; (&#39;复数{0}是由实部{0.real} 和 虚部{0.imag}构成&#39;).format(c)&#39;复数(3-5j)是由实部3.0 和 虚部-5.0构成&#39;&gt;&gt;&gt; class Point:           def __init__(self, x, y):                self.x, self.y = x, y           def __str__(self):                return &#39;Point({self.x}, {self.y})&#39;.format(self=self)&gt;&gt;&gt; str(Point(4,2))&#39;Point(4, 2)&#39;</code></pre><p>通过items访问参数进行替换：</p><pre><code class="python">&gt;&gt;&gt; coord = (3,4)&gt;&gt;&gt; &#39;X:{0[0]}; Y:{0[1]}&#39;.format(coord)&#39;X:3; Y:4&#39;</code></pre><p>替换%s和%r：</p><pre><code class="python">&gt;&gt;&gt; &quot;repr() shows quotes:{!r}; str() doesn&#39;t:{!s}&quot;.format(&#39;test1&#39;,&#39;test2&#39;)&quot;repr() shows quotes:&#39;test1&#39;; str() doesn&#39;t:test2&quot;</code></pre><p>对齐文本并指定宽度：</p><pre><code class="python">&gt;&gt;&gt; &#39;{:&lt;30}&#39;.format(&#39;left aligned&#39;)&#39;left aligned                  &#39;&gt;&gt;&gt; &#39;{:&gt;30}&#39;.format(&#39;right aligned&#39;)&#39;                 right aligned&#39;&gt;&gt;&gt; &#39;{:^30}&#39;.format(&#39;centered&#39;)&#39;           centered           &#39;&gt;&gt;&gt; &#39;{:*^30}&#39;.format(&#39;centered&#39;)&#39;***********centered***********&#39;</code></pre><p>替换%+f, %-f,  % f以及指定符号：</p><pre><code class="python">&gt;&gt;&gt; &#39;{:&lt;30}&#39;.format(&#39;left aligned&#39;)&#39;left aligned                  &#39;&gt;&gt;&gt; &#39;{:&gt;30}&#39;.format(&#39;right aligned&#39;)&#39;                 right aligned&#39;&gt;&gt;&gt; &#39;{:^30}&#39;.format(&#39;centered&#39;)&#39;           centered           &#39;&gt;&gt;&gt; &#39;{:*^30}&#39;.format(&#39;centered&#39;)&#39;***********centered***********&#39;</code></pre><p>替换%x,%o以及将值转换为不同的基数:</p><pre><code class="python">&gt;&gt;&gt; &quot;int:{0:d}; hex:{0:x}; oct:{0:o};  bin:{0:b}&quot;.format(42)&#39;int:42; hex:2a; oct:52;  bin:101010&#39;&gt;&gt;&gt; &quot;int:{0:d}; hex:{0:#x}; oct:{0:#o}; bin:{0:#b}&quot;.format(42)&#39;int:42; hex:0x2a; oct:0o52; bin:0b101010&#39;&gt;&gt;&gt; </code></pre><p>使用逗号<code>,</code>作为千位分隔符:</p><pre><code class="python">&gt;&gt;&gt; &#39;{:,}&#39;.format(1234567890)&#39;1,234,567,890&#39;&gt;&gt;&gt; </code></pre><p>百分数形式替换：</p><pre><code class="python">&gt;&gt;&gt; points = 19&gt;&gt;&gt; total = 22&gt;&gt;&gt; &#39;Correct answers:{:.2%}&#39;.format(points/total)&#39;Correct answers:86.36%&#39;</code></pre><p>特殊类型格式转换:</p><pre><code class="python">&gt;&gt;&gt; import datetime&gt;&gt;&gt; d = datetime.datetime(2018,5,4,21,54,16)&gt;&gt;&gt; &#39;{:%Y-%m-%d %H:%M:%S}&#39;.format(d)&#39;2018-05-04 21:54:16&#39;</code></pre><p>嵌套参数和更复杂的示例：</p><pre><code class="python">&gt;&gt;&gt; for align, text in zip(&#39;&lt;^&gt;&#39;, [&#39;left&#39;, &#39;center&#39;, &#39;right&#39;]):    &#39;{0:{fill}{align}16}&#39;.format(text, fill=align, align=align)&#39;left&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#39;&#39;^^^^^center^^^^^&#39;&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;right&#39;&gt;&gt;&gt; octets = [192,168,0,1]&gt;&gt;&gt; &#39;{:02X}{:02X}{:02X}{:02X}&#39;.format(*octets)&#39;C0A80001&#39;&gt;&gt;&gt; &#39;{:02X}{:02X}{:02X}{:02X}&#39;.format(*octets)&#39;C0A80001&#39;&gt;&gt;&gt; int(_, 16)3232235521&gt;&gt;&gt; width = 5&gt;&gt;&gt; for num in range(5, 12):    for base in &#39;dXob&#39;:        print(&#39;{0:{width}{base}}&#39;.format(num, base=base, width=width), end=&#39;&#39;)    print()    5    5    5  101    6    6    6  110    7    7    7  111    8    8   10 1000    9    9   11 1001   10    A   12 1010   11    B   13 1011&gt;&gt;&gt; </code></pre><h3 id="格式化字符Mini-Language"><a href="#格式化字符Mini-Language" class="headerlink" title="格式化字符Mini-Language"></a>格式化字符Mini-Language</h3><h4 id="格式化符号"><a href="#格式化符号" class="headerlink" title="格式化符号"></a>格式化符号</h4><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>%c</td><td>格式化字符及其ASCII码</td></tr><tr><td>%s</td><td>格式化字符串</td></tr><tr><td>%d</td><td>格式化整数</td></tr><tr><td>%u</td><td>格式化无符号整数</td></tr><tr><td>%o</td><td>格式化无符号八进制数</td></tr><tr><td>%x</td><td>格式化无符号十六进制数</td></tr><tr><td>%X</td><td>格式化无符号十六进制数(大写)</td></tr><tr><td>%f</td><td>格式化化浮点数字，可以指定小数点后的精度</td></tr><tr><td>%e</td><td>用科学记数法格式化浮点数</td></tr><tr><td>%E</td><td>作用同%e，用科学记数法格式化浮点数</td></tr><tr><td>%g</td><td>%f和%e的简写</td></tr><tr><td>%G</td><td>%f 和 %E 的简写</td></tr><tr><td>%p</td><td>用十六进制数格式化变量的地址</td></tr></tbody></table><h4 id="格式化旗标"><a href="#格式化旗标" class="headerlink" title="格式化旗标"></a>格式化旗标</h4><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>‘#’</td><td>值的转换将使用”替代形式”</td></tr><tr><td>0</td><td>转换将为数字值填充零字符</td></tr><tr><td>‘-‘</td><td>转换值左对齐，如果同时给出’0’转换，则会覆盖’0’转换</td></tr><tr><td>‘ ‘</td><td>(空格) 符号位转换产生的正数（或空字符串）前将留出一个空格</td></tr><tr><td>‘+’</td><td>符号字符 (<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>) 将显示于转换结果的开头（会覆盖 “空格” 旗标）</td></tr></tbody></table><h4 id="格式化类型"><a href="#格式化类型" class="headerlink" title="格式化类型"></a>格式化类型</h4><table><thead><tr><th>转换符</th><th>描述</th></tr></thead><tbody><tr><td>‘d’</td><td>有符号十进制整数</td></tr><tr><td>‘i’</td><td>有符号十进制整数</td></tr><tr><td>‘o’</td><td>有符号八进制数</td></tr><tr><td>‘u’</td><td>无符号十进制整数</td></tr><tr><td>‘a’</td><td>字符串(使用ascii()转换Python对象)</td></tr><tr><td>‘e’</td><td>浮点指数格式(小写)</td></tr><tr><td>‘E’</td><td>浮点指数格式(大写)</td></tr><tr><td>‘f’</td><td>浮点十进制格式</td></tr><tr><td>‘F’</td><td>浮点十进制格式</td></tr><tr><td>‘g’</td><td>浮点格式，如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。</td></tr><tr><td>‘G’</td><td>浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。</td></tr><tr><td>‘c’</td><td>单个字符(接受整数或单个字符的字符串)</td></tr><tr><td>‘r’</td><td>字符串(使用repr()转换Python对象)</td></tr><tr><td>‘s’</td><td>字符串(使用str()转换Python对象)</td></tr><tr><td>‘x’</td><td>有符号十六进制数(小写)</td></tr><tr><td>‘X’</td><td>有符号十六进制数(大写)</td></tr><tr><td>‘%’</td><td>不转换参数，在结果中输出一个’%’字符</td></tr></tbody></table><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串提供来更简单的字符串替换形式，这样做重要的一点是国际化(i18n)，较简单的语法和功能比Python其它内置字符串格式化更容易链接编译。</p><h3 id="模板字符串规则"><a href="#模板字符串规则" class="headerlink" title="模板字符串规则"></a>模板字符串规则</h3><p>模板字符串支持基于$的替换，使用以下规则：</p><p>. $$ is an escape; it is replaced with a single $</p><p>.$idenfifier 匹配字典中的名为’idenfifier’的key。默认情况下，’identifier’仅限于以下划线或ASCII字母开头的任何不区分大小写的ASCII字母数字字符串（包括下划线）,  \$ 字符后的第一个非标识字符代表终止字符</p><p>.${identifier} 和 \$identifier 含义相同。当有效的标识字符跟在占位符之后但不是占位符的一部分(如\${noun}ification)的时候，必须采用\${identifier}的写法</p><p>字符串中出现的任何其他$都将导致引发ValueError。</p><h3 id="木板字符串函数"><a href="#木板字符串函数" class="headerlink" title="木板字符串函数"></a>木板字符串函数</h3><p>string模块提供了Temple类执行以上规则，Temple类的方法有：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>class  string.<strong>Template</strong>(template)</td><td>构造函数，参数template是模板字符串</td></tr><tr><td><strong>substitute</strong>(mapping, **kwds)</td><td>执行模板替换，返回新字符串。映射任何类似字典的对象，其键与模板中的占位符匹配。也可以提供关键字参数，其中关键字是占位符。当同时给出映射和kwds同时给出时，kwds中的占位符优先。</td></tr><tr><td><strong>safe_substitue</strong>(mapping, **kwds)</td><td>与substitute（）类似，但不同的是如果在映射和kwd中缺少占位符，不会引发keyError异常，否则原始占位符将完整显示在结果字符串中。此外,任何以\$形式出现的字符串都不会引发VauleError。此方法被称为safe 替换函数，是因为当其它异常产生时，该方法总是尝试返回可用的字符串而不是引发异常。从另一种情况来说，safe_substitue()之所以称之为安全的方法，并非是因为它真正安全，而是因为它会默默地忽略格式错误的模板字符串，错误的模板字符串包含格式不完整的分隔符、不匹配的大括号、不是有效Python占位符的标识符。</td></tr><tr><td><strong>template</strong>()</td><td>模板实例提供的公共数据属性，返回提供给Template参数的模板字符串值。一般来说，不应该更改它，但访问的时候也并不能指定为只读。</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; from string import Template&gt;&gt;&gt; s = Template(&#39;$who likes $what&#39;)&gt;&gt;&gt; s.substitute(who=&#39;tim&#39;, what=&#39;running&#39;)&#39;tim likes running&#39;&gt;&gt;&gt; d = dict(who=&#39;tim&#39;)&gt;&gt;&gt;#制造KeyError&gt;&gt;&gt; Template(&#39;Give $who $100&#39;).substitute()Traceback (most recent call last):  File &quot;&lt;pyshell#33&gt;&quot;, line 1, in &lt;module&gt;    Template(&#39;Give $who $100&#39;).substitute()  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/string.py&quot;, line 130, in substitute    return self.pattern.sub(convert, self.template)  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/string.py&quot;, line 123, in convert    return str(mapping[named])KeyError: &#39;who&#39;&gt;&gt;&gt;#制造valueError&gt;&gt;&gt; Template(&#39;Give $who $100&#39;).substitute(d)Traceback (most recent call last):  File &quot;&lt;pyshell#34&gt;&quot;, line 1, in &lt;module&gt;    Template(&#39;Give $who $100&#39;).substitute(d)  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/string.py&quot;, line 130, in substitute    return self.pattern.sub(convert, self.template)  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/string.py&quot;, line 127, in convert    self._invalid(mo)  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/string.py&quot;, line 103, in _invalid    (lineno, colno))ValueError: Invalid placeholder in string: line 1, col 11&gt;&gt;&gt;#制造keyError&gt;&gt;&gt; Template(&#39;$who likes $what&#39;).substitute(d)Traceback (most recent call last):  File &quot;&lt;pyshell#35&gt;&quot;, line 1, in &lt;module&gt;    Template(&#39;$who likes $what&#39;).substitute(d)  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/string.py&quot;, line 130, in substitute    return self.pattern.sub(convert, self.template)  File &quot;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/string.py&quot;, line 123, in convert    return str(mapping[named])KeyError: &#39;what&#39;&gt;&gt;&gt;#用safe_substitute函数避免Error&gt;&gt;&gt; Template(&#39;$who likes $what&#39;).safe_substitute(d)&#39;tim likes $what&#39;</code></pre><h3 id="模板字符串高级用法"><a href="#模板字符串高级用法" class="headerlink" title="模板字符串高级用法"></a>模板字符串高级用法</h3><p><strong>高级用法</strong>：</p><p>可以派生模板的子类，以自定义占位符语法、分隔符或用于分析模板字符串的整个正则表达式。为此，可以重写这些类属性：</p><p><em>delimiter</em> – 描述引入分隔符的占位符的文本字符串,默认值为$。注意，这不能是正则表达式，如果想要传入正则表达式，需要根据具体的规则在此字符串上调用re.escape()。<br><em>idpattern</em> –描述无效占位符的正则表达式(括号将根据需要自动添加)。默认值是正则表达式<code>(?-i:[_a-zA-Z][_a-zA-Z0-9]*)</code></p><p><em>flags</em> –正则表达式标志，在编译期间将正则表达式转换为实际应用规则时被使用。默认值是re.VERBOSE。值得注意的是re.VERBOSE无论如何都会被添加到标志中，所以自定义的ID模式必须符合详细的正则表达式规则。</p><p>或者，可以通过重写类属性模式来提供整个正则表达式模式。这么做的前提是该值必须是具有四个捕获组组成的正则表达式对象， 捕获组与给出的规则以及无效的占位符规则相对应:</p><p><em>escaped</em> – 该捕获组与默认模式中的转义序列（例如$$）匹配</p><p><em>named</em> – 该捕获组与无空格的占位符名称匹配，并且不能包含分隔符</p><p><em>braced</em> –  该捕获组与括号内的占位符名称匹配，不能包含分隔符或括号</p><p><em>invalid</em> –  该捕获组与任何其他分隔符模式（通常是单个分隔符）匹配，它应该出现在正则表达式的最后一个</p><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>str.<strong>capitalize</strong>()</td><td>返回字符串的副本，首个字符大写，其余为小写</td></tr><tr><td>str.<strong>casefold</strong>()</td><td>返回字符串消除大小写的副本，可以用于忽略大小写的匹配</td></tr><tr><td>str.<strong>center</strong>(width, fillchar)</td><td>返回长度为 <em>width</em> 的字符串，原字符串在其正中。 使用指定的 <em>fillchar</em> 填充两边的空位（默认使用 ASCII 空格符）。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本</td></tr><tr><td>str.<strong>count</strong>(sub, start, end)</td><td>反回子字符串 sub 在 [start, end] 范围内非重叠出现的次数。 可选参数 start 与 end 会被解读为切片表示法。</td></tr><tr><td>str.<strong>encode</strong>(encoding=”utf-8”, errors=”strict”)</td><td>返回原字符串编码为字节串对象的版本。 默认编码为 <code>&#39;utf-8&#39;</code>。 可以给出 <em>errors</em> 来设置不同的错误处理方案。 <em>errors</em> 的默认值为 <code>&#39;strict&#39;</code>，表示编码错误会引发 <a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#UnicodeError"><code>UnicodeError</code></a>。 其他可用的值为 <code>&#39;ignore&#39;</code>, <code>&#39;replace&#39;</code>, <code>&#39;xmlcharrefreplace&#39;</code>, <code>&#39;backslashreplace&#39;</code>等。</td></tr><tr><td>str.<strong>endswith</strong>(suffix, start, end)</td><td>如果字符串是以指定的suffix结束则返回True，否则返回False<em>suffix</em> 也可以为由多个供查找的后缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</td></tr><tr><td>str.<strong>expandtabs</strong>(tabsize=8)</td><td>返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列位置和给定的制表符宽度。 每 <em>tabsize</em> 个字符设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制表符 (<code>\t</code>)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果字符为换行符 (<code>\n</code>) 或回车符 (<code>\r</code>)，它会被复制并将当前列重设为零。 任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示</td></tr><tr><td>str.<strong>find</strong>(sub,start,end)</td><td>返回子字符串 <em>sub</em> 在 <code>s[start:end]</code> 切片内被找到的最小索引。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果 <em>sub</em> 未被找到则返回 <code>-1</code>。find()方法只在需要知道 <em>sub</em> 所在位置时使用。 要检查 <em>sub</em> 是否为子字符串，请使用in 操作符</td></tr><tr><td>str.<strong>format</strong>(*args,**kwargs)</td><td>执行字符串格式化操作。 调用此方法的字符串可以包含字符串字面值或者以花括号 <code>{}</code> 括起来的替换域。 每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。 返回的字符串副本中每个替换域都会被替换为对应参数的字符串值。当使用 <code>n</code> 类型 (例如: <code>&#39;{:n}&#39;.format(1234)</code>) 来格式化数字 (int、float、complex、decimal 及其子类) 的时候，该函数会临时性地将 <code>LC_CTYPE</code> 区域设置为 <code>LC_NUMERIC</code> 区域以解码  <code>localeconv()</code> 的 <code>decimal_point</code> 和 <code>thousands_sep</code> 字段，如果它们是非 ASCII 字符或长度超过 1 字节的话，并且 <code>LC_NUMERIC</code> 区域会与 <code>LC_CTYPE</code> 区域不一致。 这个临时更改会影响其他线程。</td></tr><tr><td>str.<strong>format_map</strong>(mapping)</td><td>类似于 <code>str.format(**mapping)</code>，不同之处在于 <code>mapping</code> 会被直接使用而不是复制到一个 dict。 适宜使用此方法的一个例子是当 <code>mapping</code> 为 dict 的子类的情况。</td></tr><tr><td>str.<strong>index</strong>(sub, start, end)</td><td>类似于 find()，但在找不到子类时会引发 ValueError。</td></tr><tr><td>str.<strong>isalnum</strong>()</td><td>如果字符串中至少有一个字符且所有字符均为字母或数字则返回真值，否则返回假值。</td></tr><tr><td>str.<strong>isalpha</strong>()</td><td>如果字符串中至少有一个字符且所有字符均为字母则返回真值，否则返回假值</td></tr><tr><td>str.<strong>isdecimal</strong>()</td><td>如果字符串中至少有一个字符且所有字符均为十进制数字符则返回真值，否则返回假值</td></tr><tr><td>str.<strong>isdigit</strong>()</td><td>如果字符串中至少有一个字符且所有字符均为数字字符则返回真值，否则返回假值。</td></tr><tr><td>str.<strong>isidentifier</strong>()</td><td>如果字符串根据语言定义属于有效的标识符则返回真值</td></tr><tr><td>str.<strong>islower</strong>()</td><td>如果字符串中至少有一个区分大小写的字符, 字符均为小写则返回真值，否则返回假值。</td></tr><tr><td>str.<strong>isnumeric</strong>()</td><td>如果字符串中至少有一个字符且所有字符均为数值字符则返回真值，否则返回假值。</td></tr><tr><td>str.<strong>isprintable</strong>()</td><td>如果字符串中所有字符均为可打印字符或字符串为空则返回真值，否则返回假值。</td></tr><tr><td>str.<strong>isspace</strong>()</td><td>如果字符串中至少有一个字符且所有字符均为空白字符则返回真值，否则返回假值。</td></tr><tr><td>str.<strong>istitle</strong>()</td><td>如果字符串中至少有一个字符且为标题字符串则返回真值，例如大写字符之后只能带非大写字符而小写字符必须有大写字符打头。 否则返回假值。</td></tr><tr><td>str.<strong>isupper</strong>()</td><td>如果字符串中至少有一个区分大小写的字符 具此类字符均为大写则返回真值，否则返回假值。</td></tr><tr><td>str.<strong>join</strong>(iterable)</td><td>返回一个由 iterable 中的字符串拼接而成的字符串。 如果 iterable 中存在任何非字符串值包括 bytes 对象则会引发 TypeError。 调用该方法的字符串将作为元素之间的分隔。</td></tr><tr><td>str.<strong>ljust</strong>(width, fillchar)</td><td>返回长度为 width 的字符串，原字符串在其中靠左对齐。 使用指定的 fillchar 填充空位 (默认使用 ASCII 空格符)。 如果 width 小于等于 len(s) 则返回原字符串的副本。</td></tr><tr><td>str.<strong>lower</strong>()</td><td>返回原字符串的副本，其所有区分大小写的字符 均转换为小写。</td></tr><tr><td>str.<strong>lstrip</strong>(chars)</td><td>返回原字符串的副本，移除其中的前导字符.<em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空格符。</td></tr><tr><td>static str.<strong>maketrans</strong>(x,y,z)</td><td>此静态方法返回一个可供 str.translate() 使用的转换对照表。如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符串）映射到 Unicode 码位序号、（任意长度的）字符串或 <code>None</code> 的字典。 字符键将会被转换为码位序号。如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，x 中每个字符将被映射到 y 中相同位置的字符。 如果有第三个参数，它必须是一个字符串，其中的字符将在结果中被映射到 <code>None</code>。</td></tr><tr><td>str.<strong>partition</strong>(sep)</td><td>在 sep 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空字符串。</td></tr><tr><td>str.<strong>replace</strong>(old, new, count)</td><td>返回字符串的副本，其中出现的所有子字符串 old 都将被替换为 new。 如果给出了可选参数 count，则只替换前 count 次出现。</td></tr><tr><td>str.<strong>rfind</strong>(sub, start, end)</td><td>返回子字符串 sub 在字符串内被找到的最大（最右）索引，这样 sub 将包含在 s[start:end] 当中。 可选参数 start 与 end 会被解读为切片表示法。 如果未找到则返回 -1。</td></tr><tr><td>str.<strong>rindex</strong>(sub,start,end)</td><td>类似于 rfind()<code>，但在子字符串 *sub* 未找到时会引发 ValueError</code>ttps://)。</td></tr><tr><td>str.<strong>rjust</strong>(width, fillchar)</td><td>返回长度为 width 的字符串，原字符串在其中靠右对齐。 使用指定的 fillchar 填充空位 (默认使用 ASCII 空格符)。 如果 width 小于等于 len(s) 则返回原字符串的副本。</td></tr><tr><td>str.<strong>rpartition</strong>(sep)</td><td>在 sep 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空字符串以及字符串本身。</td></tr><tr><td>str.<strong>rsplit</strong>(sep,maxsplit=-1)</td><td>返回一个由字符串内单词组成的列表，使用 <em>sep</em> 作为分隔字符串。 如果给出了 <em>maxsplit</em>，则最多进行 <em>maxsplit</em> 次拆分，从 <em>最右边</em> 开始。 如果 <em>sep</em> 未指定或为 <code>None</code>，任何空白字符串都会被作为分隔符。</td></tr><tr><td>str.<strong>rstrip</strong>(chars)</td><td>返回原字符串的副本，移除其中的末尾字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空格符。</td></tr><tr><td>str.<strong>split</strong>(sep, maxsplit=-1)</td><td>返回一个由字符串内单词组成的列表，使用 <em>sep</em> 作为分隔字符串。 如果给出了 <em>maxsplit</em>，则最多进行 <em>maxsplit</em> 次拆分（因此，列表最多会有 <code>maxsplit+1</code> 个元素）。 如果 <em>maxsplit</em> 未指定或为 <code>-1</code>，则不限制拆分次数（进行所有可能的拆分）。如果给出了 <em>sep</em>，则连续的分隔符不会被组合在一起而是被视为分隔空字符串。</td></tr><tr><td>str.<strong>splitlines</strong>(keepends)</td><td>返回由原字符串中各行组成的列表，在行边界的位置拆分。 结果列表中不包含行边界，除非给出了 <em>keepends</em> 且为真值。</td></tr><tr><td>str.<strong>startswith</strong>(prefix, start,end)</td><td>如果字符串以指定的 prefix 开始则返回 True，否则返回 False。 prefix 也可以为由多个供查找的前缀构成的元组。 如果有可选项 start，将从所指定位置开始检查。 如果有可选项 end，将在所指定位置停止比较。</td></tr><tr><td>str.<strong>strip</strong>(chars)</td><td>返回原字符串的副本，移除其中的前导和末尾字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空格符。</td></tr><tr><td>str.<strong>swapcase</strong>()</td><td>返回原字符串的副本，其中大写字符转换为小写，反之亦然。</td></tr><tr><td>str.<strong>title</strong>()</td><td>返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。</td></tr><tr><td>str.<strong>translate</strong>(table)</td><td>返回原字符串的副本，其中每个字符按给定的转换表进行映射。 转换表必须是一个使用 <a href="https://docs.python.org/zh-cn/3.6/reference/datamodel.html#object.__getitem__"><code>__getitem__()</code></a> 来实现索引操作的对象，通常为 <a href="https://docs.python.org/zh-cn/3.6/glossary.html#term-mapping">mapping</a> 或 <a href="https://docs.python.org/zh-cn/3.6/glossary.html#term-sequence">sequence</a>。 当以 Unicode 码位序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 序号或字符串，将字符映射为一个或多个字符；返回 <code>None</code>，将字符从结果字符串中删除；或引发 <a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#LookupError"><code>LookupError</code></a> 异常，将字符映射为其自身。</td></tr><tr><td>str.<strong>upper</strong>()</td><td>返回原字符串的副本，其中所有区分大小写的字符均转换为大写。</td></tr><tr><td>str.<strong>zfill</strong>(width)</td><td>返回原字符串的副本，在左边填充 ASCII <code>&#39;0&#39;</code> 数码使其长度变为 <em>width</em>。 正负值前缀 (<code>&#39;+&#39;</code>/<code>&#39;-&#39;</code>) 的处理方式是在正负符号 <em>之后</em> 填充而非在之前。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</td></tr><tr><td>str.<strong>capwords</strong>(s, sep=None)</td><td>使用str.split（）将参数拆分为单词，使用str.capitalize（）将每个单词大写，并使用str.join（）连接大写单词。如果可选的第二个参数sep不存在或没有，则运行的空白字符将替换为单个空格，并删除前导空格和尾随空格，否则sep用于拆分和联接单词。</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; string = &#39;string synatx custom string formatting&#39;&gt;&gt;&gt; string.capitalize()&#39;String synatx custom string formatting&#39;&gt;&gt;&gt; string = string.capitalize()&gt;&gt;&gt; print (string)String synatx custom string formatting&gt;&gt;&gt; string = string.casefold()&gt;&gt;&gt; print (string)string synatx custom string formatting&gt;&gt;&gt; string.center(15, &#39;*&#39;)&#39;string synatx custom string formatting&#39;&gt;&gt;&gt; string.center(50, &#39;*&#39;)&#39;******string synatx custom string formatting******&#39;&gt;&gt;&gt; string.count(&#39;a&#39;, 0, 30)1&gt;&gt;&gt; string.endswith(&#39;.com&#39;, 0)False&gt;&gt;&gt; string.endswith(&#39;.com&#39;)False&gt;&gt;&gt; &#39;01\t012\t0123\t01234&#39;.expandtabs()&#39;01      012     0123    01234&#39;&gt;&gt;&gt; &#39;01\t012\t0123\t01234&#39;.expandtabs(5)&#39;01   012  0123 01234&#39;&gt;&gt;&gt; string.find(&#39;f&#39;)28&gt;&gt;&gt; &#39;f&#39; in stringTrue&gt;&gt;&gt; &#39;The sum of 4 + 5 is {0}&#39;.format(4+5)&#39;The sum of 4 + 5 is 9&#39;&gt;&gt;&gt; class Default(dict):    def __missing__(self, key):        return key&gt;&gt;&gt; &#39;{name} was born in {country}&#39;.format_map(Default(name=&#39;Joy&#39;))&#39;Joy was born in country&#39;&gt;&gt;&gt; &#39;{name} was born in {country}&#39;.format_map(Default(name=&#39;Joy&#39;, country=&#39;Chinese&#39;))                       &#39;Joy was born in Chinese&#39;&gt;&gt;&gt; string.isalnum()               False&gt;&gt;&gt; print (string)           string synatx custom string formatting&gt;&gt;&gt; string.isalpha()                       False&gt;&gt;&gt; string.isdecimal()                   False&gt;&gt;&gt; string.isdigit()                       False&gt;&gt;&gt; string.isidentifier()               False&gt;&gt;&gt; string.islower()               True&gt;&gt;&gt; string.isnumeric()                       False&gt;&gt;&gt; string.isprintable()                       True&gt;&gt;&gt; string.isspace()               False&gt;&gt;&gt; string.istitle()               False&gt;&gt;&gt; string.isupper()                   False&gt;&gt;&gt; string.join([&#39;len&#39;, &#39;type&#39;])               &#39;lenstring synatx custom string formattingtype&#39;&gt;&gt;&gt; &#39; &#39;.join([&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;])               &#39;red blue green&#39;&gt;&gt;&gt; string.ljust(50, &#39;*&#39;)                   &#39;string synatx custom string formatting************&#39;&gt;&gt;&gt; string.partition(&#39;syn&#39;)(&#39;string &#39;, &#39;syn&#39;, &#39;atx custom string formatting&#39;)&gt;&gt;&gt; string.replace(&#39;s&#39;, &#39;S&#39;, 2)                       &#39;String Synatx custom string formatting&#39;&gt;&gt;&gt; string.rfind(&#39;syn&#39;)                       7&gt;&gt;&gt; string.rindex(&#39;syn&#39;)                           7&gt;&gt;&gt; string.rjust(50, &#39;-&#39;)&#39;------------string synatx custom string formatting&#39;&gt;&gt;&gt; string.rsplit()[&#39;string&#39;, &#39;synatx&#39;, &#39;custom&#39;, &#39;string&#39;, &#39;formatting&#39;]&gt;&gt;&gt; string.rstrip()                   &#39;string synatx custom string formatting&#39;&gt;&gt;&gt; string.split()     [&#39;string&#39;, &#39;synatx&#39;, &#39;custom&#39;, &#39;string&#39;, &#39;formatting&#39;]&gt;&gt;&gt; string.splitlines()           [&#39;string synatx custom string formatting&#39;]&gt;&gt;&gt; string.startswith(&#39;str&#39;)                   True&gt;&gt;&gt; string.strip()     &#39;string synatx custom string formatting&#39;&gt;&gt;&gt; string.swapcase()     &#39;STRING SYNATX CUSTOM STRING FORMATTING&#39;&gt;&gt;&gt; string.title()                       &#39;String Synatx Custom String Formatting&#39;&gt;&gt;&gt; string.upper()                           &#39;STRING SYNATX CUSTOM STRING FORMATTING&#39;&gt;&gt;&gt; string.zfill(50)     &#39;000000000000string synatx custom string formatting&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python中处理文本数据使用由Unicode编码构成的不可变序列字符串—str对象。字符串表达形式如下:&lt;/p&gt;
&lt;p&gt;.单引号 ‘This article describes information about str object’&lt;/p&gt;
&lt;p&gt;.双引号 “This
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python运算(五)统计statistic模块</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonCaculationsStatisticModule/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonCaculationsStatisticModule/</id>
    <published>2017-05-03T14:44:39.000Z</published>
    <updated>2019-05-17T11:18:33.904Z</updated>
    
    <content type="html"><![CDATA[<p><strong>statistics</strong>模块为具有数字特性的数据提供数学统计计算函数，若无明确指明，支持的数据类型 <strong>int</strong>, <strong>float</strong>, <strong>decimal.Decimal</strong> 和 <strong>fractions.Fraction</strong>。其它类型暂不支持，混合类型也不能独立操作，如果 输入的数据是混合类型，必须用<code>map()</code>函数转换成可识别的类型<code>map(float, inpud_data)</code>。 <strong>statistics</strong>模块中的统计函数有：</p><h2 id="平均-amp-中位数函数-平均值、中位数等"><a href="#平均-amp-中位数函数-平均值、中位数等" class="headerlink" title="平均&amp;中位数函数(平均值、中位数等)"></a>平均&amp;中位数函数(平均值、中位数等)</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>statistic.<strong>mean</strong>()</td><td>返回数据的算术平均值，如果数据为空，则会触发<a href="https://docs.python.org/zh-cn/3.6/library/statistics.html#statistics.StatisticsError"><code>StatisticsError</code></a>。算术平均值容易受到异常值的影响，并不是一个稳定的估量值。</td></tr><tr><td>statistic.<strong>harmonic_mean</strong>()</td><td>返回调和优化平均值。调和平均值又被称为倒数平均值，是算术平均值的倒数。计算形式如下：数据a，b，c 的调和平均值为$\dfrac{3}{\dfrac{1}{a} + \dfrac{1}{b} + \dfrac{1}{c}}$     如果数据为空，或数据存在负数，同样会触发<a href="https://docs.python.org/zh-cn/3.6/library/statistics.html#statistics.StatisticsError"><code>StatisticsError</code></a></td></tr><tr><td>statistic.<strong>median</strong>()</td><td>返回数据的中位数，如果数据总和为偶数，则返回中间两个数字的平均值。中位数比较稳定，不太容易受异常数据的影响。如果数据为空，同样会触发<a href="https://docs.python.org/zh-cn/3.6/library/statistics.html#statistics.StatisticsError"><code>StatisticsError</code></a></td></tr><tr><td>statistic.<strong>median_low</strong>()</td><td>返回较低平均值，当数据总数为偶数时，取中间位置较小的数值</td></tr><tr><td>statistic.<strong>median_high</strong>()</td><td>返回较高平均值，当数据总数为偶数时，取中间位置较大的数值</td></tr><tr><td>statistic.<strong>median_grouped</strong>(data, interval = 1)</td><td>返回分组连续数据的中位数，以50%位数计算，interval代表计算间距，默认为1</td></tr><tr><td>statistic.<strong>media_mode</strong>()</td><td>返回出现频率最高的数值</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import statistics&gt;&gt;&gt; statistics.mean([23.4,47.2,56.45,65.8])48.2125&gt;&gt;&gt; statistics.harmonic_mean([2.4, 3.6, 12.3])3.867248908296943&gt;&gt;&gt; statistics.median([12,4,6,8,9,14,35])9&gt;&gt;&gt; statistics.median([1,3,5,7])4.0&gt;&gt;&gt; statistics.median_low([1,3,5,7])3&gt;&gt;&gt; statistics.median_high([1,3,5,7])5&gt;&gt;&gt; statistics.median_grouped([52,52,53,54])52.5&gt;&gt;&gt; statistics.median_grouped([1,2,2,3,4,4,4,4,4,5])3.7&gt;&gt;&gt; statistics.median_grouped([1,3,5,7], interval =1)4.5&gt;&gt;&gt; statistics.median_grouped([1,3,5,7], interval = 2)4.0&gt;&gt;&gt; statistics.mode([1,1,2,3,3,3,3,4])3&gt;&gt;&gt; statistics.mode([&#39;red&#39;,&#39;blue&#39;,&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;,&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;,&#39;red&#39;])&#39;red&#39;</code></pre><h2 id="分布函数-方差、标准差等"><a href="#分布函数-方差、标准差等" class="headerlink" title="分布函数(方差、标准差等)"></a>分布函数(方差、标准差等)</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>statistics.<strong>pstdev</strong>(data, mu=None)</td><td>返回数据的总体标准差，mu为平均值，如果给值则用指定的数值，如果没有指定，则自动计算</td></tr><tr><td>statistics.<strong>pvariance</strong>(data, mu=None)</td><td>返回数据的总体方差,mu为平均值，如果指定数据则用给定值，如果未给出，则自动计算</td></tr><tr><td>statistics.<strong>stdev</strong>(data, xbar=None)</td><td>返回数据的样品标准差，xbar如果指定则用给的值，如果没有指定则自动计算。</td></tr><tr><td>statistics.<strong>variance</strong>(data, xbar=None)</td><td>返回样本方差，如果指定xbar则用给的值，如果没有给出，则自动计算</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; statistics.pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])0.986893273527251&gt;&gt;&gt; statistics.pvariance([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])0.9739583333333334&gt;&gt;&gt; statistics.stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])1.0810874155219827&gt;&gt;&gt; statistics.variance([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])1.16875</code></pre><p>有关Python针对数据的运算各个类型数据的运算和相关的算术模块整理完毕，正因为Python对数据运算处理的庞大，使得Python在数据分析之中占有重要的位置。同时有许多外置框架将Python数据结构改良和对统计模块的扩展，例如Numpy、Pandas等，非常方便数据清洗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;statistics&lt;/strong&gt;模块为具有数字特性的数据提供数学统计计算函数，若无明确指明，支持的数据类型 &lt;strong&gt;int&lt;/strong&gt;, &lt;strong&gt;float&lt;/strong&gt;, &lt;strong&gt;decimal.Decimal&lt;/s
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python运算(四)random模块&amp;secrets模块</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculationsRandomAndSecrets/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculationsRandomAndSecrets/</id>
    <published>2017-05-03T10:52:27.000Z</published>
    <updated>2019-05-17T11:17:52.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h1><p><strong>random</strong>模块实现了这种分布的伪随机数生成器，随机数可以被应用于数学、安全等领域，并且也经常被嵌入算法中，用以提高算法效率，在机器学习算法中对随机数的设定是必要的一步，并且随机数的设定会影响算法的好坏。</p><p><strong>random</strong>模块提供的函数是基于random.Random类的隐藏实例的绑定方法，几乎所有模块函数都依赖于基本函数<code>random()</code>，<code>random()</code>函数在半开放区间[0.0, 1.0)内均匀生成随机浮点数。用Randon类作为子类，重写 <code>random()</code> 、 <code>seed()</code> 、 <code>getstate()</code> 以及 <code>setstate()</code> 方法可以自己设计不同随机生成器。</p><p><strong>random</strong>针对整数，范围有统一的选择；针对序列，随机元素统一选择、存在用于生成列表的随机排列函数，以及用于随机抽样而无需替换的函数；针对实数轴，有计算<strong>均匀、正态(高斯)、对数正态、负指数、伽马和贝塔分布</strong>的函数，生成角度分布，可以使用<strong>von Mises</strong>分布。</p><h2 id="Bookkeeping-函数"><a href="#Bookkeeping-函数" class="headerlink" title="Bookkeeping 函数"></a>Bookkeeping 函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>random.<strong>seed</strong>(a=None, version=2)</td><td>初始化随机数生成器，如果a被省略为或为None，则使用当前系统时间。如果提供随机源，则使用提供的随机源，如果a是int类型，则直接使用。</td></tr><tr><td>random.<strong>getstate</strong>()</td><td>捕获随机生成器当前内部状态的对象，可以将该对象传递给setstate()来恢复状态</td></tr><tr><td>random.<strong>setstate</strong>(state)</td><td>state是调用getstate()获得，并且setstate()将生成器的内部状态恢复到getstate()被调用时候的状态</td></tr><tr><td>random.<strong>getrandbits</strong>(k)</td><td>返回带有K位随机的Python整数，此方法随MersenneTwister生成器一起提供其他一些生成器也可以将其作为API的可选部分提供(注：Python 使用 Mersenne Twister 作为核心生成器。 它产生 53 位精度浮点数，周期为 2**19937-1)。</td></tr></tbody></table><h2 id="整数随机函数"><a href="#整数随机函数" class="headerlink" title="整数随机函数"></a>整数随机函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>random.<strong>randrange</strong>(stop)</td><td>返回不高于stop的一个随机数</td></tr><tr><td>random.<strong>randrange</strong>(start, stop, step)</td><td>从 <code>range(start, stop, step)</code> 返回一个随机选择的元素，相当于 <code>choice(range(start, stop, step))</code> ，但实际上并没有构建一个 range 对象，<em>在 3.2 版更改:</em> <a href="https://docs.python.org/zh-cn/3.6/library/random.html#random.randrange"><code>randrange()</code></a> 在生成均匀分布的值方面更为复杂</td></tr><tr><td>random.<strong>randint</strong>(a,b)</td><td>返回随机满足a&lt;=N&lt;=b的随机整数N。相当于 <code>randrange(a, b+1)</code></td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import random&gt;&gt;&gt; random.randrange(100)94&gt;&gt;&gt; random.randrange(0, 100, 3)81&gt;&gt;&gt; random.randint(0, 10)4</code></pre><h2 id="序列随机函数"><a href="#序列随机函数" class="headerlink" title="序列随机函数"></a>序列随机函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>random.<strong>choice</strong>(seq)</td><td>从非空序列 <em>seq</em> 返回一个随机元素。 如果 <em>seq</em> 为空，则引发 <a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#IndexError"><code>IndexError</code></a></td></tr><tr><td>random.<strong>choices</strong>(population, weights =None, *, cum_weights=None, k = 1 )</td><td>从<em>population</em>中选择替换，返回大小为 <em>k</em> 的元素列表。 如果 <em>population</em> 为空，则引发 IndexError。如果指定了weight序列，则根据相对权重进行选择。或者，如果给出 <em>cum_weights</em> 序列，则根据累积权重（可能使用 <a href="https://docs.python.org/zh-cn/3.6/library/itertools.html#itertools.accumulate"><code>itertools.accumulate()</code></a> 计算）进行选择。 例如，相对权重<code>[10, 5, 30, 5]</code>相当于累积权重<code>[10, 15, 45, 50]</code>。 在内部，相对权重在进行选择之前会转换为累积权重，因此提供累积权重可以节省工作量。如果既未指定 <em>weight</em> 也未指定 <em>cum_weights</em> ，则以相等的概率进行选择。 如果提供了权重序列，则它必须与 <em>population</em> 序列的长度相同。<em>weights</em> 或 <em>cum_weights</em> 可以使用任何与 <a href="https://docs.python.org/zh-cn/3.6/library/random.html#module-random"><code>random()</code></a> 返回的 <a href="https://docs.python.org/zh-cn/3.6/library/functions.html#float"><code>float</code></a> 值互操作的数值类型（包括整数，浮点数和分数但不包括十进制小数</td></tr><tr><td>random.<strong>shuffle</strong>(x, random)</td><td>将序列x随机打乱位置。可选参数 <em>random</em> 是一个0参数函数，在 [0.0, 1.0) 中返回随机浮点数；默认情况下，这是函数 <a href="https://docs.python.org/zh-cn/3.6/library/random.html#random.random"><code>random()</code></a> 。要改变一个不可变的序列并返回一个新的打乱列表，请使用<code>sample(x, k=len(x))</code>。</td></tr><tr><td>random.<strong>sample</strong>(poplation, k)</td><td>返回从总体序列或集合中选择的唯一元素的 <em>k</em> 长度列表。 用于无重复的随机抽样。返回包含来自总体的元素的新列表，同时保持原始总体不变。 结果列表按选择顺序排列，因此所有子切片也将是有效的随机样本。 这允许抽奖获奖者（样本）被划分为大奖和第二名获胜者（子切片）。要从一系列整数中选择样本，请使用 <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#range"><code>range()</code></a> 对象作为参数。 对于从大量人群中采样，这种方法特别快速且节省空间：<code>sample(range(10000000), k=60)</code> 。</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; random.choice([&#39;win&#39;, &#39;lose&#39;, &#39;draw&#39;])&#39;lose&#39;&gt;&gt;&gt; deck = &#39;one two three foure&#39;.split()&gt;&gt;&gt; random.shuffle(deck)&gt;&gt;&gt; deck[&#39;three&#39;, &#39;two&#39;, &#39;one&#39;, &#39;foure&#39;]&gt;&gt;&gt; random.sample([23,12,45,23,45,678,34,75], k = 4)[23, 75, 34, 23]</code></pre><h2 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>random.<strong>random</strong>()</td><td>返回[0.0, 1.0)范围内的一个随机浮点数</td></tr><tr><td>random.<strong>uniform</strong>(a,b)</td><td>返回一个随机浮点数 <em>N</em> ，当 <code>a &lt;= b</code> 时 <code>a &lt;= N &lt;= b</code> ，当 <code>b &lt; a</code> 时 <code>b &lt;= N &lt;= a</code> 。</td></tr><tr><td>random.<strong>triangular</strong>(low,high,mode)</td><td>返回一个随机浮点数N，使得low &lt;= N &lt;= high 并在这些边界之间使用指定的 <em>mode</em> 。 <em>low</em> 和 <em>high</em> 边界默认为零和一。 <em>mode</em> 参数默认为边界之间的中点，给出对称分布</td></tr><tr><td>random.<strong>betavariate</strong>(alpha,beta)</td><td>Beta分布，参数alpha、beta都必须&gt;0，返回的范围介于0~1之间</td></tr><tr><td>random.<strong>expovariate</strong>(lambd)</td><td>指数分布，lambd是1.0除以所需的平均值，非零。如果lambd为正，则返回0到正无穷；如果lambd为负，则返回负无穷到0。</td></tr><tr><td>random.<strong>gammavariate</strong>(alpha,beta)</td><td>Gmma分布，参数alpha和beta必须&gt;0。</td></tr><tr><td>random.<strong>gauss</strong>(mu,sigma)</td><td>高斯分布，mu是平均值，sigma是标准差</td></tr><tr><td>random.<strong>lognormvariate</strong>(mu,sigma)</td><td>对数正态分布，如果采用的是自然对数，则会得到平均值为mu，方差为sigma的正态分布，mu可以是任何职，sigma必须大于零</td></tr><tr><td>random.<strong>normalvariate</strong>(mu, sigma)</td><td>正态分布，mu是平均值，sigma是标准差</td></tr><tr><td>random.<strong>vonmisesvariate</strong>(mu, kappa)</td><td>mu是平均角度，以弧度表示，介于0和2<em>pi之间，kappa是浓度参数，必须大于或等于零，如果kappa等于零，则该分部在0到2\</em>pi的范围内较少到均匀的随机角度。</td></tr><tr><td>random.<strong>paretovariate</strong>(alpha)</td><td>帕累托分布，alpha是形状参数</td></tr><tr><td>random.<strong>weibullvariate</strong>(alpha, beta)</td><td>威布尔分布，alpha是比例参数，beta是形状参数</td></tr></tbody></table><p><strong>Gmma分布</strong>的概率函数为：</p><p>​                                            $pdf(x) = \dfrac{x^{(alpha-1)}\times math.exp(\dfrac{-x}{beta})}{math.gamma(alpha)\times beta^ {alpha}}$</p><pre><code class="python">&gt;&gt;&gt; import random&gt;&gt;&gt; random.random()0.024784298572476104&gt;&gt;&gt; random.uniform(2.0, 5.0)3.4259267542329748&gt;&gt;&gt; random.triangular(0.3, 1.5, 0.9)1.1348586558465164&gt;&gt;&gt; random.betavariate(0.3, 0.25)0.9983372793378633&gt;&gt;&gt; random.expovariate(3.0)1.680963868987473&gt;&gt;&gt; random.gammavariate(0.25, 2.0)0.0888430548880927&gt;&gt;&gt; random.gauss(13, 2.64)14.755902455467584</code></pre><h2 id="替代随机生成器"><a href="#替代随机生成器" class="headerlink" title="替代随机生成器"></a>替代随机生成器</h2><p>使用os.urandom()函数的类，用从操作系统提供的源生成随机数，但这并非适用于所有的系统，也不依赖于软件的序列状态，生成的序列不可再现，因此导致seed()方法没有效果而被忽略，getstate()和setstate()函数被调用会引发<a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#NotImplementedError"><code>NotImplementedError</code></a>。因此random模块提供了替代随机生成器：</p><p>random.<strong>SystemRandom</strong>(seed)</p><h2 id="随机序列重现问题"><a href="#随机序列重现问题" class="headerlink" title="随机序列重现问题"></a>随机序列重现问题</h2><p>有的时候需要重现伪随机数生成器给出的序列，这在一些特殊情况下有着特殊的作用，通过重新使用新种子值，只要没有多个线程同时运行，相同的序列就可以在两次不同运行之间重现。</p><p>多数的随机模块算法和种子函数都会在Python版本中发生变化，但不变的方面有两个：</p><p>. 如果添加了新的生成方法，则会提供向后兼容的随机生成器</p><p>. 当兼容的生成器被赋予相同种子，生成器的random()方法将会产生相同的序列</p><h1 id="secrets模块"><a href="#secrets模块" class="headerlink" title="secrets模块"></a>secrets模块</h1><p>虽然<strong>random</strong>模块可以生成随机数，但是并不能对生成随机数的种子、随机机制、生成的随机序列进行加密。而<strong>secrets</strong>模块就是专门用来为管理像密码、验证码、加密token等需要加密数据而生成具有非常强加密性的随机数字。</p><h2 id="加密随机数函数"><a href="#加密随机数函数" class="headerlink" title="加密随机数函数"></a>加密随机数函数</h2><p>secrets模块能够提供最强的能够操作系统提供的加密随机性资源。其访问和生成函数如下:</p><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>secrets.<strong>SystemRandom</strong></td><td>生成加密系统随机函数生成器</td></tr><tr><td>secrets.<strong>choice</strong>(sequence)</td><td>从非空序列sequence中随机返回一个元素</td></tr><tr><td>secrets.<strong>randbelow</strong>(n)</td><td>返回[0,n)范围内的随机数</td></tr><tr><td>secrets.<strong>randbits</strong>(k)</td><td>随机返回一个bit长度为k的整数</td></tr></tbody></table><h2 id="生成tokens"><a href="#生成tokens" class="headerlink" title="生成tokens"></a>生成tokens</h2><p>secrets模块为密码以及网络访问提供了生成token函数</p><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>secrets.<strong>token_bytes</strong>(nbytes=None)</td><td>随机返回字节数长度为nbytes值的字节形式的字符串，如果nbytes=None则使用默认的nbytes长度</td></tr><tr><td>secrets.<strong>token_hex</strong>(nbytes=None)</td><td>随机返回文本长度为nbytes的文本字符串，如果nbytes=None则使用默认的nbytes长度</td></tr><tr><td>secrets.<strong>token_urlsafe</strong>(nbytes=None)</td><td>随机返回URL-safe文本字符串，文本形式经过Base64转换，如果nbytes=None则使用默认的nbytes长度</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import secrets&gt;&gt;&gt; secrets.token_bytes(16)b&#39;\xe4\xef\x0e`\xf6k\xda\x01\xc2\xd0\x94L\x84B\xe2v&#39;&gt;&gt;&gt; secrets.token_hex(16)&#39;1e702fc2ed63e4e08d2b075d62b6e782&#39;&gt;&gt;&gt; secrets.token_urlsafe(16)&#39;EsZPaNvSuNKw6XpHr6xCCQ&#39;</code></pre><h2 id="token字节长度问题"><a href="#token字节长度问题" class="headerlink" title="token字节长度问题"></a>token字节长度问题</h2><p>关于token字节长度问题过去很长一段时间没有得到明确的值，直到2015年，32个字节(256bits)长度确定为是token最能接受的高效的长度。如果想要更改token字节长度，就需要给出token的长度。</p><h2 id="字节比较功能"><a href="#字节比较功能" class="headerlink" title="字节比较功能"></a>字节比较功能</h2><p>secrets模块中的secrets__compare_digest__(a,b)函数可以用来进行字节或字符的比较，如果a和b是一样的，则返回Ture，如果不同则返回False</p><h2 id="secrets-练习"><a href="#secrets-练习" class="headerlink" title="secrets 练习"></a>secrets 练习</h2><pre><code class="python">&gt;&gt;&gt; import string&gt;&gt;&gt; alphabet = string.ascii_letters + string.digits&gt;&gt;&gt; while True:    password = &#39;&#39;.join(secrets.choice(alphabet) for i in range(10))    if(any(c.islower() for c in password) and any(c.isupper() for c in password) and sum(c.isdigit() for c in password) &gt;= 3):        break</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;random模块&quot;&gt;&lt;a href=&quot;#random模块&quot; class=&quot;headerlink&quot; title=&quot;random模块&quot;&gt;&lt;/a&gt;random模块&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;random&lt;/strong&gt;模块实现了这种分布的伪随机数生成器，随机数可以
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数字运算(三)cmath模块</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculationsCmathModule/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculationsCmathModule/</id>
    <published>2017-05-03T04:56:50.000Z</published>
    <updated>2019-05-17T11:17:43.605Z</updated>
    
    <content type="html"><![CDATA[<p><strong>cmath</strong>模块为复数提供了有关数学运算函数，使得复数也能想整型或浮点型数字一样计算</p><h2 id="复数极坐标系转换函数"><a href="#复数极坐标系转换函数" class="headerlink" title="复数极坐标系转换函数"></a>复数极坐标系转换函数</h2><p>在<a href="https://onlyangelia.github.io/PythonAdvance/PythonBasicDataTypeNumber/">Python数据类型(一)数字类型</a>中讲到复数的存储本质，和在极坐标系的定义，有关极坐标转换函数如下：</p><table><thead><tr><th>函数名</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>phase</strong>(x)</td><td>以浮点数的形式返回x的弧度，范围在[-π，π]</td></tr><tr><td>cmath.<strong>polar</strong>(x)</td><td>返回x在极坐标系中的坐标(r,phi)</td></tr><tr><td>cmath.<strong>rect</strong>(r, phi)</td><td>返回坐标(r, phi)在极坐标系中对应的复数</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import cmath&gt;&gt;&gt; cmath.phase(complex(-1.0, 0.0))3.141592653589793&gt;&gt;&gt; cmath.phase(complex(-1.0,0.0))3.141592653589793&gt;&gt;&gt; cmath.phase(complex(-0.5, 0.0))3.141592653589793&gt;&gt;&gt; cmath.phase(complex(-0.5, 0.3))2.601173153319209&gt;&gt;&gt; cmath.polar(complex(-0.5, 0.3))(0.58309518948453, 2.601173153319209)&gt;&gt;&gt; cmath.rect(0.58309518948453, 2.601173153319209)(-0.49999999999999994+0.3j)</code></pre><h2 id="幂函数与对数函数"><a href="#幂函数与对数函数" class="headerlink" title="幂函数与对数函数"></a>幂函数与对数函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>exp</strong>(x)</td><td>返回<code>e**x</code></td></tr><tr><td>cmath.<strong>log</strong>(x,base)</td><td>返回以base为底x的对数</td></tr><tr><td>cmath.<strong>log10</strong>(x)</td><td>返回以10为底x的对数</td></tr><tr><td>cmath.<strong>sqrt</strong>(x)</td><td>x的开方</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; cmath.exp(complex(2.0, 0.0))(7.38905609893065+0j)&gt;&gt;&gt; cmath.exp(complex(10.0, 2.0))(-9166.244060822655+20028.608669281643j)&gt;&gt;&gt; cmath.log10(complex(100.0,2.0))(2.0000868415292326+0.008684731797315706j)&gt;&gt;&gt; cmath.sqrt(complex(2.0, 1.0))(1.455346690225355+0.34356074972251244j)</code></pre><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>acos</strong>(x)</td><td>返回x的反余弦值</td></tr><tr><td>cmath.<strong>asin</strong>(x)</td><td>返回x的反正弦值</td></tr><tr><td>cmath.<strong>atan</strong>(x)</td><td>返回x的反正切值</td></tr><tr><td>cmath.<strong>cos</strong>(x)</td><td>返回x的余弦值</td></tr><tr><td>cmath.<strong>sin</strong>(x)</td><td>返回x的正弦值</td></tr><tr><td>cmath.<strong>tan</strong>(x)</td><td>返回x的正切值</td></tr></tbody></table><h2 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>acosh</strong>(x)</td><td>返回双曲线中x的反余弦值</td></tr><tr><td>cmath.<strong>asinh</strong>(x)</td><td>返回双曲线中x的反正弦值</td></tr><tr><td>cmath.<strong>atanh</strong>(x)</td><td>返回双曲线中x的反正切值</td></tr><tr><td>cmath.<strong>cosh</strong>(x)</td><td>返回双曲线中x的余弦值</td></tr><tr><td>cmath.<strong>sinh</strong>(x)</td><td>返回双曲线中x的正弦值</td></tr><tr><td>cmath.<strong>tanh</strong>(x)</td><td>返回双曲线中x的正切值</td></tr></tbody></table><h2 id="分类函数"><a href="#分类函数" class="headerlink" title="分类函数"></a>分类函数</h2><table><thead><tr><th>函数</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>isfinite</strong>(x)</td><td>模数r和弧度phi都是有理数，则返回True，否则返回False</td></tr><tr><td>cmath.<strong>isinf</strong>(x)</td><td>模数r和弧度phi都趋近于正无穷，则返回True，否则返回False</td></tr><tr><td>cmath.<strong>isnan</strong>(x)</td><td>模数r和弧度phi都是Nan，则返回True，否则返回False</td></tr><tr><td>cmath.<strong>isclose</strong>(a,b,*,rel_tol,abs_tol)</td><td>若a和b的值比较接近则返回True，否则返回False。判定标准是根据给定的绝对和相对容差。rel_tol是相对容差，必须大于0，是a和b之间允许的最大差值。abs_tol是最小绝对容差，至少为0</td></tr></tbody></table><h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><table><thead><tr><th>常数名</th><th>释义</th></tr></thead><tbody><tr><td>cmath.<strong>pi</strong></td><td>常数π=3.141926….</td></tr><tr><td>cmath.<strong>e</strong></td><td>常数e= 2.718281….</td></tr><tr><td>cmath.<strong>tau</strong></td><td>常数τ = 6.283185…，为π的两倍</td></tr><tr><td>cmath.<strong>inf</strong></td><td>正无穷大浮点数</td></tr><tr><td>cmath.<strong>infj</strong></td><td>实部为0，虚部为正无穷大浮点数的复数</td></tr><tr><td>cmath.<strong>nan</strong></td><td>浮点数”非数值”</td></tr><tr><td>cmath.<strong>nanj</strong></td><td>实部为0，虚部为Nan的”非数值”</td></tr></tbody></table><p><strong>cmath</strong>模块与<strong>math</strong>模块许多功能看上去相似，但实际上是不同的功能。cmath返回的值是复数，哪怕虚部为0。许多人不理解为什么单独定义一个cmath模块而不是math模块一起解决复数运算问题。假设有一天需要用特别复杂的方式去计算，就会理解这么定义的原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;cmath&lt;/strong&gt;模块为复数提供了有关数学运算函数，使得复数也能想整型或浮点型数字一样计算&lt;/p&gt;
&lt;h2 id=&quot;复数极坐标系转换函数&quot;&gt;&lt;a href=&quot;#复数极坐标系转换函数&quot; class=&quot;headerlink&quot; title=&quot;复数极坐标系
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python运算(二)math模块</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonCaculationsMathModule/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonCaculationsMathModule/</id>
    <published>2017-05-02T05:49:09.000Z</published>
    <updated>2019-05-17T11:17:34.918Z</updated>
    
    <content type="html"><![CDATA[<p><strong>math</strong>是Python自带的数学函数模块，对大多数数字类型适用，但不适用于复数，如果是复数需要使用<strong>cmath</strong>模块的同名函数，无特殊情况下，<strong>math</strong>模块中的函数返回值均为浮点数。</p><h2 id="数论与表示函数"><a href="#数论与表示函数" class="headerlink" title="数论与表示函数"></a>数论与表示函数</h2><table><thead><tr><th>函数名</th><th>释义/代码实例</th></tr></thead><tbody><tr><td>math.<strong>ceil</strong>(x)</td><td>返回大于或等于x的最小整数，如果x不是浮点数，则会委托x.<strong>ceil</strong>()返回一个Integer类的值</td></tr><tr><td>math.<strong>copysign</strong>(x,y)</td><td>返回一个基于x的绝对值和y的符号的浮点数&gt;&gt;&gt; math.copysign(2.4, -1.2)<br>-2.4</td></tr><tr><td>math.<strong>fabs</strong>(x)</td><td>返回x的绝对值</td></tr><tr><td>math.<strong>factorial</strong>(x)</td><td>返回x的阶乘，当x不是整数或者是负数时，引发ValueError异常</td></tr><tr><td>math.<strong>floor</strong>(x)</td><td>返回x的向下取整，小于或等于x的最大整数，如果x不是浮点数，则委托x.<strong>floor</strong>()返回一个Integral值</td></tr><tr><td>math.<strong>fmod</strong>(x,y)</td><td>x除以y的余数，但结果并不一定与x%y相同，x%y取余是向下取余，而fomd函数是向靠近0的方向取余，并且fmod函数精度更准确，所以fmod()函数更适合浮点数</td></tr><tr><td>math.<strong>frexp</strong>(x)</td><td>返回x的尾数和指数对(m，e),m是一个浮点数，e是一个整数，m和e要满足 <code>x== m * 2 **e</code>。 如果x为零，则返回(0.0,0)</td></tr><tr><td>math.<strong>fsum</strong>(iterable)</td><td>返回迭代中的精确浮点值，通过跟踪多个中间部分和 以此避免精度损失。该方法的准确性取决于IEEE-754算术保证和 舍入模式为半偶的典型情况，在一些非Windows版本中，底层C库使用扩展精度添加，并且有时可能会使中间和加倍，导致在最低有效位中关闭。<br>&gt;&gt;&gt; sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])<br>0.9999999999999999<br>&gt;&gt;&gt; math. fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])<br>1.0<br></td></tr><tr><td>math.<strong>gcd</strong>(a,b)</td><td>返回a和b的最大公约数，如果a或b之一非负，则函数函数的值是同时能正常a和b的最大正整数，gcd(0，0)则返回0</td></tr><tr><td>math.<strong>isclose</strong>(a,b,*,rel_tol=1e-09,abs_tol=0.0)</td><td>若a和b的值比较接近则返回True，否则返回False。判定标准是根据给定的绝对和相对容差。rel_tol是相对容差，必须大于0，是a和b之间允许的最大差值。abs_tol是最小绝对容差，至少为0</td></tr><tr><td>math.<strong>isfinite</strong>(x)</td><td>如果x是有限位数，则返回True，否则返回False</td></tr><tr><td>math.<strong>isinf</strong>(x)</td><td>如果x是正无穷或负无穷，则返回True，否则返回False</td></tr><tr><td>math.<strong>isnan</strong>(x)</td><td>如果x是NaN，则返回True，否则返回False</td></tr><tr><td>math.<strong>ldexp</strong>(x,i)</td><td>返回<code>x*(2**i)</code>, 是函数frexp()的反函数</td></tr><tr><td>math.<strong>modf</strong>(x)</td><td>返回x的小数和整数部分，两个结果都带有x的符号并且是浮点数</td></tr><tr><td>math.<strong>trunc</strong>(x)</td><td>返回x实部截断Integeral</td></tr></tbody></table><h2 id="幂函数与对数函数"><a href="#幂函数与对数函数" class="headerlink" title="幂函数与对数函数"></a>幂函数与对数函数</h2><table><thead><tr><th>函数名</th><th>释义/代码示例</th></tr></thead><tbody><tr><td>math.<strong>exp</strong>(x)</td><td>返回 e**x</td></tr><tr><td>math.<strong>expm1</strong>(x)</td><td>返回e**x - 1</td></tr><tr><td>math.<strong>log</strong>(x,base)</td><td>使用一个参数，则返回x的自然对数(底为e)。使用两个参数，返回给定的base的对数x，计算为log(x)/log(base)。</td></tr><tr><td>math.<strong>log1p</strong>(x)</td><td>返回1+x(base e)的自然对数</td></tr><tr><td>math.<strong>log2</strong>(x)</td><td>返回x以2为底的对数，比log(x,2)准确度高</td></tr><tr><td>math.<strong>log10</strong>(x)</td><td>返回x底为10的对数，比log(x,10)准确度高</td></tr><tr><td>math.<strong>pow</strong>(x,y)</td><td>返回x的y次幂</td></tr><tr><td>math.<strong>sqrt</strong>(x)</td><td>返回x的平方根</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; x = 5&gt;&gt;&gt; math.exp(x)148.4131591025766&gt;&gt;&gt; math.expm1(x)147.4131591025766&gt;&gt;&gt; math.log(x)1.6094379124341003&gt;&gt;&gt; math.log(x, 2)2.321928094887362&gt;&gt;&gt; math.log1p(x)1.791759469228055&gt;&gt;&gt; math.log2(x)2.321928094887362&gt;&gt;&gt; math.log10(x)0.6989700043360189&gt;&gt;&gt; math.pow(x, 2)25.0&gt;&gt;&gt; math.sqrt(x)2.23606797749979</code></pre><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><table><thead><tr><th>函数名</th><th>释义/代码示例</th></tr></thead><tbody><tr><td>math.<strong>acos</strong>(x)</td><td>以弧度为单位返回x的反余弦值</td></tr><tr><td>math.<strong>asin</strong>(x)</td><td>以弧度为单位返回x的反正弦值</td></tr><tr><td>math.<strong>atan</strong>(x)</td><td>以弧度为单位返回x的反正切值</td></tr><tr><td>math.<strong>atan2</strong>(y,x)</td><td>以弧度为单位返回athan(y/x)，结果在-pi和pi之间，可以计算角度的正确象限</td></tr><tr><td>math.<strong>cos</strong>(x)</td><td>返回x弧度的余弦值</td></tr><tr><td>math.<strong>hypot</strong>(x,y)</td><td>返回欧几里德范数，sqrt(x<em>x + y\</em>y),是原点到点(x，y)的向量距离</td></tr><tr><td>math.<strong>sin</strong>(x)</td><td>返回x弧度的正弦值</td></tr><tr><td>math.<strong>tan</strong>(x)</td><td>返回x弧度的正切值</td></tr></tbody></table><p>注意： x的取值若超出范围，否则会报<code>ValueError: math domain error</code></p><pre><code class="python">&gt;&gt;&gt; math.acos(2.3)Traceback (most recent call last):  File &quot;&lt;pyshell#26&gt;&quot;, line 1, in &lt;module&gt;    math.acos(2.3)ValueError: math domain error&gt;&gt;&gt; math.acos(0.5)1.0471975511965976&gt;&gt;&gt; math.asin(0.5)0.5235987755982988&gt;&gt;&gt; math.atan(0.5)0.46364760900080615&gt;&gt;&gt; math.atan2(0.5,0.5)0.7853981633974483&gt;&gt;&gt; math.cos(0.5)0.8775825618903728&gt;&gt;&gt; math.hypot(0.5,0.5)0.7071067811865476&gt;&gt;&gt; math.sin(0.5)0.479425538604203&gt;&gt;&gt; math.tan(0.5)0.5463024898437905&gt;&gt;&gt; math.tan(1)1.557407724654902&gt;&gt;&gt; math.tan(1.4)5.797883715482887&gt;&gt;&gt; math.tan(2)-2.185039863261519&gt;&gt;&gt; math.tan(2.5)-0.7470222972386602</code></pre><h2 id="角度转换"><a href="#角度转换" class="headerlink" title="角度转换"></a>角度转换</h2><table><thead><tr><th>函数名</th><th>释义</th></tr></thead><tbody><tr><td>math.<strong>degrees</strong>(x)</td><td>将角度x从弧度转换为度数</td></tr><tr><td>math.<strong>radians</strong>(x)</td><td>将角度x从度数转换为弧度</td></tr></tbody></table><h2 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h2><p>双曲函数是基于双曲线而非圆来对三角函数进行模拟</p><table><thead><tr><th>函数名</th><th>释义</th></tr></thead><tbody><tr><td>math.<strong>acosh</strong>(x)</td><td>返回x的反双曲余弦值</td></tr><tr><td>math.<strong>asinh</strong>(x)</td><td>返回x的反双曲正弦值</td></tr><tr><td>math.<strong>atanh</strong>(x)</td><td>返回x的反双曲正切值</td></tr><tr><td>math.<strong>cosh</strong>(x)</td><td>返回x的双曲余弦值</td></tr><tr><td>math.<strong>sinh</strong>(x)</td><td>返回x的双曲正弦值</td></tr><tr><td>math.<strong>tanh</strong>(x)</td><td>返回x的双曲正切值</td></tr></tbody></table><h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><table><thead><tr><th>函数名</th><th>释义</th></tr></thead><tbody><tr><td>math.<strong>erf</strong>(x)</td><td>用来计算传统的统计函数，如累积标准正态分布</td></tr><tr><td>math.<strong>erfc</strong>(x)</td><td>返回x的互补误差函数，<a href="https://en.wikipedia.org/wiki/Error_function">互补错误函数</a> 定义为 <code>1.0 - erf(x)</code></td></tr><tr><td>math.<strong>gamma</strong>(x)</td><td>返回x的伽马函数值</td></tr><tr><td>math.<strong>lgamma</strong>(x)</td><td>返回Gamma函数x绝对值的自然对数</td></tr></tbody></table><h2 id="math模块中的常数"><a href="#math模块中的常数" class="headerlink" title="math模块中的常数"></a>math模块中的常数</h2><table><thead><tr><th>常数</th><th>释义</th></tr></thead><tbody><tr><td>math.<strong>pi</strong></td><td>数学常数π=3.1415926…</td></tr><tr><td>math.<strong>e</strong></td><td>数学常数e= 2.718281….</td></tr><tr><td>math.<strong>tau</strong></td><td>数学常数τ = 6.283185…</td></tr><tr><td>math.<strong>inf</strong></td><td>正无穷大浮点数，负无穷大浮点数使用-math.<strong>inf</strong></td></tr><tr><td>math.<strong>nan</strong></td><td>浮点”非数字”值</td></tr></tbody></table><p>math模块是数学函数的包装模块，若使用不符合数学规范，则会触发<a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#ValueError"><code>ValueError</code></a> </p><p>参考文献：</p><p>1.<a href="https://docs.python.org/English/3.6/library/math.html#math.fmod">https://docs.python.org/English/3.6/library/math.html#math.fmod</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;math&lt;/strong&gt;是Python自带的数学函数模块，对大多数数字类型适用，但不适用于复数，如果是复数需要使用&lt;strong&gt;cmath&lt;/strong&gt;模块的同名函数，无特殊情况下，&lt;strong&gt;math&lt;/strong&gt;模块中的函数返回值均为浮点
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数字运算(-)数值、哈希、按位、布尔等运算</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculations/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculations/</id>
    <published>2017-05-01T12:34:35.000Z</published>
    <updated>2019-05-17T11:17:26.047Z</updated>
    
    <content type="html"><![CDATA[<p>所有的类型都可以被比较、检测逻辑值、转换字符串，所有的数据类型都可进行数学运算。</p><h2 id="逻辑值检测"><a href="#逻辑值检测" class="headerlink" title="逻辑值检测"></a>逻辑值检测</h2><p>任何数据类型或对象皆可进行逻辑值检测，默认情况下均被视为真值，除非对象或所属类重定义了<strong>bool</strong>()方法且返回<code>False</code> 或者是对象定义了<strong>len</strong>()方法且返回零。</p><p>以下是在逻辑检测时被视为假值的对象:</p><p>.被定义为假值的常量：<code>None 和 False</code></p><p>.任何数值类型的零：<code>0，0.0，0j,Decimal(0),Fraction(0,1)</code></p><p>.空的序列和多项集：<code>&#39;&#39;，()，{}，set(),range(0)</code></p><h2 id="Bool运算"><a href="#Bool运算" class="headerlink" title="Bool运算"></a>Bool运算</h2><p>Bool运算包括 <code>and、or、not</code>，按照优先级排列not &gt; and &gt; or</p><table><thead><tr><th>运算</th><th>结果</th><th>注释</th></tr></thead><tbody><tr><td>x or y</td><td>如果x为false，那么返回y，否则返回x</td><td>or为短路运算符，只有在第一个参数为假值时才会对第二个参数求值</td></tr><tr><td>x and y</td><td>如果x为false，那么返回x，否则返回y</td><td>and同样是短路运算符，只有在第一个参数为真值时才会对第二个参数求值</td></tr><tr><td>not x</td><td>如果x为false，那么返回True，否则返回False</td><td>优先级比非布尔运算符低，因此 <code>not a == b</code>会被解读为<code>not (a==b)</code>，而<code>a == not b</code>会造成语法错误</td></tr></tbody></table><h2 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h2><p>Python中有八种比较运算符，优先级相同，但都比布尔运算优先级高，并且比较运算符可以任意串联。例如，<code>x&lt;y&lt;=z</code>等价于 <code>x&lt; y and y &lt;=z</code>,不同之处是前者y只被求值一次，后者会被求值两次，相同点是在x&lt;y结果为假时z都不会被求值。</p><p>八种比较运算符如下：</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>&lt;</strong></td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center"><strong>&lt;=</strong></td><td style="text-align:center">小于或等于</td></tr><tr><td style="text-align:center"><strong>&gt;</strong></td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center"><strong>&gt;=</strong></td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center"><strong>==</strong></td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center"><strong>!=</strong></td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center"><strong>is</strong></td><td style="text-align:center">对象标识</td></tr><tr><td style="text-align:center"><strong>is not</strong></td><td style="text-align:center">否定的对象标识</td></tr></tbody></table><h3 id="比较运算注意点"><a href="#比较运算注意点" class="headerlink" title="比较运算注意点"></a>比较运算注意点</h3><p>. 不同数字、不同类型对象比较时绝不会相等</p><p>. 函数类型仅支持简化形式比较</p><p>. &lt;,&lt;=,&gt;,&gt;= 运算符在比较复数和其它数字类型时，或在两个对象具有无法被比较的不同类型时，或在未定义次序的其他情况时，以上皆会产生<code>TypeErroe</code>异常</p><p>. 不同标识类的实例比较，除非定义了<strong>eq</strong>()方法，否则不相等</p><p>. 类实例不能与相同类或其他实例或其它类型对象进行排序，除非定义了 <strong>it</strong>(),<strong>le</strong>(),<strong>gt</strong>(),<strong>ge</strong>()这些函数</p><p>. <code>is</code> 和 <code>is not</code>无法自定义，可以被应用于任意两个对象不引发异常。</p><p>.<code>in</code> 和 <code>not in</code> ，与上面八种比较运算符具有相同优先级，但只能支持<strong>iterable(可迭代对象)</strong>或实现了<strong>contains</strong>()方法的类型</p><h2 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h2><p>所有的数字类型，除了复数类型，都支持下面的运算操作，所有数字运算的优先级都高于比较运算，以下按照<strong>优先级升序排列</strong>：</p><table><thead><tr><th style="text-align:center">运算</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>+</strong></td><td>两数之和</td></tr><tr><td style="text-align:center"><strong>-</strong></td><td>两数之差</td></tr><tr><td style="text-align:center">$ \times $</td><td>两数乘积</td></tr><tr><td style="text-align:center"><strong>/</strong></td><td>两数相除，结果返回商</td></tr><tr><td style="text-align:center"><strong>//</strong></td><td>两数整除，结果返回商数</td></tr><tr><td style="text-align:center"><strong>%</strong></td><td>两数相除结果取余数</td></tr><tr><td style="text-align:center"><strong>-x</strong></td><td>x取反</td></tr><tr><td style="text-align:center"><strong>+x</strong></td><td>x取正</td></tr><tr><td style="text-align:center"><strong>abs(x)</strong></td><td>x的绝对值</td></tr><tr><td style="text-align:center"><strong>int(x)</strong></td><td>将x转换为整数</td></tr><tr><td style="text-align:center"><strong>float(x)</strong></td><td>将x转换为浮点数</td></tr><tr><td style="text-align:center"><strong>complex(re,im)</strong></td><td>一个带有实部re和虚部im的复数，im默认为0</td></tr><tr><td style="text-align:center"><strong>c.conjugate()</strong></td><td>复数c的共轭</td></tr><tr><td style="text-align:center"><strong>divmod(x,y)</strong></td><td>执行x//y x%y ，得到x被y除之后的商和余数</td></tr><tr><td style="text-align:center"><strong>pow(x,y)</strong></td><td>x的y次幂</td></tr><tr><td style="text-align:center">x **y</td><td>同样表示x的y次幂</td></tr><tr><td style="text-align:center">invmod(x,y)</td><td>对x模y取反</td></tr></tbody></table><h3 id="数字运算注意点："><a href="#数字运算注意点：" class="headerlink" title="数字运算注意点："></a>数字运算注意点：</h3><p>. / 除法运算返回的永远是一个浮点数</p><p>.// 整除结果值是一个整数，但结果的类型不一定是int。 运算结果永远向负无穷方向舍入， 1//2 为0, (-1)//2 为-1，1//(-2)为-1,(-1)//(-2)为0。</p><p>. % 不能用于复数</p><p>. int() 若从浮点数转换为整数会被舍入或被截断，原因在前面文章数字类型中提到过，因为二进制浮点数问题</p><p>数字类型还能进行数学函数运算，具体会在后面math和cmath模块讲到。</p><h2 id="整数类型按位运算"><a href="#整数类型按位运算" class="headerlink" title="整数类型按位运算"></a>整数类型按位运算</h2><p>按位运算只对整数有意义，按位运算优先级低于数字运算，高于比较运算，但一元运算<code>~</code>与其它一元算术运算符优先级相同。</p><table><thead><tr><th>运算</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>x\</td><td>y</td><td>x和y按位或</td><td></td></tr><tr><td>x^y</td><td>x和y按位异或</td><td></td></tr><tr><td>x&amp;y</td><td>x和y按位与</td><td></td></tr><tr><td>x&lt;&lt;n</td><td>x左移n位</td><td>负的移位会引发ValueError，左移n位等价于不带溢出检测的乘以pow(2,n)</td></tr><tr><td>x&gt;&gt;n</td><td>x右移n位</td><td>负的移位同样会引发ValueErroe，右移n位等价于不带溢出检测的除以pow(2,n)</td></tr><tr><td>~x</td><td>x按位取反</td></tr></tbody></table><h2 id="数字类型的哈希运算"><a href="#数字类型的哈希运算" class="headerlink" title="数字类型的哈希运算"></a>数字类型的哈希运算</h2><p><strong>不同数字类型的两个数，要做== 比较运算时，必须转成哈希值，即hash(x)==hash(y)</strong>。为便于在各种数字类型上实现并保证效率，Python对数字类型的哈希运算是基于任意有理数定义统一的数学函数，本质上hash()是通过以一个固定质数P进行P降模。P的值在 Python 中可以 <a href="https://docs.python.org/zh-cn/3.6/library/sys.html#sys.hash_info"><code>sys.hash_info</code></a> 的 <code>modulus</code> 属性的形式被访问。</p><p>CPython implementation detail: 所用质数设定，在 C long 为 32 位的机器上 <code>P = 2**31 - 1</code> 而在 C long 为 64 位的机器上 <code>P = 2**61 - 1</code></p><p>运算规则如下：</p><ul><li>如果 <code>x = m / n</code> 是一个非负比例数，且 <code>n</code> 不能被 <code>P</code> 整除，则定义 <code>hash(x)</code> 为 <code>m * invmod(n, P) % P</code>。</li><li>如果 <code>x = m / n</code> 是一个非负比例数，且 <code>n</code> 能被 <code>P</code> 整除（但 <code>m</code> 不能）则 <code>n</code> 不能对 <code>P</code> 降模，以上规则不适用；在此情况下则定义 <code>hash(x)</code> 为常数值 <code>sys.hash_info.inf</code>。</li><li>如果 <code>x = m / n</code> 是一个负比例数，则定义 <code>hash(x)</code> 为 <code>-hash(-x)</code>。 如果结果哈希值为 <code>-1</code> 则将其替换为 <code>-2</code>。</li><li>特定值 <code>sys.hash_info.inf</code>, <code>-sys.hash_info.inf</code> 和 <code>sys.hash_info.nan</code> 被用作正无穷、负无穷和空值（所分别对应的）哈希值。 （所有可哈希的空值都具有相同的哈希值）</li><li>对于一个 <a href="https://docs.python.org/zh-cn/3.6/library/functions.html#complex"><code>complex</code></a> 值 <code>z</code>，会通过计算 <code>hash(z.real) + sys.hash_info.imag * hash(z.imag)</code> 将实部和虚部的哈希值结合起来，并进行降模 <code>2**sys.hash_info.width</code> 以使其处于 <code>range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))</code> 范围之内。 同样地，如果结果为 <code>-1</code> 则将其替换为 <code>-2</code></li></ul><p>为了更好的理解运算规则，用代码实现如下:</p><p>对分数求哈希值：</p><pre><code class="python">&gt;&gt;&gt; import sys,math&gt;&gt;&gt; def hash_fraction(m,n):    &#39;&#39;&#39;计算比例数m/n的哈希值，m和n为整数，n为正数&#39;&#39;&#39;    P = sys.hash_info.modulus    #去掉P的公因数，除非m和n互质    while m%P == n%P ==0:        m,n = m//P, n//P    #如果n能被P整除，hash值为固定值    if n % P == 0:        hash_value = sys.hash_info.inf    else:        #如果n不能被P整除，则对P进行降模处理        hash_value = (abs(m)%P)*pow(n,P-2,P)%P    #判断m是否是负数，对负数求hash    if m &lt; 0:        hash_value = -hash_value    if hash_value == -1:        hash_value = -2    return hash_value</code></pre><p>对float浮点数类型求哈希值：</p><pre><code class="python">&gt;&gt;&gt; def hash_float(x):    #计算浮点数x的哈希值    if math.isnan(x):        return sys.hash_info.nan    elif math.isinf(x):        return sys.hash_info.inf if x &gt; 0 else -sys.hash_info.inf    else:        return hash_fraction(*x.as_integer_ratio())</code></pre><p>对复数类型求哈希值：</p><pre><code class="python">#计算复数z的哈希值    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)    M = 2 **(sys.hash_info.width - 1)    hash_value = (hash_value &amp; (M-1)) - (hash_value&amp;M)    if hash_value == -1:        hash_value = -2    return hash_value</code></pre><h2 id="Decimal运算实例"><a href="#Decimal运算实例" class="headerlink" title="Decimal运算实例"></a>Decimal运算实例</h2><p>Decimal 进行  $+ 、- 、\times 、/$  运算</p><pre><code class="python">&gt;&gt;&gt; data = list(map(Decimal, &#39;1.34 1.87 3.45 2.35 1.00 0.03 9.25&#39;.split()))&gt;&gt;&gt; sum (data)Decimal(&#39;19.29&#39;)&gt;&gt;&gt; min(data)Decimal(&#39;0.03&#39;)&gt;&gt;&gt; max(data)Decimal(&#39;9.25&#39;)&gt;&gt;&gt; min(data)Decimal(&#39;0.03&#39;)&gt;&gt;&gt; a,b,c = data[:3]&gt;&gt;&gt; a * 5Decimal(&#39;6.70&#39;)&gt;&gt;&gt; a * bDecimal(&#39;2.5058&#39;)&gt;&gt;&gt; c % aDecimal(&#39;0.77&#39;)&gt;&gt;&gt; a + b + cDecimal(&#39;6.66&#39;)&gt;&gt;&gt; a - bDecimal(&#39;-0.53&#39;)&gt;&gt;&gt; </code></pre><p>当余数运算%应用于Decimal对象时，结果的符号是被除数的符号，而不是除数的符号</p><pre><code class="python">&gt;&gt;&gt; -5 % 83&gt;&gt;&gt; Decimal(-5) % Decimal(8)Decimal(&#39;-5&#39;)&gt;&gt;&gt; Decimal(8) % Decimal(-5)Decimal(&#39;3&#39;)</code></pre><p>同样Decimal也可以进行一些数学函数运算</p><pre><code class="python">&gt;&gt;&gt; Decimal(2).sqrt()Decimal(&#39;1.41421&#39;)&gt;&gt;&gt; Decimal(1).exp()Decimal(&#39;2.71828&#39;)&gt;&gt;&gt; Decimal(10).ln&lt;built-in method ln of decimal.Decimal object at 0x1073b04a8&gt;&gt;&gt;&gt; Decimal(10).ln()Decimal(&#39;2.30259&#39;)&gt;&gt;&gt; Decimal(&#39;10&#39;).log10()Decimal(&#39;1&#39;)</code></pre><p>关于四舍五入，Decimal的quantize()方法可以将数字四舍五入为固定函数</p><pre><code class="python">&gt;&gt;&gt; Decimal(&#39;7.325&#39;).quantize(Decimal(&#39;0.01&#39;), rounding=ROUND_DOWN)Decimal(&#39;7.32&#39;)&gt;&gt;&gt; Decimal(&#39;7.325&#39;).quantize(Decimal(&#39;1.&#39;), rounding=ROUND_UP)Decimal(&#39;8&#39;)</code></pre><h2 id="Fraction运算实例"><a href="#Fraction运算实例" class="headerlink" title="Fraction运算实例"></a>Fraction运算实例</h2><p>Fraction同样可以进行$+、-、\times /$   四则运算和%运算等</p><pre><code class="python">&gt;&gt;&gt; from fractions import Fraction&gt;&gt;&gt; import math&gt;&gt;&gt; Fraction(2,3) + Fraction(3,5)Fraction(19, 15)&gt;&gt;&gt; Fraction(2,3) - Fraction(3,5)Fraction(1, 15)&gt;&gt;&gt; Fraction(2,3) * Fraction(3,5)Fraction(2, 5)&gt;&gt;&gt; Fraction(2,3) / Fraction(3,5)Fraction(10, 9)&gt;&gt;&gt; Fraction(2,3) % Fraction(-3, 5)Fraction(-8, 15)&gt;&gt;&gt; Fraction(2,3) % Fraction(3,5)Fraction(1, 15)</code></pre><p>Fraction没有sqrt()、exp()等函数方法。</p><p>参考文献：</p><p>1.<a href="https://docs.python.org/zh-cn/3.6/contents.html">https://docs.python.org/zh-cn/3.6/contents.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所有的类型都可以被比较、检测逻辑值、转换字符串，所有的数据类型都可进行数学运算。&lt;/p&gt;
&lt;h2 id=&quot;逻辑值检测&quot;&gt;&lt;a href=&quot;#逻辑值检测&quot; class=&quot;headerlink&quot; title=&quot;逻辑值检测&quot;&gt;&lt;/a&gt;逻辑值检测&lt;/h2&gt;&lt;p&gt;任何数据类型或对象皆
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数据类型(一)数字类型</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/PythonBasicDataTypeNumber/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/PythonBasicDataTypeNumber/</id>
    <published>2017-05-01T07:23:14.000Z</published>
    <updated>2019-05-17T11:17:09.883Z</updated>
    
    <content type="html"><![CDATA[<p>Python3有六个标准数据类型：</p><p>.不可变数据类型：<strong>Number(数字)、String(字符串)、Tuple(元组)</strong></p><p>.可变数据类型： <strong>List(列表)、Dictionary(字典)、Set(集合)</strong></p><p>在每种基本数据类型下会有其它一些衍生类型。以上六种是基本的数据类型，除基本数据类型外，其它数据类型有：<strong>Datetime(时间)、Calendar(日历)、Collection(容器)、enum(枚举)</strong>等。</p><p>该篇讲述<strong>Number</strong>(数字)的各种类型、衍生类型<strong>Decimal</strong>类型和<strong>Fractions</strong>类型的适用情况以及针对数据类型的运算规则。</p><p><strong>Number</strong>：</p><p>Python3 支持<strong>int、float、bool、complext、Decimal、Fraction</strong> 等数值类型，数值类型可以直接进行<code>+、-、*、/</code>运算，<code>()</code>用于分组。内置函数<code>type()</code>和<code>isinstance()</code>可以查看变量所指的对象类型，<strong>适用于所有的数据类型</strong>,两者的区别是<code>type()</code>不认为子类是父类类型  <code>isinstance()</code>认为子类是父类类型。</p><h2 id="int-整数"><a href="#int-整数" class="headerlink" title="int(整数)"></a>int(整数)</h2><p>整数(例如<code>4，5，6</code>)类型为<strong>int</strong> 类型，Python3之后只有一种整数类型int，表示长整型，不再有之前的<strong>long</strong>类型。在Python2中用数字0表示<code>False</code>，用数字1表示<code>True</code>，但是Python3 中直接把<code>True</code>和<code>False</code>定义为关键字，其值还是表示0和1。布尔值属于整数的子类型，整数具有无限的精度。</p><pre><code class="python">&gt;&gt;&gt; a = 1; b=2&gt;&gt;&gt; isinstance(a, int)True&gt;&gt;&gt; type(b)&lt;class &#39;int&#39;&gt; #以上两个函数同样适用于其它Number类型以及String等</code></pre><h3 id="整数类型附加方法"><a href="#整数类型附加方法" class="headerlink" title="整数类型附加方法"></a>整数类型附加方法</h3><p>int 类型实现了<a href="https://docs.python.org/zh-cn/3.6/library/numbers.html#numbers.Integral"><code>numbers.Integral</code></a> <a href="https://docs.python.org/zh-cn/3.6/glossary.html#term-abstract-base-class">abstract base class</a>，也提供了其他方法</p><h4 id="bit-length"><a href="#bit-length" class="headerlink" title="bit_length()"></a>bit_length()</h4><p><code>int.bit_length()</code>返回以二进制表示一个整数所需要的位数，不包括符号位和前面的零</p><pre><code class="python">&gt;&gt;&gt; a = -13&gt;&gt;&gt;#转换成二进制&gt;&gt;&gt; bin(a)&#39;-0b1101&#39;&gt;&gt;&gt; a.bit_length()4</code></pre><p>如果a的值为0，则<code>bit_length(</code>)函数返回0，如果a的值不为0，则<code>bit_length()</code>是使得<code>2**(k-1) &lt;= abs(x)&lt; 2 **k</code>的 唯一正整数k,同样abs(a)小到足以具有正确的舍入对数时，则<code>k = 1 + int(log(abs(x),2))</code>。</p><p>等价于：</p><pre><code class="python">&gt;&gt;&gt; def bit_length(self):    s = bin(self)   #将整数转换为二进制    s = s.lstrip(&#39;-0b&#39;) #将二进制的前缀去掉    return len(s)   #返回二进制位的长度</code></pre><h4 id="to-bytes"><a href="#to-bytes" class="headerlink" title="to_bytes()"></a>to_bytes()</h4><p>int.<strong>to_bytes</strong>(length, byteorder, *,signed=False)返回一个整数的字节数组，是Python3.1新增加的功能</p><p>参数含义：</p><p>length: 整数字节数，如果不能用给定的字节数来表示则会引发OverflowError</p><p>byteorder:  确定用于表示整数的字节顺序，byteorder为’big’表示最高位字节放在字节位开头。byteorder为’little’表示最高位字节放在字节数组的末尾。</p><p>signed: 是否使用二进制补码来表示整数，如果signed为False并且给出的是负整数，则会引发<a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#OverflowError"><code>OverflowError</code></a>。默认值为False</p><pre><code class="python">&gt;&gt;&gt; a = 1024&gt;&gt;&gt; a.to_bytes(2, byteorder=&#39;big&#39;)b&#39;\x04\x00&#39;&gt;&gt;&gt; a.to_bytes(10, byteorder=&#39;big&#39;)b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00&#39;&gt;&gt;&gt; a.to_bytes(10, byteorder=&#39;big&#39;, signed=True)b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00&#39;&gt;&gt;&gt; b = -1024&gt;&gt;&gt; b.to_bytes(10, byteorder=&#39;big&#39;, signed=True)b&#39;\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00&#39;&gt;&gt;&gt; c = 1000&gt;&gt;&gt; c.to_bytes((c.bit_length()+7)//8, byteorder=&#39;little&#39;)b&#39;\xe8\x03&#39;</code></pre><h4 id="from-bytes"><a href="#from-bytes" class="headerlink" title="from_bytes()"></a>from_bytes()</h4><p>int.from_bytes(bytes, byteorder, *, signed=False) 返回给定字节数组表示的整数，是Python3.2增加的功能。</p><p>参数含义:</p><p>bytes: 必须是一个<a href="https://docs.python.org/zh-cn/3.6/glossary.html#term-bytes-like-object">bytes-like object</a> 或是生成字节的可迭代对象</p><p>byteorder： 表示整数的字节顺序，如果 <em>byteorder</em> 为 <code>&quot;big&quot;</code>，则最高位字节放在字节数组的开头。 如果 <em>byteorder</em> 为 <code>&quot;little&quot;</code>，则最高位字节放在字节数组的末尾</p><p>signed：是否使用二进制补码表示</p><pre><code class="python">&gt;&gt;&gt; int.from_bytes(b&#39;\x04\x00&#39;,byteorder=&#39;big&#39;)1024&gt;&gt;&gt; int.from_bytes(b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00&#39;, byteorder=&#39;big&#39;)1024&gt;&gt;&gt; int.from_bytes(b&#39;\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00&#39;, byteorder=&#39;big&#39;,signed=True)-1024</code></pre><h2 id="float（浮点数）"><a href="#float（浮点数）" class="headerlink" title="float（浮点数）"></a>float（浮点数）</h2><p>带小数部分的数字（如：<code>4.5，6.78</code>）是<strong>float类型</strong>。<code>float()</code>函数可以将数字转换为<strong>float类型</strong>。浮点数通常使用C中的double来实现，浮点数精度和内部表示可以查看<a href="https://docs.python.org/zh-cn/3.6/library/sys.html#sys.float_info"><code>sys.float_info</code></a></p><pre><code class="python">&gt;&gt;&gt; float(8)8.0</code></pre><h3 id="浮点数类型附加方法"><a href="#浮点数类型附加方法" class="headerlink" title="浮点数类型附加方法"></a>浮点数类型附加方法</h3><p>float 类型实现了 <a href="https://docs.python.org/zh-cn/3.6/library/numbers.html#numbers.Real"><code>numbers.Real</code></a> <a href="https://docs.python.org/zh-cn/3.6/glossary.html#term-abstract-base-class">abstract base class</a>。 float 具有以下附加方法。</p><h4 id="as-integer-ratio"><a href="#as-integer-ratio" class="headerlink" title="as_integer_ratio()"></a>as_integer_ratio()</h4><p>float.as_integer_ratio() 返回一对整数，其比率证照等于原浮点数并且分母为整数，如果是无穷大会引发 <a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#OverflowError"><code>OverflowError</code></a> 而 NaN 则会引发 <a href="https://docs.python.org/zh-cn/3.6/library/exceptions.html#ValueError"><code>ValueError</code></a></p><pre><code class="py">&gt;&gt;&gt; 2.5.as_integer_ratio()(5, 2)</code></pre><h4 id="is-integer"><a href="#is-integer" class="headerlink" title="is_integer()"></a>is_integer()</h4><p>float.is_integer() 如果float实例可以用有限位整数表示则返回<code>True</code>，否则返回<code>False</code></p><pre><code class="py">&gt;&gt;&gt; 2.0.is_integer()True&gt;&gt;&gt; 3.3.is_integer()False</code></pre><p><strong>注意点</strong>：</p><p>以上两个方法都支持与十六进制数、字符串之间转换。由于 Python 浮点数在内部存储为二进制数，因此浮点数与 <em>十进制数</em> 字符串之间的转换往往会导致微小的舍入错误。 而十六进制数字符串却允许精确地表示和描述浮点数。 这在进行调试和数值工作时非常有用。</p><h4 id="hex"><a href="#hex" class="headerlink" title="hex()"></a>hex()</h4><p><code>float.hex()</code> 以十六进制字符串的形式返回一个浮点数，如果是有限浮点数，这种表示法将包含前导的 <code>0x</code> 和尾随的 <code>p</code> 加指数，此方法是<strong>实例方法</strong></p><pre><code class="python">&gt;&gt;&gt; 4.7.hex()&#39;0x1.2cccccccccccdp+2&#39;&gt;&gt;&gt; 3.3.hex()&#39;0x1.a666666666666p+1&#39;</code></pre><h4 id="fromhex"><a href="#fromhex" class="headerlink" title="fromhex()"></a>fromhex()</h4><p><code>float.fromhex()</code>是<strong>类方法</strong>，返回以十六进制字符串 <em>s</em> 表示的浮点数的类方法，返回的字符串可以带有前导和尾随的空格</p><pre><code class="python">&gt;&gt;&gt; float.fromhex(&#39;0x1.a666666666666p+1&#39;)3.3&gt;&gt;&gt; float.fromhex(&#39;0x1.2cccccccccccdp+2&#39;)4.7</code></pre><h2 id="complex（复数）"><a href="#complex（复数）" class="headerlink" title="complex（复数）"></a>complex（复数）</h2><p>complext由实部re和虚部im构成，实部和虚部都是浮点类型，使用后缀j和J表示虚数部分，表示为a+bj，函数<code>complex(re,im)</code>同样可以构造复数。</p><pre><code class="python">&gt;&gt;&gt; complex(4.5, 1.2)(4.5+1.2j)</code></pre><h3 id="复数极坐标"><a href="#复数极坐标" class="headerlink" title="复数极坐标"></a>复数极坐标</h3><p>Python中复数本质上实现是一个长方形坐标系或由笛卡尔坐标系存储。它被定义为实部和虚部：</p><p><code>z=z.real + z.imag*1j</code></p><p>极坐标系 提供了可供选择的表达复数的方式，在极坐标系中复数z被定义为是由模数<em>r</em>和位项角<em>phi</em>构成。模数<em>r</em>是由z到原点的距离，位项角<em>phi</em>是正x轴到原点与z轴连接线段按弧度计算的逆时针角度。</p><pre><code class="python">The modulus r is the distance from z to the origin, while the phase phi is the counterclockwise angle, measured in radians, from the positive x-axis to the line segment that joins the origin to z</code></pre><p>有关于复数极坐标的转换函数可以查看：<a href="https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculationsCmathModule/">Python运算(三)cmath模块</a></p><h2 id="Decimal-十进制定点和浮点数"><a href="#Decimal-十进制定点和浮点数" class="headerlink" title="Decimal(十进制定点和浮点数)"></a>Decimal(十进制定点和浮点数)</h2><p>Decimal能够快速正确舍入十进制，为十进制浮点运算提供支持。Decimal是基于浮点模型，方便十进制浮点数科学运算，并且提高来精确性。Decimal保留尾数零，如<code>1.30 + 1.70 = 3.00</code>, <code>1.20 *1.40 =1.6800</code> ;</p><p>具有严格相等不变量的会计或金融程序中，会优先选择Decimal类型，举例来说，<code>1.0-1.0</code> 结果恰好为0，但是在二进制数值中结果为<code>5.5511151231257827e-017</code>，虽然无限接近于0，但是仍然存在误差，若用Decimal则不会存在这样的误差，其结果为0；Decimal作为十进制的浮点数可以设置精度(默认为28个精度)</p><p>Decimal由<strong>十进制数</strong>、<strong>信号</strong>、和<strong>算数上下文</strong>组成。</p><h3 id="Decimal构成——十进制数"><a href="#Decimal构成——十进制数" class="headerlink" title="Decimal构成——十进制数"></a>Decimal构成——十进制数</h3><p>值的注意的是Decimal中的十进制数与整型的十进制数并不完全相同，Decimal中的十进制数由符号、系数数字和指数构成，系数数字不截断尾数零，并且十进制数包括特殊字符(如：<code>Infinity</code>、<code>-Infinity</code>以及<code>NaN</code>)，并且还区分<code>-0</code> 和 <code>+ 0</code>即代表同样都是0但是<code>-0</code> 和<code>+0</code> 在Decimal中是两个不同的数字。</p><p>如：利用整数、字符串、浮点或元组(这些类型后面会讲到)构造十进制实例，<strong>NaN 在这里并不代表空值，而是代表”非数字”</strong>。</p><pre><code class="python">&gt;&gt;&gt; getcontext().prec = 6&gt;&gt;&gt; Decimal(10)Decimal(&#39;10&#39;)&gt;&gt;&gt; Decimal(&#39;3.1415&#39;)Decimal(&#39;3.1415&#39;)&gt;&gt;&gt; Decimal(3.14)Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)&gt;&gt;&gt; Decimal((0,(3,1,4),-2))Decimal(&#39;3.14&#39;)&gt;&gt;&gt; Decimal(str(2.0**0.5))Decimal(&#39;1.4142135623730951&#39;)&gt;&gt;&gt; Decimal(2) ** Decimal(&#39;0.5&#39;)Decimal(&#39;1.41421&#39;)&gt;&gt;&gt; Decimal(&#39;NaN&#39;)Decimal(&#39;NaN&#39;)&gt;&gt;&gt; Decimal(&#39;-Infinity&#39;)Decimal(&#39;-Infinity&#39;)</code></pre><p>若Decimal(value)中并没有给value赋值，则会返回<code>Decimal(&#39;0&#39;)</code>。</p><p>如果value是tuple，则有三个组件，一个符号、一个数字的tuple、和整数指数，如上面的代码<code>Decimal((0,(3,1,4),-2))</code> ，返回<code>Decimal(&#39;3.14&#39;)</code></p><p>如果value是float，则二进制浮点值无损地转换为其精确的十进制等效值。该转换通常需要50位精度或更高位数的精度转换，例如上面代码中<code>Decimal(3.14)</code>转换为<code>Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)</code></p><h3 id="Decimal构成——信号"><a href="#Decimal构成——信号" class="headerlink" title="Decimal构成——信号"></a>Decimal构成——信号</h3><p>信号是计算过程中出现的异常条件。根据程序需要，信号有时会被忽略，有时被视为信息，也有可能被视为异常。每个信号，由一个标志和一个陷阱启动器构成，遇到信号时，其标志设置为 1 ，若陷阱启用器设置为 1 ，则引发异常，并且用户需要在监控计算之前重置标志。信号有<a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Clamped"><code>Clamped</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.InvalidOperation"><code>InvalidOperation</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.DivisionByZero"><code>DivisionByZero</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Inexact"><code>Inexact</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Rounded"><code>Rounded</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Subnormal"><code>Subnormal</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Overflow"><code>Overflow</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.Underflow"><code>Underflow</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.FloatOperation"><code>FloatOperation</code></a>。</p><p>若FloatOperation信号被捕获，若使用浮点数进行构造Decimal或者浮点数做排序和比较运算，则会抛出异常,但等于比较不会引发异常。</p><pre><code class="python">&gt;&gt;&gt; context = getcontext()&gt;&gt;&gt; context.traps[FloatOperation] = True&gt;&gt;&gt; Decimal(3.14)Traceback (most recent call last):  File &quot;&lt;pyshell#23&gt;&quot;, line 1, in &lt;module&gt;    Decimal(3.14)decimal.FloatOperation: [&lt;class &#39;decimal.FloatOperation&#39;&gt;]&gt;&gt;&gt; Decimal(&#39;3.4&#39;) &lt; 3.5Traceback (most recent call last):  File &quot;&lt;pyshell#24&gt;&quot;, line 1, in &lt;module&gt;    Decimal(&#39;3.4&#39;) &lt; 3.5decimal.FloatOperation: [&lt;class &#39;decimal.FloatOperation&#39;&gt;]&gt;&gt;&gt; Decimal(&#39;3.5&#39;)==3.5True</code></pre><h3 id="Decimal构成——算术上下文"><a href="#Decimal构成——算术上下文" class="headerlink" title="Decimal构成——算术上下文"></a>Decimal构成——算术上下文</h3><p>算术上下文是指精度、舍入规则、指数限制、指示操作结果的标志以及信号被视为异常的陷阱启动器的环境。</p><p>舍入选项包括 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_CEILING"><code>ROUND_CEILING</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_DOWN"><code>ROUND_DOWN</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_FLOOR"><code>ROUND_FLOOR</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_HALF_DOWN"><code>ROUND_HALF_DOWN</code></a>, <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_HALF_EVEN"><code>ROUND_HALF_EVEN</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_HALF_UP"><code>ROUND_HALF_UP</code></a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_UP"><code>ROUND_UP</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.ROUND_05UP"><code>ROUND_05UP</code></a>。 用函数getcontext()可以访问当前上下文，并可以更改设置。Context()函数可以创建算数上下文，若启用备用上下文，则需要setcontext()函数。</p><pre><code class="python">&gt;&gt;&gt; from decimal import *&gt;&gt;&gt; getcontext()Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])&gt;&gt;&gt; getcontext().prec = 6</code></pre><p> Decimal提供了两个现成的上下文<strong>BasicContext</strong> 和 <strong>ExtendedContext</strong>，<strong>BasicContext</strong>启用了许多陷阱对调试起到很大作用。算数上下文的另一个作用就是监视计算期间遇到的异常情况信号标志，举例见上文中信号部分示例。</p><h3 id="Decimal-常数"><a href="#Decimal-常数" class="headerlink" title="Decimal 常数"></a>Decimal 常数</h3><p>常数是C语言模块，但是完全可以和Python和谐共存。其中Decimal的常数有：</p><table><thead><tr><th>常数名称</th><th>32-bit</th><th>64-bit</th></tr></thead><tbody><tr><td>decimal.MAX_PREC</td><td>425000000</td><td>999999999999999999</td></tr><tr><td>decimal.MAX_EMAX</td><td>425000000</td><td>999999999999999999</td></tr><tr><td>decimal.MIN_EMIN</td><td>-425000000</td><td>-999999999999999999</td></tr><tr><td>decimal.MIN_ETINY</td><td>-849999999</td><td>-1999999999999999997</td></tr></tbody></table><p>另外，还有一个比较特别的常数 <code>decimal.HAVE_THREADS</code>, 默认值为<code>True</code>，但如果Python被编译的时候没有开辟线程，C会自动的杀死本地运行环境中开销比较大的线程，这种情况下，值为<code>False</code></p><h3 id="Decimal方法"><a href="#Decimal方法" class="headerlink" title="Decimal方法"></a>Decimal方法</h3><p>除了标准的数字属性，Decimal也有许多专门方法，并且方法很多</p><table><thead><tr><th style="text-align:left">方法名</th><th>含义</th><th>代码示例</th></tr></thead><tbody><tr><td style="text-align:left">adjuested()</td><td>移除系数最右边数字之后返回调整后的指数，直到只剩下前导数字</td><td></td></tr><tr><td style="text-align:left">as_integer_ratio()</td><td>返回一对(n,d)整数，表示给Decimal实例作为分数最简形式并带正分母</td><td>&gt;&gt;&gt; Decimal(‘-3.14’).as_integer_ratio()<br>(-157, 50)</td></tr><tr><td style="text-align:left">as_tuple()</td><td>返回一个tuple表示的数值</td><td>DecimalTuple(sign, digits, exponent)</td></tr><tr><td style="text-align:left">canonical()</td><td>返回参数的规范编码</td><td></td></tr><tr><td style="text-align:left">compare()</td><td>比较两个Decimal实例的值</td><td>a or b is a NaN  ==&gt; Decimal(‘NaN’)                 a &lt; b            ==&gt; Decimal(‘-1’)                              a == b           ==&gt; Decimal(‘0’)                                  a &gt; b            ==&gt; Decimal(‘1’)</td></tr><tr><td style="text-align:left">compare_signal()</td><td>除了所有的NaN信号之外，此操作与compare()方法相同</td><td></td></tr><tr><td style="text-align:left">compare_total()</td><td>使用抽象表示来比较 两个操作数</td><td></td></tr><tr><td style="text-align:left">compare_total_mag</td><td>使用抽象表示来比较，但忽略操作数的符号</td><td></td></tr><tr><td style="text-align:left">conjugate()</td><td>返回自身，只符合Decimal规范</td><td></td></tr><tr><td style="text-align:left">copy_abs()</td><td>返回参数的绝对值，操作不受上下文影响，不执行舍入</td><td></td></tr><tr><td style="text-align:left">copy_negate()</td><td>返回参数的否定值，符号设置与第二个操作数符号相同</td><td>&gt;&gt;&gt; Decimal(‘2.3’).copy_sign(Decimal(‘-1.5’)) Decimal(‘-2.3’)</td></tr><tr><td style="text-align:left">exp(context=None)</td><td>返回给定数字的指数函数，结果使用ROUND_HALF_EVEN模式舍入</td><td>&gt;&gt;&gt; Decimal(1).exp() Decimal(‘2.718281828459045235360287471’)     &gt;&gt;&gt; Decimal(321).exp() Decimal(‘2.561702493119680037517373933E+139’)</td></tr><tr><td style="text-align:left">from_float()</td><td>将浮点数转换为十进制数，Python3.2之后可以直接用float构造</td><td></td></tr><tr><td style="text-align:left">fma(other,third,context=None)</td><td>混合乘法加法，返回self *other+third，乘积不会四舍五入</td><td>&gt;&gt;&gt; Decimal(2).fma(3, 5)                                   Decimal(‘11’)</td></tr><tr><td style="text-align:left">is_canonical()</td><td>参数是规范的，则为返回 [<code>True</code>]，否则为 [<code>False</code>]</td><td></td></tr><tr><td style="text-align:left">is_finite()</td><td>参数是有限数 则返回True，否则返回Fasle</td><td></td></tr><tr><td style="text-align:left">is_infinite()</td><td>参数为正负无穷大，则返回True，否则为False</td><td></td></tr><tr><td style="text-align:left">is_nan()</td><td>如果参数为Nan，则返回True，否则返回False</td><td></td></tr><tr><td style="text-align:left">is_normal(context=None)</td><td>如果参数是一个有限正规数，返回 <code>True</code>，如果参数是0、次正规数、无穷大或是NaN，返回 <code>False</code></td><td></td></tr><tr><td style="text-align:left">is_qnan()</td><td>同is_nan()</td><td></td></tr><tr><td style="text-align:left">is_signed()</td><td>如果参数带有负数，返回True，否则返回False</td><td></td></tr><tr><td style="text-align:left">is_snan()</td><td>如果参数为显示NaN，则返回True，否则返回False</td><td></td></tr><tr><td style="text-align:left">is_subnormal(context=None)</td><td>如果参数为低于给定值，则返回 True，否则返回 False。</td><td></td></tr><tr><td style="text-align:left">is_zero()</td><td>如果参数是0(正负皆可)，则返回True，否则返回False</td></tr></tbody></table><p>Decimal参数很多，这里不一一列举了，更多函数可以参考<a href="https://docs.python.org/3.6/library/decimal.html">Deccimal标准库</a></p><h3 id="Decimal-注意点"><a href="#Decimal-注意点" class="headerlink" title="Decimal 注意点"></a>Decimal 注意点</h3><p>新版本Python3.3之后，congtext精度不会影响存储的位数，完全由value中的位数决定，context精度和舍入仅在算数期间发挥作用。context参数的目的是确定value是格式错误的字符串时该怎么做，如果context陷阱<a href="https://docs.python.org/zh-cn/3.6/library/decimal.html#decimal.InvalidOperation"><code>InvalidOperation</code></a>则引发 异常，否则构造函数返回一个新的Decimal，其值为NaN。构造完成后Decimal对象是不可变的。Python3.6之后允许下划线进行分组。</p><pre><code class="python">&gt;&gt;&gt; from decimal import *&gt;&gt;&gt; getcontext().prec = 6&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;)Decimal(&#39;3.1415926535&#39;)&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;) + Decimal(&#39;2.7182818285&#39;)Decimal(&#39;5.85987&#39;)&gt;&gt;&gt; getcontext().rounding = ROUND_UP&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;) + Decimal(&#39;2.7182818285&#39;)Decimal(&#39;5.85988&#39;)</code></pre><h2 id="Fraction-分数-："><a href="#Fraction-分数-：" class="headerlink" title="Fraction(分数)："></a>Fraction(分数)：</h2><p>Fraction分数类型可以由一系列整型数值，或其它数字类型，又或者是string(字符串)构造。</p><h3 id="Fraction构建方式"><a href="#Fraction构建方式" class="headerlink" title="Fraction构建方式"></a>Fraction构建方式</h3><p>Fraction构建形式为:</p><pre><code class="python">Fraction(numerator=0, denominator=1)Fraction(other_fraction)Fraction(float)Fraction(decimal)Fraction(string)</code></pre><p>第一种构建方式，需要一个符合数字类型的数值当分子，和一个符合数字类型的数值当分母，构造函数会返回一个<code>分子/分母</code>值的Fraction实例。众所周知，分数分母不能为0，如果分母为0，会出现<code>ZeroDivisionError</code>的错误。</p><p>第二种构建方式也必须要求是一个符合数字类型的数值当分子，返回同样值的一个fraction分数实例。</p><p>第三种和第四种构建方式接受数字类型为float类型和Decimal类型，返回一个精确的具有同样数值大小的Fraction分数实例。不过由于二进制浮点数问题，类似于Fraction(1.1)并不能准确地返回类似于Fration(11,10)这样的分数实例。具体的构建规则，由函数<code>limit_denominator()</code>决定(该函数后面会涉及)。</p><p>最后一种构建方式用string字符串类型或unicode类型构建，一般形式为:</p><p><code>[符号] 分子&#39;/&#39;分母</code> 如:<code>Fraction(&#39;-3/7&#39;)</code></p><pre><code class="python">&gt;&gt;&gt; from fractions import Fraction&gt;&gt;&gt;#第一种构建方式&gt;&gt;&gt; Fraction(-4, 5)Fraction(-4, 5)&gt;&gt;&gt; Fraction(3, 8)Fraction(3, 8)&gt;&gt;&gt;#第二种构建方式&gt;&gt;&gt; Fraction()Fraction(0, 1)&gt;&gt;&gt;#第三种构建方式&gt;&gt;&gt; Fraction(2.30)Fraction(2589569785738035, 1125899906842624)&gt;&gt;&gt; Fraction(Decimal (&#39;1.1&#39;))Fraction(11, 10)&gt;&gt;&gt;#第四种构建方式&gt;&gt;&gt; Fraction(&#39;-3/7&#39;)Fraction(-3, 7)&gt;&gt;&gt; Fraction(&#39;7e-6&#39;)Fraction(7, 1000000)</code></pre><p>Fraction类型继承字基本数据类型(numbers.Rational)，并继承了基类中的方法和操作。Fraction类型能够进行哈希运算，并且是不可变类型。</p><h3 id="Fraction属性和方法"><a href="#Fraction属性和方法" class="headerlink" title="Fraction属性和方法"></a>Fraction属性和方法</h3><p>属性：</p><p>numerator： 分子</p><p>denominator:  分母</p><p>方法：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:center">含义</th><th style="text-align:left">代码</th></tr></thead><tbody><tr><td style="text-align:left">from_float(flt)</td><td style="text-align:center">类方法，用float构建Fraction实例 Python3.2之后的方法</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">from_decimal(dec)</td><td style="text-align:center">类方法，用Decimal构建Fraction实例，同样是Python3.2之后才有</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">limit_denominator (max_denominator=100000)</td><td style="text-align:center">查找并返回一个和构造Fraction类数值接近，且分母是不超过设置的max_denominator的最大分母；该方法用来寻找与给定浮点数相近比例数，以及纠正一个近似float类型的比例数值</td><td style="text-align:left">&gt;&gt;&gt; from fractions import Fraction<br>&gt;&gt;&gt; Fraction(‘3.1415926’).limit_denominator(1000)<br>Fraction(355, 113)<br>&gt;&gt;&gt; from math import pi, cos<br>&gt;&gt;&gt; Fraction(cos(pi/3))<br>Fraction(4503599627370497, 9007199254740992)<br>&gt;&gt;&gt; Fraction(cos(pi/3)).limit_denominator()<br>Fraction(1, 2)<br>&gt;&gt;&gt; Fraction(1.1).limit_denominator()<br>Fraction(11, 10)<br>&gt;&gt;&gt;</td></tr><tr><td style="text-align:left"><strong>floor</strong>()</td><td style="text-align:center">返回一个&lt;= 分数自身的 int类型值，也可用数学模块中的math.floor()</td><td style="text-align:left">&gt;&gt;&gt; from math import floor<br>&gt;&gt;&gt; floor(Fraction(335,113))<br>2</td></tr><tr><td style="text-align:left"><strong>ceil</strong>()</td><td style="text-align:center">返回一个&gt;=分数自身的最小int值，同样可以用数学模块中的math.ceil()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>round</strong>() /<strong>round</strong>(ndigits)</td><td style="text-align:center">round()返回Fraction的四舍五入最接近的int值; round(ndigits)返回Fraction(1, 10*ndigits)最接近的倍数数</td><td style="text-align:left">&gt;&gt;&gt; round(Fraction(4.8))<br>5<br>&gt;&gt;&gt; round(Fraction(4.5))<br>4<br>&gt;&gt;&gt; round(Fraction(4.3))<br>4<br>&gt;&gt;&gt; round(Fraction(4.389089), 3)<br>Fraction(4389, 1000)</td></tr><tr><td style="text-align:left">fractions.gcd(a,b)</td><td style="text-align:center">返回整数a和b最大公约数, Python3.5之后用math.gcd()代替</td><td style="text-align:left">&gt;&gt;&gt; import fractions<br>&gt;&gt;&gt; fractions.gcd(2,3)<br>1<br>&gt;&gt;&gt; fractions.gcd(36, 24)<br>12</td></tr></tbody></table><h3 id="round-函数注意点"><a href="#round-函数注意点" class="headerlink" title="round()函数注意点"></a>round()函数注意点</h3><p>round()默认会进行四舍五入，但我们发现在上面的代码中</p><pre><code class="python">&gt;&gt;&gt; round(Fraction(4.5))4</code></pre><p>4.5四舍五入值应该为5，但是给出的结果是4。</p><p>这是因为Python3.5 之后round()函数如果遇到浮点距离两边一样远，会保留到偶数那一边，doc中的原话为：”values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice.”  </p><p>因为4.5 距离4 和距离5 都是0.5的距离，但因为4是偶数，所以最后结果是偶数4。如果是5.5的话，结果就是6</p><pre><code class="python">&gt;&gt;&gt; round(5.5)6</code></pre><p>不过在Pyton2 中就不会有这个问题，round()函数会保留到离上一位更近的一端，即远离0的一端。</p><p>瞬间是不是觉得有点坑，如果代码从Python2 迁移到Python3 涉及到了大量round()函数的话，就比较坑，所以建议如果是要进行数据运算，还是尽量使用math或cmath模块中的函数。</p><p>此外，除来以上问题之外，还存在着一个问题：<strong>浮点数精度问题</strong></p><p>例如代码</p><pre><code class="py">&gt;&gt;&gt; round (2.565, 2)2.56</code></pre><p>无论是Python2 还算Python3 以上代码得到的结果都是2.56，显然这不符合常理。这是<strong>因为数字的存储都是用二进制，如果换算成二进制后一串1和0后可能是无限位数的，机器已经做出了截断处理，那么2565这个数字就比实际数字要小一点点</strong>。这一点点就导致了它离2.56要更近一点点，所以保留两位小数时就近似到了2.56。</p><p>那round()函数对精度把控不准，有替代函数吗？</p><p>1.像上面提到的，使用math中函数替代 ，如math.ceiling</p><p>2.Python自带整除//</p><p>3.可以将浮点型做截断转成字符串</p><p>有关具体的各类Number运算，详见：<a href="https://onlyangelia.github.io/PythonAdvance/PythonNumberCaculations/">Python运算(-)数值、哈希、布尔等运算</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python3有六个标准数据类型：&lt;/p&gt;
&lt;p&gt;.不可变数据类型：&lt;strong&gt;Number(数字)、String(字符串)、Tuple(元组)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.可变数据类型： &lt;strong&gt;List(列表)、Dictionary(字典)、Set(集
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python前篇</title>
    <link href="https://onlyangelia.github.io/PythonAdvance/Pythonbrief/"/>
    <id>https://onlyangelia.github.io/PythonAdvance/Pythonbrief/</id>
    <published>2017-05-01T05:34:08.000Z</published>
    <updated>2019-05-17T11:16:54.246Z</updated>
    
    <content type="html"><![CDATA[<p>Python是一种解释型语言，一门完善的面向对象高级编程语言，无需编译和链接，为编写大型程序提供更多的结构和支持，并且与Shell脚本相比，适合编写GUI应用程序或游戏。Python提供大量的多种类型标准模块，模块提供了诸如I/O、 系统调用、Socket支持、用户图形（GUI工具）、机器学习、可视化等；内置高级的数据结构类型，为数据分析提供了更多支持；Python是可扩展的，可以将Python解释器集成进其它应用程序。</p><p><strong>Python学习建议</strong>：对于学习Python的建议是可以先敲几行代码，再回头看具体的类型和语法解释，因为这样会理解深刻，地基也能打的更牢靠。然后在这一组循环结束之后，再进行Python高阶学习，效率会更高。</p><p>个人认为的Python的优点： 每种语言都有自己的特点，之所以选择学习Python，是认可了Python对数字类型、字符串 强大的处理能力，以及对数据结构的扩展，这两点对数据清洗、数据存储和操作有很大帮助。</p><p>Python官网：<a href="https://www.python.org/">https://www.python.org/</a></p><h2 id="Python下载安装"><a href="#Python下载安装" class="headerlink" title="Python下载安装"></a>Python下载安装</h2><p>官网地址<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>提供各种版本的平台安装包，可以根据自己电脑版本下载对应的平台包。本人电脑是Mac 版，所以安装的Mac OS X平台包。不过Mac系统自带Python2.7环境，可以打开Termail 输入<code>Python -v</code>查看版本号，或者打开Python自带的IDLE，解释器开头会有Python环境的描述。因为本人要学习Python3，所以保留了自带的Python2.7环境，又下载来Python3.6，同时存在两种版本。若只想将Python2.7升级到Python3.6，则需要将下载后的Python3.6 替换原有的Python2.7。 </p><p>通常Python安装目录是:<code>/usr/local/bin</code>  ,如果是windows，安装目录一般是<code>C:\Python36</code>, 这里目录并不是固定Python36，如果安装版本是3.5，则目录就是<code>C:\Python35</code></p><h2 id="Python-IDE：模式-amp-类型"><a href="#Python-IDE：模式-amp-类型" class="headerlink" title="Python IDE：模式&amp;类型"></a>Python IDE：模式&amp;类型</h2><p>Python运行，需要通过IDE，Python IDE有很多种，例如：IDLE、PyCharm、Sublime Text、iPython、Vim、Eclipse + PyDev、jupyter、notebook+spyder3 等，可以根据个人习惯安装适合的IDE，以JAVA开发为主的编程人员可能更习惯使用Eclipse，不太会编码的人员可能使用notebook+spyder3更普遍，不过本人使用最频繁的IDE是Pycharm，Pycharm自带错误提示和输入提示，节约编码时间，提高编码效率，并且适合编写爬虫。</p><p>以上IDE中有IDE是工作在交互模式下，例如IDLE，打开IDLE会发现每行都以<code>&gt;&gt;&gt;</code>开头，<code>&gt;&gt;&gt;</code>是主标识符。若解释器从tty读取命名，则称解释器工作于<strong>交互模式</strong>，IDLE就是工作于交互模式的解释器，这种模式是根据主提示符来执行，主提示符通常情况下标识为三个大于号<code>&gt;&gt;&gt;</code> ，继续部分称为从属提示符，通常是三个点<code>...</code>,</p><p>在第一行主提示符之前，IDE打印欢迎信息、版本号和授权提示，这就是我们打开Python安装包自带的IDLE就能查看版本号的原因。因为交互模式的工作方式，每行代码敲完后都需要回车，回车之后会继续有三个大于号<code>&gt;&gt;&gt;</code> 的提示符，再继续输入后面的内容。脚本式编程的IDE 不会有提示符，代码编写完成后再运行即可。</p><h2 id="Python-IDE-环境设计"><a href="#Python-IDE-环境设计" class="headerlink" title="Python IDE 环境设计"></a>Python IDE 环境设计</h2><p>Python3 之前默认的编码格式是ASCII格式，在没有修改编码格式之前无法打印汉字，不过Python3 之后这个问题不存在，默认情况下源码文件以<strong>UTF-8</strong>编码。若使用的Python3之前的版本，则在编写程序之间需要添加一行注释：</p><pre><code class="python"># -*- coding: utf-8 -*-</code></pre><p>若要支持其它文字，则需要输入对应的编码格式。</p><p>针对部分IDE，可以统一设置编码格式，统一设置编码格式后则不需要在每次编码的时候添加注释。统一设置一般是在setting(mac版为偏好设置)中，找到对应的File encodings 将其中的IDE Encoding和Project Encoding设置为utf-8</p><h2 id="Python-基础语法"><a href="#Python-基础语法" class="headerlink" title="Python 基础语法"></a>Python 基础语法</h2><h3 id="1-缩进问题"><a href="#1-缩进问题" class="headerlink" title="1.缩进问题"></a>1.缩进问题</h3><p>​    缩进在Python中作为语法出现，表示代码的层级关系，同一个代码块的语句必须包含相同的缩进空格数。所以空格缩进问题要特别注意，多一个空格或少空格会造成语法错误。</p><pre><code class="python">IndentationError: unindent does not match any outer indentation level</code></pre><h3 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2.标识符"></a>2.标识符</h3><p>标识符由字母、数字、下划线构成，第一个字符必须是字母表中字母或下划线<code>_</code>，并且标识符区分大小写。以下划线开头的标识符有特殊含义， 单下划线开头<code>_modelorclassname</code>代表不能直接访问的类属性,需通过类提供的接口进行访问，不能用<code>from xxx import *</code>导入；双下划线开头<code>__propertyname</code>代表类的私有成员；以双下划线开头和结尾的<code>__name__</code> 是Python特殊方法专用表示，如<code>__init()__</code>代表类的构造函数。此外，Python3 现在可以接收非ASCII字符。</p><h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3.注释"></a>3.注释</h3><p>单行注释用<strong>#</strong>开头，多行注释可以用多个#号，或者是三个单引号’’’，或者三个双引号”””</p><pre><code class="python">#Python简介#Python基础语法&#39;&#39;&#39;Python简介Python基础语法&#39;&#39;&#39;&quot;&quot;&quot;Python简介Python基础语法&quot;&quot;&quot;</code></pre><h3 id="4-保留字"><a href="#4-保留字" class="headerlink" title="4.保留字"></a>4.保留字</h3><p>保留字是Python系统的关键字，所以开发者不能用来当标识符。Python3中可以查看所有保留字</p><pre><code class="python">&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</code></pre><h3 id="5-多行语句"><a href="#5-多行语句" class="headerlink" title="5.多行语句"></a>5.多行语句</h3><p>在[],{},()中的语句可以直接回车换行进行多行语句书写，但非以上结构中的语句，要想换行写必须使用反斜杠<code>\</code>。</p><pre><code class="python">number = 120000000 + 2000000000 + \                 3424546 + 58690765465\               234567789 + 5678900</code></pre><h3 id="6-标点符号问题"><a href="#6-标点符号问题" class="headerlink" title="6.标点符号问题"></a>6.标点符号问题</h3><p>Python环境中，除了Python流程控制函数后需要输入冒号以此来区分控制语句的多行代码，其它情况每行代码后无需加任何标点符号。</p><h3 id="7-空行"><a href="#7-空行" class="headerlink" title="7.空行"></a>7.空行</h3><p>空行在Python中也是程序代码的一部分，但空行并不是Python语法的一部分。函数之间、类的方法之间用空行分隔，表式一段新的代码的开始，不插入空行也不会报错。</p><h3 id="8-一行显示多条语句"><a href="#8-一行显示多条语句" class="headerlink" title="8.一行显示多条语句"></a>8.一行显示多条语句</h3><p>Python中可以在同一行中写多条语句，这个时候语句之间要使用分号<strong>；</strong>分割。交互式IDE中会一次性输出多条语句的执行结果。</p><h3 id="9-多个语句构成代码组"><a href="#9-多个语句构成代码组" class="headerlink" title="9. 多个语句构成代码组"></a>9. 多个语句构成代码组</h3><p>前面讲到缩进相同的代码代表同一个层级，这些代码构成来一个代码块，称为代码组。</p><p><strong>if</strong>、<strong>while</strong>等控制语句就会形成代码组。以及自定义函数<strong>def</strong> 或 <strong>class</strong>后面可以形成代码组。 交互式系统中代码组最后一行必须是空行 以此来表示代码组结束。</p><h3 id="10-import-与-from-…-import"><a href="#10-import-与-from-…-import" class="headerlink" title="10. import 与 from … import"></a>10. import 与 from … import</h3><p>Python中导入模块有<strong>import</strong>与<strong>form…import</strong>两种方式。整个模块导入用import格式，从某个模块中导入某个函数使用from…import个数。多个模块导入或某个模块导入多个函数，则在模块或特定函数之间用逗号<strong>,</strong>分割</p><pre><code class="python">import modulenameimport moduleone,moduletwofrom modulename import funcnamefrom modulename import funcone,functwo</code></pre><h3 id="11-模块下载"><a href="#11-模块下载" class="headerlink" title="11.模块下载"></a>11.模块下载</h3><p>Python具有兼容性，许多第三方module要自己下载，打开Terimal,输入：</p><pre><code class="python">python -m install modulename  #modulename 为要下载的部件名称</code></pre><p>如果电脑上有多个Python版本，需要指定Python版本进行下载</p><pre><code class="python">python3 -m install modulename </code></pre><h3 id="12-命令行参数"><a href="#12-命令行参数" class="headerlink" title="12. 命令行参数"></a>12. 命令行参数</h3><p>在Terimal中使用<strong>-h</strong>参数可以查看各参数帮助信息：</p><pre><code class="python">apple@muyingdeMacBook-Pro ~&gt; python -husage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...Options and arguments (and corresponding environment variables):-B     : don&#39;t write .py[co] files on import; also PYTHONDONTWRITEBYTECODE=x-c cmd : program passed in as string (terminates option list)-d     : debug output from parser; also PYTHONDEBUG=x-E     : ignore PYTHON* environment variables (such as PYTHONPATH)-h     : print this help message and exit (also --help)-i     : inspect interactively after running script; forces a prompt even         if stdin does not appear to be a terminal; also PYTHONINSPECT=x-m mod : run library module as a script (terminates option list)-O     : optimize generated bytecode slightly; also PYTHONOPTIMIZE=x-OO    : remove doc-strings in addition to the -O optimizations-R     : use a pseudo-random salt to make hash() values of various types be         unpredictable between separate invocations of the interpreter, as         a defense against denial-of-service attacks-Q arg : division options: -Qold (default), -Qwarn, -Qwarnall, -Qnew-s     : don&#39;t add user site directory to sys.path; also PYTHONNOUSERSITE-S     : don&#39;t imply &#39;import site&#39; on initialization-t     : issue warnings about inconsistent tab usage (-tt: issue errors)-u     : unbuffered binary stdout and stderr; also PYTHONUNBUFFERED=x         see man page for details on internal buffering relating to &#39;-u&#39;-v     : verbose (trace import statements); also PYTHONVERBOSE=x         can be supplied multiple times to increase verbosity-V     : print the Python version number and exit (also --version)-W arg : warning control; arg is action:message:category:module:lineno         also PYTHONWARNINGS=arg-x     : skip first line of source, allowing use of non-Unix forms of #!cmd-3     : warn about Python 3.x incompatibilities that 2to3 cannot trivially fixfile   : program read from script file-      : program read from stdin (default; interactive mode if a tty)arg ...: arguments passed to program in sys.argv[1:]Other environment variables:PYTHONSTARTUP: file executed on interactive startup (no default)PYTHONPATH   : &#39;:&#39;-separated list of directories prefixed to the               default module search path.  The result is sys.path.PYTHONHOME   : alternate &lt;prefix&gt; directory (or &lt;prefix&gt;:&lt;exec_prefix&gt;).               The default module search path uses &lt;prefix&gt;/pythonX.X.PYTHONCASEOK : ignore case in &#39;import&#39; statements (Windows).PYTHONIOENCODING: Encoding[:errors] used for stdin/stdout/stderr.PYTHONHASHSEED: if this variable is set to &#39;random&#39;, the effect is the same   as specifying the -R option: a random value is used to seed the hashes of   str, bytes and datetime objects.  It can also be set to an integer   in the range [0,4294967295] to get hash values with a predictable seed.</code></pre><p>此外，Python提供来<strong>getopt</strong>模块获取命令行参数， 或者用<strong>sys</strong> 模块的<strong>sys.argv</strong>获取命令行参数</p><h4 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块:"></a>sys模块:</h4><p><code>sys.argv[0]表示脚本名</code></p><p><code>sys.argv是命令行参数列表</code></p><p><code>len(sys.argv)是命令行参数个数</code></p><p>.py文件(.py为Python文件的后缀)中：</p><pre><code class="python">import sysprint (&#39;命令行参数个数为:&#39;, len(sys.argv))pring (&#39;命令行参数列表:&#39;, str(sys.argv)) </code></pre><p>执行和输出结果为:</p><pre><code class="python">python3 classname.py arg1 arg2输出结果：命令行参数个数为： 4命令行参数列表：[&#39;classname.py&#39;, &#39;arg1&#39;, &#39;arg2&#39;]</code></pre><h4 id="getopt模块"><a href="#getopt模块" class="headerlink" title="getopt模块"></a>getopt模块</h4><p>getopt模块专门处理命令行参数，用于获取命令行选型和参数支持短选项模式<code>-</code>和长选项模式<code>—</code></p><p>模块中共有：两个方法；一个异常。 用来处理解析命令行参数。</p><p><strong>getopt</strong>方法：</p><p>此方法解析命令行参数列表：</p><pre><code class="python">getopt.getopt(args, options[, long_options])</code></pre><p>方法参数说明:</p><p>args：要解析的命令行参数列表</p><p>options: 以字符串格式定义，options后的冒号: 表示该选项必须有附加的参数，没有则代表不需要附加参数。</p><p>long_options ： 列表格式定义，long_options 后的等号表示如果设置该选项，必须有附加的参数，否则就不附加参数。</p><p>返回值由两个元素组成：第一个是 <strong>(option, value)</strong> 元组的列表。 第二个是参数列表，包含那些没有’-‘或’–’的参数。</p><p><strong>gnu_getopt</strong>方法:</p><p>getopt.getopt方法在遇到第一个不符合设置的参数时就会自动忽略，而gnu_getopt方法则不会存在这样的情况，即使参数不符合设定也会将结果输出出来，能够得到全部的命令行参数。</p><p><strong>GetoptError</strong>异常：</p><p>没有找到参数列表或选项需要的参数为空时会触发此异常。异常的参数是一个字符串，表示错误的原因。属性msg和opt为相关选项的错误信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python是一种解释型语言，一门完善的面向对象高级编程语言，无需编译和链接，为编写大型程序提供更多的结构和支持，并且与Shell脚本相比，适合编写GUI应用程序或游戏。Python提供大量的多种类型标准模块，模块提供了诸如I/O、 系统调用、Socket支持、用户图形（G
      
    
    </summary>
    
      <category term="Python进阶" scheme="https://onlyangelia.github.io/categories/PythonAdvance/"/>
    
    
      <category term="Python" scheme="https://onlyangelia.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网络连接过程</title>
    <link href="https://onlyangelia.github.io/computerIntnet/intnetlink/"/>
    <id>https://onlyangelia.github.io/computerIntnet/intnetlink/</id>
    <published>2017-03-07T14:02:04.000Z</published>
    <updated>2019-05-17T11:16:12.348Z</updated>
    
    <content type="html"><![CDATA[<p>讲解连接过程之前，先解释几点，给后面的阐述做铺垫。在我们的电脑启动时，会通过<strong>DHCP协议(也是属于应用层的协议，基于UDP协议，全程 Dynamic Host Configuration Protocol ：动态主机配置协议)</strong> 进行动态配置IP地址（当然也可以手动配置IP，一般人不会这么做），并且我们的电脑会有对应的唯一的<strong>MAC地址（MAC全称：Media Access Control，媒体访问控制）</strong>，发送网络包，目标地址既要包括IP地址，也要包含MAC地址。IP地址类似于住址，MAC地址类似于身份证，两者缺一不可。IP地址和MAC地址的映射可以通过<strong>APR协议(全称：Address Resolution Protocol 地址解析协议，是属于链路层的协议 )</strong> 查询。记住IP地址和MAC地址这两个概念。</p><p>​<br>在<strong>TCP/IP五层模型</strong>下，通过在浏览器中浏览网页，我们来梳理下网络的连接过程。比如，我们在浏览器输入：<a href="https://onlyAnglia.github.io">https://onlyAnglia.github.io</a> ，按下回车，到浏览器中显示出博客内容中间经历了哪些过程？先简单的讲下HTTP的连接，再在HTTP的基础上补充HTTPS的连接。当然应用层还有许多协议，例如RTMP、QUIC、GTP等，有基于TCP的，也有基于UDP的。这里举例用基于TCP的HTTP协议，有关传输层常用的协议UDP 和 TCP连接不同和详细的连接过程，后面会单独写解释,接下来看一下网络的连接。</p><p>整体的传输流程如下：<br><img src="/computerIntnet/intnetlink/TCP-IP五层模型数据传输.png" alt></p><p>首先，机器和人不一样，并不能识别我们能熟记的域名，机器只认IP地址，所以</p><p><strong>step1：进行DNS解析，得到域名对应的IP地址</strong>(DNS解析比较复杂，这里只说下一般流程，有关<strong>负载均衡</strong>等暂且不提)</p><p>浏览器先在<strong>本地DNS</strong>缓存中查找onlyAnglia.github.io 对应的IP地址，若找到则返回对应的IP；倘若<strong>本地DNS缓存</strong>中未查找到域名对应的IP地址，则接下来会像<strong>本地DNS服务器</strong>询问（如果是通过<strong>DHCP</strong>配置，<strong>本地DNS服务器</strong>由对应的 <strong>网络服务商（ISP</strong>自动分配），如果找到就直接返回IP地址；若没有找到，<strong>本地DNS服务器</strong>会向它的<strong>根域名服务器</strong>询问,<strong>根域名服务器</strong>会告诉<strong>本地DNS服务器</strong>该向哪个<strong>顶级域名服务器</strong>询问，之后<strong>顶级域名服务器</strong>会告诉<strong>本地DNS服务器</strong>该向哪个<strong>权威域名服务器</strong>询问；接下来<strong>本地DNS服务器</strong>会找到对应的<strong>权威域名服务器</strong>查询对应的IP地址，<strong>权威服务器</strong>将对应的IP地址告诉<strong>本地DNS服务器</strong>，<strong>本地DNS服务器</strong>再将IP地址返回给浏览器，浏览器接收到对应的IP地址，准备开始建立连接。</p><p>​<br><strong>step2：使用HTTP协议，经过应用层包装</strong></p><p>查询到域名对应的IP地址之后表示请求访问的目标存在，可以进行访问。然后应用层请求构建<strong>HTTP</strong>，客户端的<strong>HTTP报文</strong>叫做<strong>请求报文</strong>，多数使用的还是<strong>HTTP1.1</strong>,在<strong>HTTP1.1</strong>的<strong>请求报文中</strong>包含了<strong>请求行</strong>、<strong>首部</strong>、<strong>正文实体</strong>。 其中，<strong>请求行</strong>包含用户<strong>请求的方法</strong>，<strong>请求URI</strong> 和 <strong>HTTP版本号</strong>。 例如：<code>POST  /form/entry  HTTP1.1</code>    <strong>首部字段</strong> 包含各种<strong>请求条件</strong>和<strong>请求属性</strong>，有些字段只是<strong>请求首部字段</strong>，部分是<strong>通用首部字段</strong>，还有一部分是<strong>实体首部字段</strong>(有关该部分可详见：<a href="https://github.com/onlyAngelia/Read-Mark/blob/master/HTTP/HTTP图解mark.md">HTTP协议简单解释</a>)。构建好请求报文后，通过<strong>stream二进制流</strong>传递给传输层。并且浏览器开启端口号监听。</p><p>​<br><strong>step3：传输层接收请求报文，构建请求段</strong>(传输层协议主要有UDP协议和TCP协议，HTTP是基于TCP协议)</p><p>应用层将请求报文传递给传输层后，传输层根据要使用的协议进行传输层报文的封装，在这里构建的是<strong>TCP包头</strong>，传输层构建好<strong>TCP包头</strong>后，将传输来的流信息作为数据项。<strong>TCP的包头</strong>比较复杂,这和<strong>TCP</strong>的可靠连接有关，此时到了传输层后内核会开启，监听端口号，等待接下来的回应。（一般机器中会有一个网卡，也有部分机器会装有多个网卡）此时浏览器处于<strong>SYN-SENT</strong>状态。<br><img src="/computerIntnet/intnetlink/TCP包头.jpg" alt> </p><p>​<br><strong>step4：网络层接收传输层的段，构建IP包</strong>（网络传输二层叫帧，网络层叫包，传输层叫段）</p><p>网络层在接收到传输层传过来的<strong>TCP包</strong>后，第一个任务是封装<strong>IP包</strong>，将应用层传输过来的TCP包作为数据项，添加IP首部，形成IP包。传输层TCP协议的包头首部中包含了源端口号、目的端口号，在网络层IP协议要将<strong>源地址</strong>、<strong>目的地址</strong>包装在IP包中。此外，<strong>IP包中还包含了版本、首部长度、服务类型TOS、总长度、标识、标志、片偏移、首部检验和、生存时间TTL等</strong>。网络层封装完<strong>IP包</strong>后，将<strong>IP包</strong>传交给链路层。</p><p>​<br><strong>step5：数据链路层接收IP包，构建MAC帧</strong></p><p>数据链路层又可称为<strong>MAC层(MAC全称 Media Access Control 媒体访问控制)</strong>，<strong>MAC层</strong>接收到<strong>IP包</strong>后，开始构建<strong>MAC帧</strong>，<strong>MAC帧</strong>开始是<strong>目标MAC地址</strong>和<strong>源MAC地址</strong>，<strong>源MAC地址</strong>毫无疑问是我们<strong>本机的MAC地址</strong>，<strong>本机的MAC地址</strong>在该设备被创造出来的时候就有，并且是唯一的(要想查看<strong>IP地址</strong>和<strong>MAC地址</strong>，linux上使用<strong>ifconfig</strong>或者<strong>ip addr</strong>，会在终端输出电脑的网络相关信息)。知道了自己设备上的<strong>MAC地址</strong>，但不知道<strong>目标IP地址</strong>对应的<strong>MAC地址</strong>，所以需要一个能够查询<strong>IP地址</strong>和<strong>MAC地址</strong>对应的协议，就是<strong>ARP（Address Resolution Protocol）协议</strong>。<strong>ARP协议</strong>只是针对<strong>IPv4</strong>，若是<strong>IPv6</strong>，要使用<strong>NDP协议</strong>。机器本地是有<strong>ARP协议缓存</strong>的，若能在<strong>ARP协议缓存</strong>中找到<strong>IP地址</strong>对应的<strong>MAC地址</strong>，便不会再去请求<strong>ARP协议</strong>，若没有则会请求<strong>ARP协议</strong>。在知道了<strong>目标IP地</strong>址对应的<strong>MAC地址</strong>后，将<strong>目标MAC地址</strong>放在<strong>MAC帧</strong>里,以太网的第二层最后面是<strong>CRC</strong>，也就是<strong>循环冗余检测</strong>，（<strong>MAC帧</strong>的其它组成不在细说）。</p><p>​<br><strong>step6：MAC帧头构建好后，网关准备发包</strong></p><p>MAC帧构建好，在网络中传输的网络包即构建好，然后将网络包发出去。在发包之前IP地址是否在同一个网段内的问题，通过CIDR和子网掩码计算是否在一个网段内，若在同一个网段内直接发出。一般我们访问的网站是不太可能和我们在同一网段内的，那么需要将包发往默认网关，默认网关收入包。</p><p><strong>step7：网关查询路由表，通过路由协议进行网络传输</strong></p><p>网关收入包后，取下<strong>MAC帧</strong>和<strong>IP包</strong>，判断该网哪里转发，根据路由算法，选择一个合适的网段。网段的选择会涉及到两种形式的路由算法，一种是<strong>静态路由</strong>，一种是<strong>动态路由</strong>。<strong>静态路由</strong>就是在路由器上配置一条条规则，维护路由表。可以通过route命令和ip route命令查看进行<strong>静态路由</strong>的查询和配置。 <strong>动态路由</strong>使用动态路由路由器，根据路由协议算法生成动态路由表，随网络运行情况的变化而变化。<strong>动态路由协议算法</strong>也涉及两大类，第一大类算法称为<strong>距离矢量路由（distance vector  routing）</strong>适用于小型网络，最早的路由协议<strong>RIP</strong>采用该算法，第二大类算法是<strong>链路状态路由（link state routing）</strong>。内部网关协议采用基于链路状态路由算法的<strong>OSPF（Open Shortest Path First，开放式最短路径优先</strong>），网络的路由协议是基于距离矢量路由算法的<strong>BGP(Border Gateway  Protocol)</strong>。<strong>BGP</strong>分为两类，<strong>eBGP</strong>和<strong>iBGP</strong>。对于网络包，每个数据中心有自己的规则，网络中这种不同规则所构成的网络包为<strong>自治系统AS(Autonomous System)</strong>。<strong>自治系统</strong>间边界路由器使用<strong>eBGP</strong>广播路由，内部运行<strong>iBGP</strong>，让内部路由器快速找到到达外网目的的最好的边界路由器。路由器之间信息交换使用的协议，<strong>RIP</strong>使用<strong>UDP协议</strong>，<strong>OSPF</strong>直接发送<strong>IP包</strong>，而<strong>BGP</strong>使用的是<strong>TCP协议</strong>，路由之间会建立<strong>TCP连接</strong>，每60s发送一次<strong>keep-alive</strong> 消息。此外<strong>HTTP 1.1</strong>默认<strong>keep-alive</strong>是开启的。这样网络包就像跳方格一样跳了多个（也许是一个）路由器之后，终于找到了目的<strong>IP地址</strong>所在的网关。</p><p>​<br><strong>step8：找到目的IP地址后，网关取下MAC头，将IP包发送给目的主机的网络层，检查IP地址是否对上</strong></p><p><strong>目的IP地址</strong>所在的网关接收到<strong>网络包</strong>后，发现在同一个网段内， 将包收入，然后发送给<strong>目的主机</strong>，<strong>目的主机</strong>取下<strong>MAC头</strong>，判断一下<strong>MAC地址</strong>和自己的相符，然后将<strong>IP包</strong>传给网络层，网络层取下<strong>IP包</strong>头,查看<strong>IP地址</strong>和自己的<strong>IP地址</strong>是否对上。</p><p>​<br><strong>step9：IP地址对上之后，网络层将包传递给传输层，TCP发确认包，会延刚才的方向报平安，直到收到平安到达的回复，进行TCP握手</strong></p><p>网络层数判断<strong>IP地址</strong>对上之后，根据IP头中的协议项，知道自己上层还需要<strong>TCP协议</strong>，将包传递给传输层，目的主机的内核开启，当目的主机有了IP的端口号，就可以调用<strong>listen函数</strong>进行监听(<strong>TCP</strong>和<strong>UDP</strong>都是基于 <strong>Socket</strong>,  而 <strong>listen函数 </strong>是<strong>Socket</strong>里的函数，有关 <strong>Socket</strong> 这里不详细解说)，目的主机处于<strong>LISTEN</strong>状态。传输层在收到TCP请求段后，会发送ACK包确认到达，此时目的主机处于<strong>SYN-RCVD</strong>状态，发送的网络包延刚才的路径传回，浏览器在接收到目的主机发送的SYN,ACK后进入<strong>ESTABLISHED</strong>状态，同时再发出ACK，当目的主机接收到ACK后也进入<strong>ESTABLISHED</strong>状态，此时TCP三次握手完成。</p><p>​<br><strong>step10：TCP收到回复后，进行目的端口匹配，将包内容传给HTTP服务，RPC统筹处理请求，告诉相关进程</strong></p><p><strong>TCP</strong>三次握手完成后，进行目的端口匹配，之后将包内容传给上层的<strong>HTTP服务</strong>，<strong>RPC</strong>统筹处理，告诉相关进程（<strong>Soket</strong>可能是进程在维护也可能是线程在维护监听，并且<strong>TCP</strong>往往会创立两个<strong>Socket</strong>，一个叫做就<strong>监听Socket</strong>，一个是<strong>已连接Socket</strong>，这里不详细讲述)。</p><p>​<br><strong>step11：RPC处理完毕，会回复一个HTTP/HTTPS包告知操作成功，准备向接收端传输处理结果</strong></p><p>在<strong>RPC</strong>处理完毕后，目的主机开始向接收方发送数据。在连接建立的时候，两方已商定<strong>起始ID</strong>，但数据的发送不是一个发送完等回复后再发送另一个，而是通过<strong>累计确认</strong>或者叫<strong>累计应答（cumulative acknowledgment）</strong> 的模式进行传输，即在应答某个之前的ID表示都收到了。这样<strong>TCP</strong>需要双方有缓存进行记录，发送方的记录分四部分：第一部分是<strong>发送了并且已确认</strong>，第二部分是<strong>发送了并且尚未确认</strong>，第三部分是<strong>没有发送但在等待发送</strong>，第四部分是<strong>没有发送暂时也不会发送</strong>。第一部分和第二部分的分界线是<strong>lastByteAcked</strong>，第二部分和第三部分的分界线是<strong>lastByteSent</strong>，整个第二部分和第三部分的和 <strong>Advertised window</strong> 。 浏览器作为接收端在TCP报文里是会告诉发送端这个窗口大小的，超过了这个窗口的包，接收端无法接收就会丢弃。（有关接收方的窗口说明详情可自行查询）</p><p>​<br><strong>step 12: TCP慢启动，之后开始进行数据传输，并随时监测窗口大小进行流量控制和拥塞控制</strong></p><p>虽然浏览器作为接收方告诉了发送方窗口大小，但网络是瞬息万变的，也许这会网络变差了或者网段了，那么<strong>TCP</strong>在一开始的时候，为了避免造成通道容量溢出，一条<strong>TCP</strong>连接后，设置只能发送一个报文段<strong>cwnd</strong>(congestion window 拥塞窗口)设置为1，在收到一个确认后，<strong>cwnd</strong>加一，一次能够发送两个，当这两个报文段的确认到来的时候，每个<strong>cwnd</strong>都加一，这样两个<strong>cwnd</strong>就加二，一次就能发四个，开始呈现指数级增长。当一次发送超过<strong>ssthresh</strong>的值时代表快要溢出，此时<strong>cwnd</strong>改为增加1/<strong>cwnd</strong>，一轮下来增长一个……这是有关传输过程中的拥塞控制，关于拥塞控制仍有一些问题存在，具体的流程可自查询相关的流量控制和拥塞控制。</p><p>​<br><strong>step 13:接收方浏览器接收到数据后，开始进行处理，逐渐在浏览器上显示</strong></p><p>通过数据的传输，接收端接收到了来自发送方的网络包，当接收到一个网络包时，<strong>TCP</strong>最终将包传递给浏览器，让浏览器处理<strong>HTTP应答报文</strong>，这样随着应答报文的数量增加，网页中的内容也会逐渐的显示在浏览器上。</p><p>​<br><strong>step 14: 数据传输完成，进行连接断开，四次挥手说再见</strong></p><p>数据终于传输完成，到了该断开的时候。但我们知道<strong>TCP</strong>是可靠的传输连接，是相对靠谱的，那作为靠谱的协议在断开的时候不能说断开就断开，并且<strong>TCP</strong>是全双工的，所以接收端和发送端需要各自断开。数据传输完毕时，服务器和浏览器作为发送方和接收方都处于<strong>ESTABLISHED</strong>状态，此时服务器知道数据已传输完毕，准备断开，就向接收方发送<strong>FIN</strong>报文，进入<strong>FIN-WAIT-1</strong>状态；接收方收到<strong>FIN</strong>报文后，向发送方发送<strong>ACK</strong>，进入<strong>CLOSED-WAIT</strong>状态；服务端收到<strong>ACK</strong>后从<strong>FIN-WAIT-1</strong>状态进入<strong>FIN-WAIT-2</strong>状态；接收方进入<strong>CLOSED-WAIT</strong>状态结束后再向发送方发送<strong>FIN,ACK</strong> ,并进入<strong>LAST-ACK</strong>状态；发送方接收到<strong>FIN、ACK</strong>后从<strong>FIN-WAIT-2</strong>状态进入<strong>TIME-WAIT</strong>状态(等待<strong>2MSL</strong>)，并且发送<strong>ACK</strong>；接收方接收到<strong>ACK</strong>后进入<strong>CLOSED</strong>状态；服务端等待2<strong>MSL(MSL: Maximum Segment Lifetime ,报文最大生成时间)</strong>后也进入<strong>CLOSED</strong>状态。至此，建立的连接已经各自断开，整个连接过程结束。  </p><p>为了更好的理解<strong>TCP三次握手</strong>和<strong>四次挥手</strong>，附上<strong>TCP状态机</strong><br><img src="/computerIntnet/intnetlink/TCP状态机.jpg" alt><br>以<strong>HTTP</strong>为例讲述了网络的连接过程，其它协议与此大同小异，若是基于<strong>UDP</strong>的协议会在上述步骤中简化很多，数据传输中的<strong>socket</strong>维护也相对简单。以上就是网络的连接过程。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;讲解连接过程之前，先解释几点，给后面的阐述做铺垫。在我们的电脑启动时，会通过&lt;strong&gt;DHCP协议(也是属于应用层的协议，基于UDP协议，全程 Dynamic Host Configuration Protocol ：动态主机配置协议)&lt;/strong&gt; 进行动态配置
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://onlyangelia.github.io/categories/computerIntnet/"/>
    
    
      <category term="网络连接" scheme="https://onlyangelia.github.io/tags/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Block自动截获变量</title>
    <link href="https://onlyangelia.github.io/Objective-C/blockbrief/"/>
    <id>https://onlyangelia.github.io/Objective-C/blockbrief/</id>
    <published>2016-05-07T14:55:08.000Z</published>
    <updated>2019-05-17T11:16:46.320Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://onlyangelia.github.io/Objective-C/blockindex/">《Block前言》</a>中讲到，不论何种类型的Block都自带截获变量这一技能，而针对不同的变量类型和不同的情况，自动截获分为以下情况</p><p><strong><br>1.截获变量的值<br>2.截获对象,将对象指针传递进去<br>3.将变量拷贝到堆区域，并持有变量<br>4.截获变量内存地址</strong><br>现针对以上内容进行详细分析。</p><h1 id="截获变量的值"><a href="#截获变量的值" class="headerlink" title="截获变量的值"></a>截获变量的值</h1><p>这一情况主要发生在<br>1.<strong>对基本数据类型的引用</strong>（局部参数）<br>其实说白了，对于所有类型，Block自动截获的皆为在Block截获之前的变量的瞬间值，唯一不同的是如果是Object类型，Block会多一步copy操作。先来看基本数据常量</p><pre><code>int a = 0;void (^lockBlock)(void) = ^{        NSLog(@&quot;a = %d&quot;,a);};++a;lockBlock();NSLog(@&quot;%@&quot;, lockBlock);</code></pre><p>以上代码最后输出</p><pre><code>YAObjectTest[7397:1142111] a = 0 YAObjectTest[7397:1142111] &lt;__NSMallocBlock__: 0x604000443e10&gt;</code></pre><p>发现a的值在执行block之前做了修改，执行block后获取到的还是a的原来值。<br>查看编译后的cpp文件</p><pre><code>void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__testBlockAutomaticInterceptVar_block_impl_0((void *)__BlockObject__testBlockAutomaticInterceptVar_block_func_0, &amp;__BlockObject__testBlockAutomaticInterceptVar_block_desc_0_DATA, a));</code></pre><p>可以看到传入lockBlock结构体中的仅有a的值，再看_block_impl_0中</p><pre><code>struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0{  struct __block_impl impl;  struct __BlockObject__testBlockAutomaticInterceptVar_block_desc_0* Desc;  int a;  __BlockObject__testBlockAutomaticInterceptVar_block_impl_0(void *fp, struct __BlockObject__testBlockAutomaticInterceptVar_block_desc_0 *desc, int _a, int flags=0) : a(_a) {    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }};</code></pre><p>该部分的第五行<code>int a；</code>可以明确的看到a 是值的形式存在。</p><p>为何会是引入a的值而不是a的内存地址呢？主要原因是<strong>int a 和LockBlock的存储区域不同，因int a = 0的声明是在函数内，所以是在栈区，而lockBlock在引用了局部变量后转换为MallocBlock存放在堆区</strong>。</p><p>在上述Block的实现函数<code>__BlockObject__testBlockAutomaticInterceptVar_block_func_0</code>中，我们可以看到如下部分</p><pre><code>int a = __cself-&gt;a; // bound by copy</code></pre><p>系统自动给我们加上了注释，<code>bound by copy</code>，变量<code>int a</code> ，是用 <code>__cself-&gt;</code> 来访问的,Block仅仅捕获了 <code>a</code> 的值，并没有捕获<code>a</code>的内存地址。<br>所以在testBlockAutomaticInterceptVar`这个函数中后来即使我们重写int a 的值，依旧无法去改变Block外面变量a的值</p><hr><hr><p>也正是基于以上原因，我们无法在Block内部更改自动截获的变量，更改截获的自动变量编译器会报以下错误</p><pre><code>Variable is not assignable (missing __block type specifier)</code></pre><p>变量无法在Block中改变外部变量的值，所以编译过程中就报编译错误</p><hr><hr><h1 id="截获对象-将对象指针传递进去，并持有变量"><a href="#截获对象-将对象指针传递进去，并持有变量" class="headerlink" title="截获对象,将对象指针传递进去，并持有变量"></a>截获对象,将对象指针传递进去，并持有变量</h1><p>相比较于基本数据常量而言，Block截获Object上，会有区分，Block截获的是对象，传入的是对象的指针，但是会多传入一部分内容，而且会多一步copy操作</p><pre><code> NSString *testString = @&quot;It is just a joke&quot;; void (^lockBlock)(void) = ^{        [testString stringByAppendingString:@&quot;Yeah, I&#39;m sure&quot;];  };   lockBlock();  NSLog(@&quot;%@&quot;,testString);  NSLog(@&quot;%@&quot;, lockBlock);</code></pre><p>用以上OC代码运行会发现testString的内存地址是一样的<code>&lt;__NSArrayM 0x604000240090&gt;</code>，同样不能在Block内部进行初始化操作（因为重新初始化Block内部的引用对象内存地址会发生变化这是不允许的）。</p><p>查看clang后的cpp文件，我们发现lockBlock声明赋值的部分编译后的代码如下</p><pre><code>void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__testBlockAutomaticInterceptVar_block_impl_0((void *)__BlockObject__testBlockAutomaticInterceptVar_block_func_0, &amp;__BlockObject__testBlockAutomaticInterceptVar_block_desc_0_DATA, testString, 570425344));</code></pre><p>相比较于基本数据常量而言，<strong>传递参数多了后面的<code>570425344</code>（这一部分后面探讨）</strong>。其它和基本数据类型一样，直接以<code>NSString *testString;</code>出现在<code>__BlockObject__testBlockAutomaticInterceptVar_block_impl_0</code>结构体中，在<code>__BlockObject__testBlockAutomaticInterceptVar_block_func_0</code>结构体中以<br><code>NSString *testString = __cself-&gt;testString; // bound by copy</code>——cself-&gt; 形式调用。</p><p>引用对象不同的是会多出来以下函数</p><pre><code>static void __BlockObject__testBlockAutomaticInterceptVar_block_copy_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*dst, struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;testString, (void*)src-&gt;testString, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __BlockObject__testBlockAutomaticInterceptVar_block_dispose_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;testString, 3/*BLOCK_FIELD_IS_OBJECT*/);}</code></pre><p>在编译文件中看到引用对象时有_block_copy  和 _block_dispose函数。这两个函数的作用相当于内存管理MRC中的copy 和 release操作，调用_block_copy将引用对象进行copy操作，调用_block_dispose相当于对testString 进行release操作。<br>copy具体的执行操作是申请内存，将栈数据复制过去，将Class改一下，最后向捕获到的对象发送retain，增加block的引用计数，dispose函数正好相反。<br>copy和dsipose函数中最后一个参数代表截获的参数类型，3 代表是Block，编译后的代码中注释了BLOCK_FIELD_IS_OBJECT，其它形式如下<br>.BLOCK_FIELD_IS_BLOCK；<br>.BLOCK_FIELD_IS_WEAK;<br>.BLOCK_BYREF_CALLER<br>.BLOCK_FIELD_IS_BYREF</p><p>与截获基本数据类型相同，截获对象传递的是指针，所以在Block内不能再对对象进行初始化，但其本身自带的方法可以调用，MallocBlock会持有引用的变量。</p><p>#变量拷贝到堆区域，并持有变量<br>.__block 修饰符修饰</p><p>#<strong>block<br>对于对象，Block引用内部可以进行操作不能初始化，但对于基本数据类型如何进行更改呢，这个时候会用到`</strong>block`修饰符。该修饰符的主要作用是将基本数据常量写入结构体转变为对象，copy到堆上，持有变量。来看下代码和转换后的代码</p><pre><code> __block int a = 0; void (^lockBlock)(void) = ^{      a = 2; };</code></pre><p>编译后的代码</p><pre><code>__attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 0};  void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__testBlockAutomaticInterceptVar_block_impl_0((void *)__BlockObject__testBlockAutomaticInterceptVar_block_func_0, &amp;__BlockObject__testBlockAutomaticInterceptVar_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));</code></pre><p>可以看到int a 被转换为<code>_blocks__(byref）</code>类型，在Block使用时传入的<code>(__Block_byref_a_0 *)&amp;a</code>，而具体的a被转换后的结构体，</p><pre><code>struct __Block_byref_a_0 {  void *__isa;__Block_byref_a_0 *__forwarding; int __flags; int __size; int a;};</code></pre><p>和对象的结构体一样包含isa指针，并且还有一个<strong>forwarding指针，flags、size、和一个int a 。此时，发现int a作为结构体成员，而</strong>forwarding指针是指向其本身，这就保证了被拷贝到堆区之后依然能够找到该变量。<br>将参数转变成对象之后，其也会增加</p><pre><code>static void __BlockObject__testBlockAutomaticInterceptVar_block_copy_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*dst, struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __BlockObject__testBlockAutomaticInterceptVar_block_dispose_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}</code></pre><p>copy和dispose函数的最后一个参数变为8，意味截获的变量是<strong>block转换来的。<br>具体的关于copy和dispose 可以祥见[霜神博客《深入研究Block捕获外部变量和</strong>block实现原理》第二部分Block的copy和dispose](<a href="https://www.jianshu.com/p/ee9756f3d5f6">https://www.jianshu.com/p/ee9756f3d5f6</a>)</p><p>#截获内存地址<br>.对于静态变量，全局变量，Block截获的是内存地址，在Block内部可以直接修改值。<br>主要因为静态变量和全局变量的存储区域并不会发生改变，所以在Block截获时引用的是其内存地址，修改后仍旧是存储在静态区</p><pre><code>static int count = 100; typedef int (^blockStatic)(void); blockStatic blk = ^(){    count = 1000;   return count;  };</code></pre><p>转换后的函数实现如下</p><pre><code>static int __BlockObject__testBlockKinds_block_func_0(struct __BlockObject__testBlockKinds_block_impl_0 *__cself) {        count = 1000;        return count;  }</code></pre><p>在Block内部直接可以修改count的值，对count的引用直接获取的内存地址，且在__block _impl 结构体中并没有将count值引用或copy。</p><p>#结尾补充：”570425344”代表啥？<br>细心的大佬们肯定发现了在Block语法转换时候，若引用的是对象，则后面必跟一个数字<strong>570425344</strong> ，且不管是不同项目、不同类、不同Block，这个数值是固定的。为了这个问题也困惑了好久，开始以为这就是一个判断是否是对象的枚举类型。最后特不好意思的咨询霜大神，醍醐灌顶。可能和霜神之间隔了570425344光年的距离，这距离差在解决问题的思路和办法上，我是一直在编译后的cpp文件中查看，发现并没有解释，只能通过尝试来得出一个猜想。霜神是直接将这串数次Google ，而Google 告诉我们了答案（虽然这答案未必准备，但比我的想法好多了）。</p><pre><code>myBlock-&gt;impl.isa = &amp;_NSConcreteStackBlock;myBlock-&gt;impl.Flags = 570425344;</code></pre><p><code>570425344</code>为Flags的偏移量，这个偏移量是固定的。大家可以自己代码运行下查看GlobalBlock的Flags为10位数正数，StackBlock和MallocBlock的Flags为10位数负数，<br>这里暂时将”<code>570425344&quot;</code>理解为Flags的偏移量，若有大佬知道确切答案，希望能不吝赐教</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://onlyangelia.github.io/Objective-C/blockindex/&quot;&gt;《Block前言》&lt;/a&gt;中讲到，不论何种类型的Block都自带截获变量这一技能，而针对不同的变量类型和不同的情况，自动截获分为以下情况&lt;/p&gt;

      
    
    </summary>
    
      <category term="Objective-C" scheme="https://onlyangelia.github.io/categories/Objective-C/"/>
    
    
      <category term="Block" scheme="https://onlyangelia.github.io/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Block类型及内存区域</title>
    <link href="https://onlyangelia.github.io/Objective-C/blockmemory/"/>
    <id>https://onlyangelia.github.io/Objective-C/blockmemory/</id>
    <published>2016-04-10T14:55:08.000Z</published>
    <updated>2019-05-17T11:16:19.563Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://onlyangelia.github.io/Objective-C/blockindex/">Block前言</a>中，讲到Block 的isa指针六种类型，以及每种类型的存储区域。简单回顾一下最终结论</p><table><br>  <tr><br>    <th width="35%," bgcolor="#eeeeee">类型</th><br>    <th width="35%," bgcolor="#eeeeee">查看源</th><br>    <th width="30%," bgcolor="#eeeeee">存储区域</th><br>  </tr><br> <tr><br>    <td>_NSConcreteGlobalBlock</td><br>    <td> .cpp文件/Block.h </td><br>    <td> 全局变量/静态变量区</td><br>  </tr><br>  <tr><br>    <td>_NSConcreteStackBlock </td><br>    <td> .cpp文件/Block.h</td><br>    <td> 栈区 </td><br>  </tr><br> <tr><br>    <td>_NSConcreteMallocBlock </td><br>    <td> Block_private.h文件</td><br>    <td> 堆区</td><br>  </tr><br><tr><br>    <td>_NSConcreteAutoBlock </td><br>    <td> Block_private.h文件</td><br>    <td> 堆区</td><br>  </tr><br><tr><br>    <td>_NSConcreteFinalizingBlock </td><br>    <td> Block_private.h文件</td><br>    <td> 堆区</td><br>  </tr><br><tr><br>    <td>_NSConcreteWeakBlockVariable </td><br>    <td> Block_private.h文件</td><br>    <td> 堆区</td><br>  </tr><br></table><p>以上内容的查看在编译后的cpp文件以及runtime源码中都可以查看到相关信息<br><a href="https://github.com/onlyAngelia/YAObjectTest.git">code已上传到Github,点击下载</a><br><a href="https://opensource.apple.com/source/objc4/objc4-680/runtime/">runtime源码Apple官网</a><br><a href="https://github.com/onlyAngelia/objc-runtime">runtime源码Github</a></p><h1 id="特别注意点"><a href="#特别注意点" class="headerlink" title="特别注意点"></a>特别注意点</h1><p>Block前言中讲到默认创建的Block指针只有Global、Statck，其它四种是在运行时编译环境决定的，此根据也是根据runtime源码和注释得出结论。</p><pre><code class="cpp">// the raw data space for runtime classes for blocks// class+meta used for stack, malloc, and collectable based blocksBLOCK_EXPORT void * _NSConcreteMallocBlock[32]    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteAutoBlock[32]    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32]    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32]    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</code></pre><p>从以上runtime源码和注释中我们可以很好的解释该6种Block在Mac和iOS系统中都会出现，除Global、Statck，其它四种是在运行时编译环境决定。</p><h1 id="每种Block出现的情况"><a href="#每种Block出现的情况" class="headerlink" title="每种Block出现的情况"></a>每种Block出现的情况</h1><p>（最好复习一下基本数据结构）</p><h2 id="NSConcreteGlobalBlock"><a href="#NSConcreteGlobalBlock" class="headerlink" title="_NSConcreteGlobalBlock"></a>_NSConcreteGlobalBlock</h2><p>在以下情况下，Block为GlobalBlock (根据赋值情况会决定存储静态区的静态变量区域还是全局变量区域)<br><strong>1.Block声明为全局变量<br>2.函数区域内Block语法表达式没有使用外部变量<br>3.Block内部只引用了内部传递值或只引用了静态变量或全局变量</strong></p><p>第一种情况好理解,一般我们声明的全局变量都会放在静态区,当Block被声明为全局变量时也会存放在静态区域<br>如下将Block声明为全局变量,查看编译后的cpp文件,找到对应的编译代码<br>源码:</p><pre><code>#import &quot;BlockObject.h&quot;#import &lt;objc/runtime.h&gt;void (^globalBlock)(void)=^{};@interface BlockObject()</code></pre><p>编译后的部分代码:</p><pre><code>struct __globalBlock_block_impl_0 {  struct __block_impl impl;  struct __globalBlock_block_desc_0* Desc;  __globalBlock_block_impl_0(void *fp, struct __globalBlock_block_desc_0 *desc, int flags=0) {    impl.isa = &amp;_NSConcreteGlobalBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }};</code></pre><p>`impl.isa = &amp;_NSConcreteGlobalBlock;可以看到我们声明的<strong>全局变量block为NSConcreteGlobalBlock</strong>。</p><p>第二种情况我们可以看如下代码</p><pre><code> typedef int (^blockStatic)(void);blockStatic secondBlk = ^(){        return 1; };NSLog(@&quot;%@&quot;,secondBlk);</code></pre><p>最后查看到输出结果如下</p><pre><code>YAObjectTest[8834:1196308] &lt;__NSGlobalBlock__: 0x10de381c8&gt;</code></pre><p>所以，<strong>未引用外部变量时，最终得到的block也是NSConcreteGlobalBlock</strong>。</p><p>第三种情况我看可以看如下代码</p><pre><code>static int count = 100;typedef int (^blockStatic)(void);blockStatic blk = ^(){        return count;    };     NSLog(@&quot;%@&quot;,blk);</code></pre><p>最后的输出结果如下：</p><pre><code>YAObjectTest[8719:1185296] &lt;__NSGlobalBlock__: 0x108320188&gt;</code></pre><p>最后的输出也是GlobalBlock，所以，<strong>只引用静态变量或全局变量时，Block仍为NSConcreteGlobalBlock</strong>。</p><hr><p>解惑：第二种情况和第三种情况我们最终查看的是输出情况，而不是clang后的源文件。查看clang后的源文件该两种情况得到的是StackBlock。编译器根据编译特性会把后两种情况默认编译后定义为StackBlock，但是我们知道OC是动态语言，所以最终还是以运行时或最终输出结果为准。</p><hr><h1 id="NSConcreteStackBlock"><a href="#NSConcreteStackBlock" class="headerlink" title="_NSConcreteStackBlock"></a>_NSConcreteStackBlock</h1><p><strong>1.使用到外部局部变量、成员属性变量（非静态变量值）&amp; 2.未使用strong或copy修饰符修饰</strong><br><strong>以上条件缺一不可，只有这两个条件同时成立时，Block才为_NSConcreteStackBlock</strong><br>如果在函数内，Block只是引用了外部局部变量或成员属性变量，最终会被copy到堆上变为MallocBlock。而对于声明为属性的Block，如果修饰符为strong或copy，则也会copy到堆上，而不是StackBlock。<br>查看以下代码的最终输出（不能同时满足上述两种条件的情况下）</p><pre><code>@interface BlockObject()@property (nonatomic, strong)void(^proBlock)(void);@property (nonatomic, assign)NSInteger outsideCount;@end     int a = 1;    //使用外部局部变量情况    void (^blockVariable)(void) = ^(){        NSLog(@&quot;%ld&quot;,(long)_outsideCount);    };    NSLog(@&quot;%@&quot;,blockVariable);    _proBlock = ^(){        NSLog(@&quot;%d&quot;,a);    };    NSLog(@&quot;%@&quot;,_proBlock);</code></pre><p>最终控制台输出如下</p><pre><code> &lt;__NSMallocBlock__: 0x600000447c50&gt; &lt;__NSMallocBlock__: 0x6040002557b0&gt;</code></pre><p>将proBlock的修饰符换成weak，</p><pre><code>@property (nonatomic, weak)void(^proBlock)(void);</code></pre><p>同样的代码，会得到如下结果，proBlock会是StackBlock</p><pre><code>YAObjectTest[10461:1384618] &lt;__NSMallocBlock__: 0x60400025d1f0&gt;YAObjectTest[10461:1384618] &lt;__NSStackBlock__: 0x7ffee9f07930&gt;</code></pre><p>所以，<strong>在引用了外部变量并且没有强指针引用的情况下的Block为_NSConcreteStackBlock</strong>。</p><h1 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="_NSConcreteMallocBlock"></a>_NSConcreteMallocBlock</h1><p>1.引用了外部变量，有strong或copy修饰符修饰<br>2.block内部需要修改引用变量的值，外部变量被<strong>block修饰<br>第一种情况在求证StackBlock的情况下已经得到验证，有strong或copy修饰后并且引用了外部变量的情况下，为** &lt;</strong>NSMallocBlock__: 0x6040002557b0&gt;**<br>有关第二种情况，在该文只做验证，后续深入解析，详见Block截获变量中的__block修饰符深入解析</p><pre><code>    __block int a = 0;    void (^lockBlock)(void) = ^{        a++;    };    lockBlock();    NSLog(@&quot;%@&quot;, lockBlock);</code></pre><p>最后的输出结果为</p><pre><code>YAObjectTest[10853:1425358] &lt;__NSMallocBlock__: 0x60000024e610&gt;</code></pre><p>在此就求证了以上两种结果最后Block为_NSConcreteMallocBlock。</p><hr><p>接下来的三种类型Block，因对有GC回收机制的语言不是太熟悉，在Xcode中编写的C++代码 最终查看运行时的isa指针皆为—NSStackBlock，在Xcode中并没有按照预想的查看到以下三种类型，Terminal终端g++ 编译后的可执行文件也未见以下类型，查阅资料发现以下三种出现的情况大致如下，若有对C++ 熟悉的人员 ，请不吝赐教😉</p><hr><h1 id="NSConcreteFinalizingBlock"><a href="#NSConcreteFinalizingBlock" class="headerlink" title="_NSConcreteFinalizingBlock"></a>_NSConcreteFinalizingBlock</h1><p>.Block需要copy到堆上，但是Block内部有ctors 和 dtors时，block会是NSFinalizingBlock</p><h1 id="NSConcreteAutoBlock"><a href="#NSConcreteAutoBlock" class="headerlink" title="_NSConcreteAutoBlock"></a>_NSConcreteAutoBlock</h1><p>.Block需要copy到堆上若未引用到ctors和 dtors 则是NSAutoBlock<br>以上是AutoBlock和FinalizingBlock的出现情况。而对于ctors和dtors，<br>ctors中保存着程序全部构造函数的指针数组，dtors中保存着程序全部析构函数的指针数组，从两者的存储内容来看，若block引用了该两种类型，势必block会在程序运行结束时回收内存，所以会被转换为FinalizingBlock，而未引用的block则会根据情况自动回收，转换为AutoBlock。</p><p>以下是写在cpp文件中的代码</p><pre><code>void testAutoBlock(){  int * b=new int[4];   __block int testCount = 100;   int (^myBlock)() = ^() {        b[0] = testCount;        b[1] = testCount + 1;        b[2] = testCount + 2;        b[3] = testCount + 3;        std::cout&lt;&lt;b&lt;&lt;std::endl;       return 0;    };    std::cout&lt;&lt;myBlock&lt;&lt;std::endl;   }；</code></pre><h1 id="NSConcreteWeakBlockVariable"><a href="#NSConcreteWeakBlockVariable" class="headerlink" title="_NSConcreteWeakBlockVariable"></a>_NSConcreteWeakBlockVariable</h1><p>.GC回收机制下，用_weak 或<strong>block修饰的block 会转变成NSWeakBlockVariable<br>具体的对于</strong>weak 和__blcok修饰符，在后面截获变量和循环引用中具体详解。<br>以上是个人对于Block类型和存储区域的总结。中间为探究后三种类型浪费了很多时间，导致文章延迟。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://onlyangelia.github.io/Objective-C/blockindex/&quot;&gt;Block前言&lt;/a&gt;中，讲到Block 的isa指针六种类型，以及每种类型的存储区域。简单回顾一下最终结论&lt;/p&gt;
&lt;table&gt;&lt;br&gt;  
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://onlyangelia.github.io/categories/Objective-C/"/>
    
    
      <category term="Block" scheme="https://onlyangelia.github.io/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Block实质</title>
    <link href="https://onlyangelia.github.io/Objective-C/blocknature/"/>
    <id>https://onlyangelia.github.io/Objective-C/blocknature/</id>
    <published>2016-04-09T14:55:08.000Z</published>
    <updated>2019-05-17T11:16:36.756Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://onlyangelia.github.io/Objective-C/blockindex/">《Block前言》</a>中讲到，<strong>Block</strong>是对C语言的扩充，<strong>Block为带有自动变量（局部变量）的匿名函数</strong>。查看源码得知OC中，<strong>Block是作为对象存在</strong>。该篇文章针对这两点展开细节。</p><p>#Block为带有自动变量（局部变量）的匿名函数<br>接下来，根据clang命令<code>clang -rewrite-objc BlockObject.m</code> 得到的cpp文件查看Block具体的结构<a href="https://github.com/onlyAngelia/YAObjectTest.git">code已上传到Github,点击下载</a></p><pre><code class="objc:n"> void (^lockBlock)(void) = ^{ }; lockBlock();</code></pre><p>执行clang命令后对应代码会有如下结果</p><pre><code class="cpp:n">void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__init_block_impl_0((void *)__BlockObject__init_block_func_0, &amp;__BlockObject__init_block_desc_0_DATA));        ((void (*)(__block_impl *))((__block_impl *)lockBlock)-&gt;FuncPtr)((__block_impl *)lockBlock);</code></pre><p>第一行代码Block的定义<code>void (^lockBlock)(void) = ^{ }</code>;被解析成</p><pre><code class="cpp">void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__init_block_impl_0((void *)__BlockObject__init_block_func_0, &amp;__BlockObject__init_block_desc_0_DATA));</code></pre><p>我们主要看<code>=</code>后面的部分。大家有没有对<code>void (*)()</code>这一部分有种似曾相识的感觉，没错，这和我们C语言中的函数格式一样，唯一的区别是没有函数名称，所以这就是为何称 <code>**Block为匿名函数**</code>的原因。<br> 我们知道<code>^{ }</code>该部分才是Block语法，然而该部分在编译之后，我们单纯看上面部分编译后的内容可能会觉得<code>__BlockObject__init_block_impl_0</code>这是对应的转换，其实也没错，只不过为了理解自动变量这一概念，我们看<code>__BlockObject__init_block_impl_0</code>的第一个参数<code>__BlockObject__init_block_func_0</code>。为了方便大家更好的理解以及查找，在Block语法中我们增添一部分内容<code>^{ NSLog(@&quot;lockBlock&quot;); }</code>，该部分block语法块的单独对应编译部分(即<code>__BlockObject__init_block_impl_0</code>对应的第一参数)为</p><pre><code class="cpp">static void __BlockObject__init_block_func_0(struct __BlockObject__init_block_impl_0 *__cself) {            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n__p6qtc6t91tgcqk06x_s9b84w0000gn_T_BlockObject_2304d0_mi_0);        }</code></pre><p>来看<code>struct __BlockObject__init_block_impl_0 *__cself</code>该部分，<code>__cself</code>这里暂时不做深入讲解，只要明白这行代码的意思是<code>struct __BlockObject__init_block_impl_0</code>代表的是当前Block语法即可。那么我们<strong>回归正题</strong>在最初提到的编译后如下代码，</p><pre><code class="cpp">void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__init_block_impl_0((void *)__BlockObject__init_block_func_0, &amp;__BlockObject__init_block_desc_0_DATA));</code></pre><p>我们关注<code>((void (*)())&amp;__BlockObject__init_block_impl_0</code>这一部分，上述讲到在该编译代码中<code>__BlockObject__init_block_impl_0</code>代表的是当前Block语法，查看<code>__BlockObject__init_block_impl_0</code>的编译源码我们知道其实是一个结构体类型的变量（该切入点放第二部分讲解），那么<code>&amp;__BlockObject__init_block_impl_0</code>便是结构体的实例指针，所以整个转换后的操作是将生成的<strong><code>结构体自动变量</code></strong>转换为结构体实例指针赋值给变量<code>lockBlock</code>。至此，我们可以清晰的知道<strong><code>Block为带有自动变量（局部变量）的匿名函数</code></strong>。</p><p>也许大多数跟本人一样，对C语言已经不太熟悉。那接下来的小插曲便是简单写C语言的函数声明和调用，帮助大家更好的理解(这里使用函数指针代替直接调用)</p><pre><code class="s:n">void func(int count);void (*funcptr)(int) = &amp;func;void conclusion = (*funcptr)(100);</code></pre><p>对应的第二行调用代码 <code>lockBlock();</code> 编译后对应的转换我们可以清晰的看到<code>((__block_impl *)lockBlock)-&gt;FuncPtr)((__block_impl *)lockBlock)</code>，简化后为<code>（*lockBlock-&gt;impl.FuncPtr)(lockBlock)</code>，至此我们看到函数调用采用的是函数指针。<br>以上简单的介绍，相信大家对Block是对C语言的扩充，是匿名函数有了明确的认知。</p><p>#Block作为对象存在（OC语言中）<br>上一部分中，为了更好的帮助大家理解，简化了很大一部分。我们留下几个点放在这部分来讲。首先大家最关心的应该是<code>__BlockObject__init_block_impl_0</code>问题。在此，有一点要向大家说明：<strong>BlockObject是本人代码中的类名，</strong>init是函数名，会有这两部分前缀仅仅是因为本人在类BlockObject的初始化方法init里面写的Block，所以每个人创建的类不同，方法不同，<code>__BlockObject__init</code>这一部分前缀便会不同。下面，我们来看下其结构体本身</p><pre><code class="cpp">struct __BlockObject__init_block_impl_0 {  struct __block_impl impl;  struct __BlockObject__init_block_desc_0* Desc;  __BlockObject__init_block_impl_0(void *fp, struct __BlockObject__init_block_desc_0 *desc, int flags=0) {    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }};</code></pre><p>编译后的源码将构造函数和结构体一块合并，接下来我们将其拆分，其实<code>__BlockObject__init_block_impl_0</code>最核心的本质便是如下：</p><pre><code class="cpp">struct __BlockObject__init_block_impl_0 {  struct __block_impl impl;  struct __BlockObject__init_block_desc_0* Desc;}</code></pre><p>观察到<code>__BlockObject__init_block_impl_0</code> 本质是结构体，结构体中又包含结构体<code>struct __block_impl</code>和<code>__BlockObject__init_block_desc_0</code>指针，接下来我们再一步步探究这两部分的具体内容，而构造函数放在后序进行分析。</p><pre><code class="cpp">struct __block_impl {  void *isa;  int Flags;  int Reserved;  void *FuncPtr;}</code></pre><p>此结构体是我们探究到的Block最原始结构，看到isa指针，松口气，推断<strong>Block在OC语言中作为对象存在</strong>。</p><hr><p>以上内容作为简单理解<strong>Block为带有自动变量（局部变量）的匿名函数</strong>以及<strong>Block在OC语言中作为对象存在</strong>，以下部分有兴趣可继续了解</p><hr><p>既然我们知道Block是作为对象存在的，其肯定存在内存大小，而具体的内存大小便在其如下结构中可以清晰的看到<code>Block_size</code></p><pre><code class="cpp">static struct __BlockObject__init_block_desc_0 {  size_t reserved;  size_t Block_size;}</code></pre><p>在<code>__BlockObject__init_block_impl_0((void *)__BlockObject__init_block_func_0, &amp;__BlockObject__init_block_desc_0_DATA))</code>的两个初始化参数中，我们看到<code>__BlockObject__init_block_func_0</code> 该参数第一部分有讲到，是转换的c函数指针，第二个参数<code>&amp;__BlockObject__init_block_desc_0_DATA</code>转换后的编译代码为</p><pre><code class="cpp">__BlockObject__init_block_desc_0_DATA = { 0, sizeof(struct __BlockObject__init_block_impl_0)};</code></pre><p>所以第二个参数是初始化<code>__BlockObject__init_block_impl_0</code>实例的大小。<br>再讲下构造函数</p><pre><code class="cpp">  __BlockObject__init_block_impl_0(void *fp, struct __BlockObject__init_block_desc_0 *desc, int flags=0) {    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }</code></pre><p>从构造函数中我们可以看到fp被赋值给了结构体成员变量FuncPtr，那fp是何玩意呢，联想到<code>__BlockObject__init_block_impl_0</code>的第一个参数，便知fp即为<strong>BlockObject</strong>init_block_func_0，所以成员变量FuncPtr被赋值<strong>BlockObject</strong>init_block_func_0的函数指针。这就是为什么在第一部分讲<code>((__block_impl *)lockBlock)-&gt;FuncPtr)((__block_impl *)lockBlock)</code>采用函数指针调用函数。<br>有关Block实质大致讲到这里，后续发现问题再修正。若有任何问题，也请指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://onlyangelia.github.io/Objective-C/blockindex/&quot;&gt;《Block前言》&lt;/a&gt;中讲到，&lt;strong&gt;Block&lt;/strong&gt;是对C语言的扩充，&lt;strong&gt;Block为带有自动变量（局部变量
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://onlyangelia.github.io/categories/Objective-C/"/>
    
    
      <category term="Block" scheme="https://onlyangelia.github.io/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Block前言</title>
    <link href="https://onlyangelia.github.io/Objective-C/blockindex/"/>
    <id>https://onlyangelia.github.io/Objective-C/blockindex/</id>
    <published>2016-04-08T14:55:08.000Z</published>
    <updated>2019-05-17T11:16:28.894Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Block</strong>可能已经是被大家讨论的滚瓜烂熟的话题了，却经久不衰。总结这篇文章的起因是在一个开发群里许多iOSer咨询block问题，于是写该系列Block文章系统梳理一下有关Block的知识体系。该系列文章会从<code>Block实质</code>、<code>Block类型及内存区域</code>、<code>Block截获自动变量</code>、<code>Block循环引用问题</code>深入理解Block。</p><h1 id="Block实质"><a href="#Block实质" class="headerlink" title="Block实质"></a>Block实质</h1><p>在OC语言中，<strong>Block</strong>从OS X Snow Leopard 和 iOS 4起开始引入，才被众多OC语言使用者周知。OC是基于C语言编写，Block也是基于C语言的扩充，那Block是扩充的何种功能呢？简而言之，Block是<strong><code>带有自动变量（局部变量）的匿名函数</code></strong>。但OC语言又是对C语言的扩展，是OOL，所以Block在OC中的存在绝不仅仅是一段函数。我们可以使用<strong>clang</strong>命令，查看Block在OC中的实现。(clang -rewrite-objc 源文件名 note：具体如何clang，详情Google )<br>具体沿着编译后的cpp文件查找，会查找到如下最<strong>原始结构</strong></p><pre><code class="cpp">struct __block_impl {void *isa;int Flags;int Reserved;void *FuncPtr;}</code></pre><p>可以看到，结构体中有isa指针,Block的实质是与OC中常见objc_object结构体类似,由此可见<strong>Block在OC中是作为对象存在</strong>。<br><a href="https://onlyangelia.github.io/Objective-C/blocknature/">Block实质详解</a></p><h1 id="Block类型及内存区域"><a href="#Block类型及内存区域" class="headerlink" title="Block类型及内存区域"></a>Block类型及内存区域</h1><p>在Block实质中，我们探究到了Block的最原始结构，那么Block<br>有哪几种类型呢，接下来看Block结构体中的<strong>isa指针</strong>。<br>在编译后的cpp文件中，我们可以看到构造函数中会有如下赋值</p><pre><code class="cpp">__BlockObject__init_block_impl_0(void *fp, struct __BlockObject__init_block_desc_0 *desc, int flags=0) {    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }</code></pre><p>可以看到 <code>**impl.isa = &amp;_NSConcreteStackBlock**</code>,<code>_NSConcreteStackBlock</code>就代表了Block类型。<br>类似_NSConcreteStackBlock这样的结构还有以下几种</p><p>|类型|查看源|存储区域<br>_NSConcreteGlobalBlock    | .cpp文件/Block.h | 全局变量/静态变量区<br>_NSConcreteStackBlock      | .cpp文件/Block.h|栈区<br>_NSConcreteMallocBlock     |Block_private.h文件|堆区<br>_NSConcreteAutoBlock |Block_private.h文件|堆区<br>_NSConcreteFinalizingBlock |Block_private.h文件|堆区<br>_NSConcreteWeakBlockVariable |Block_private.h文件|堆区</p><p>通过编译后cpp文件以及查看runtime中与Block相关文件，找到以上六种类型。我们创建的Block默认赋值的isa指针会有<code>_NSConcreteGlobalBlock</code>和<code>_NSConcreteStackBlock 两种类型，</code>，其它四种是在运行期间，编译器根据情况生成。<br>有关各Block类型、存储区域 以及各类型和存储区域和各种场景的对应详情点击<br> <a href="https://onlyangelia.github.io/Objective-C/blockmemory/">Block类型及内存区域</a></p><h1 id="Block截获变量"><a href="#Block截获变量" class="headerlink" title="Block截获变量"></a>Block截获变量</h1><p>使用Block期间，不可避免要使用一些外部变量或全局变量以及对象等。而Block对于引用的变量或对象有自动截获的能力。对于Global、Stack、Malloc 类型的Block都有自动截获的能力，但对于不同的变量或者是在不同情况下，Block截获变量会出现以下情况：<br>1.截获变量的值<br>2.截获变量的指针<br>3.将变量拷贝到堆区域，并持有变量<br>对于每种情况的具体分析，详见<a href="https://onlyangelia.github.io/Objective-C/blockbrief/">《Block自动截获变量》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Block&lt;/strong&gt;可能已经是被大家讨论的滚瓜烂熟的话题了，却经久不衰。总结这篇文章的起因是在一个开发群里许多iOSer咨询block问题，于是写该系列Block文章系统梳理一下有关Block的知识体系。该系列文章会从&lt;code&gt;Block实质&lt;/c
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://onlyangelia.github.io/categories/Objective-C/"/>
    
    
      <category term="Block" scheme="https://onlyangelia.github.io/tags/Block/"/>
    
  </entry>
  
</feed>
