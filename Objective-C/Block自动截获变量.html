<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Block自动截获变量 | 温凉</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="喜欢OC，目前是一名iOS编程人员；在Python进修的路上">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Block自动截获变量 | 温凉">
    <meta name="twitter:description" content="喜欢OC，目前是一名iOS编程人员；在Python进修的路上">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Block自动截获变量 | 温凉">
    <meta property="og:description" content="喜欢OC，目前是一名iOS编程人员；在Python进修的路上">

    
    <meta name="author" content="温凉">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://lanjiying.allenqin.com/Objective-C/Block自动截获变量.html"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 温凉 的主页"><img src="/images/avatar.jpg" width="80" alt="温凉 logo" class="panel-cover__logo logo"></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 温凉">温凉</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">不念过往、不负当下、不畏将来</span>
        
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">喜欢OC，目前是一名iOS编程人员；在Python进修的路上</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="/Objective-C">Objective-C</a></li>
            
              <li class="navigation__item"><a href="/aboutMe">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/u/2683037683" title="Weibo" target="_blank">
      <i class="social fa fa-weibo"></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/onlyAngelia" title="GitHub" target="_blank">
      <i class="social fa fa-github"></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <h1 class="post-title">Block自动截获变量</h1>
  </header>

  <section class="post">
    <p><a href="https://onlyangelia.github.io/2018/04/06/Block前言/" target="_blank" rel="noopener">《Block前言》</a>中讲到，不论何种类型的Block都自带截获变量这一技能，而针对不同的变量类型和不同的情况，自动截获分为以下情况</p>
<p><strong><br>1.截获变量的值<br>2.截获对象,将对象指针传递进去<br>3.将变量拷贝到堆区域，并持有变量<br>4.截获变量内存地址
</strong><br>现针对以上内容进行详细分析。</p>
<h1 id="截获变量的值"><a href="#截获变量的值" class="headerlink" title="截获变量的值"></a>截获变量的值</h1><p>这一情况主要发生在<br>1.<strong>对基本数据类型的引用</strong>（局部参数）<br>其实说白了，对于所有类型，Block自动截获的皆为在Block截获之前的变量的瞬间值，唯一不同的是如果是Object类型，Block会多一步copy操作。先来看基本数据常量</p>
<pre><code>int a = 0;
void (^lockBlock)(void) = ^{
        NSLog(@&quot;a = %d&quot;,a);
};
++a;
lockBlock();
NSLog(@&quot;%@&quot;, lockBlock);
</code></pre><p>以上代码最后输出</p>
<pre><code>YAObjectTest[7397:1142111] a = 0
 YAObjectTest[7397:1142111] &lt;__NSMallocBlock__: 0x604000443e10&gt;
</code></pre><p>发现a的值在执行block之前做了修改，执行block后获取到的还是a的原来值。<br>查看编译后的cpp文件</p>
<pre><code>void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__testBlockAutomaticInterceptVar_block_impl_0((void *)__BlockObject__testBlockAutomaticInterceptVar_block_func_0, &amp;__BlockObject__testBlockAutomaticInterceptVar_block_desc_0_DATA, a));
</code></pre><p>可以看到传入lockBlock结构体中的仅有a的值，再看_block_impl_0中</p>
<pre><code>struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0
{
  struct __block_impl impl;
  struct __BlockObject__testBlockAutomaticInterceptVar_block_desc_0* Desc;
  int a;
  __BlockObject__testBlockAutomaticInterceptVar_block_impl_0(void *fp, struct __BlockObject__testBlockAutomaticInterceptVar_block_desc_0 *desc, int _a, int flags=0) : a(_a) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
</code></pre><p>该部分的第五行<code>int a；</code>可以明确的看到a 是值的形式存在。</p>
<p>为何会是引入a的值而不是a的内存地址呢？主要原因是<strong>int a 和LockBlock的存储区域不同，因int a = 0的声明是在函数内，所以是在栈区，而lockBlock在引用了局部变量后转换为MallocBlock存放在堆区</strong>。</p>
<p>在上述Block的实现函数<code>__BlockObject__testBlockAutomaticInterceptVar_block_func_0</code>中，我们可以看到如下部分</p>
<pre><code>int a = __cself-&gt;a; // bound by copy
</code></pre><p>系统自动给我们加上了注释，<code>bound by copy</code>，变量<code>int a</code> ，是用 <code>__cself-&gt;</code> 来访问的,Block仅仅捕获了 <code>a</code> 的值，并没有捕获<code>a</code>的内存地址。<br>所以在testBlockAutomaticInterceptVar`这个函数中后来即使我们重写int a 的值，依旧无法去改变Block外面变量a的值</p>
<hr>
<hr>
<p>也正是基于以上原因，我们无法在Block内部更改自动截获的变量，更改截获的自动变量编译器会报以下错误</p>
<pre><code>Variable is not assignable (missing __block type specifier)
</code></pre><p>变量无法在Block中改变外部变量的值，所以编译过程中就报编译错误</p>
<hr>
<hr>
<h1 id="截获对象-将对象指针传递进去，并持有变量"><a href="#截获对象-将对象指针传递进去，并持有变量" class="headerlink" title="截获对象,将对象指针传递进去，并持有变量"></a>截获对象,将对象指针传递进去，并持有变量</h1><p>相比较于基本数据常量而言，Block截获Object上，会有区分，Block截获的是对象，传入的是对象的指针，但是会多传入一部分内容，而且会多一步copy操作</p>
<pre><code> NSString *testString = @&quot;It is just a joke&quot;;
 void (^lockBlock)(void) = ^{
        [testString stringByAppendingString:@&quot;Yeah, I&#39;m sure&quot;];
  };
   lockBlock();
  NSLog(@&quot;%@&quot;,testString);
  NSLog(@&quot;%@&quot;, lockBlock);
</code></pre><p>用以上OC代码运行会发现testString的内存地址是一样的<code>&lt;__NSArrayM 0x604000240090&gt;</code>，同样不能在Block内部进行初始化操作（因为重新初始化Block内部的引用对象内存地址会发生变化这是不允许的）。</p>
<p>查看clang后的cpp文件，我们发现lockBlock声明赋值的部分编译后的代码如下</p>
<pre><code>void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__testBlockAutomaticInterceptVar_block_impl_0((void *)__BlockObject__testBlockAutomaticInterceptVar_block_func_0, &amp;__BlockObject__testBlockAutomaticInterceptVar_block_desc_0_DATA, testString, 570425344));
</code></pre><p>相比较于基本数据常量而言，<strong>传递参数多了后面的<code>570425344</code>（这一部分后面探讨）</strong>。其它和基本数据类型一样，直接以<code>NSString *testString;</code>出现在<code>__BlockObject__testBlockAutomaticInterceptVar_block_impl_0</code>结构体中，在<code>__BlockObject__testBlockAutomaticInterceptVar_block_func_0</code>结构体中以<br><code>NSString *testString = __cself-&gt;testString; // bound by copy</code>——cself-&gt; 形式调用。</p>
<p>引用对象不同的是会多出来以下函数</p>
<pre><code>static void __BlockObject__testBlockAutomaticInterceptVar_block_copy_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*dst, struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;testString, (void*)src-&gt;testString, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __BlockObject__testBlockAutomaticInterceptVar_block_dispose_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;testString, 3/*BLOCK_FIELD_IS_OBJECT*/);}
</code></pre><p>在编译文件中看到引用对象时有_block_copy  和 _block_dispose函数。这两个函数的作用相当于内存管理MRC中的copy 和 release操作，调用_block_copy将引用对象进行copy操作，调用_block_dispose相当于对testString 进行release操作。<br>copy具体的执行操作是申请内存，将栈数据复制过去，将Class改一下，最后向捕获到的对象发送retain，增加block的引用计数，dispose函数正好相反。<br>copy和dsipose函数中最后一个参数代表截获的参数类型，3 代表是Block，编译后的代码中注释了BLOCK_FIELD_IS_OBJECT，其它形式如下<br>.BLOCK_FIELD_IS_BLOCK；<br>.BLOCK_FIELD_IS_WEAK;<br>.BLOCK_BYREF_CALLER<br>.BLOCK_FIELD_IS_BYREF</p>
<p>与截获基本数据类型相同，截获对象传递的是指针，所以在Block内不能再对对象进行初始化，但其本身自带的方法可以调用，MallocBlock会持有引用的变量。</p>
<p>#变量拷贝到堆区域，并持有变量<br>.__block 修饰符修饰</p>
<p>#<strong>block<br>对于对象，Block引用内部可以进行操作不能初始化，但对于基本数据类型如何进行更改呢，这个时候会用到`</strong>block`修饰符。该修饰符的主要作用是将基本数据常量写入结构体转变为对象，copy到堆上，持有变量。来看下代码和转换后的代码</p>
<pre><code> __block int a = 0;
 void (^lockBlock)(void) = ^{
      a = 2;
 };
</code></pre><p>编译后的代码</p>
<pre><code>__attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 0};
  void (*lockBlock)(void) = ((void (*)())&amp;__BlockObject__testBlockAutomaticInterceptVar_block_impl_0((void *)__BlockObject__testBlockAutomaticInterceptVar_block_func_0, &amp;__BlockObject__testBlockAutomaticInterceptVar_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));
</code></pre><p>可以看到int a 被转换为<code>_blocks__(byref）</code>类型，在Block使用时传入的<code>(__Block_byref_a_0 *)&amp;a</code>，而具体的a被转换后的结构体，</p>
<pre><code>struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 int a;
};
</code></pre><p>和对象的结构体一样包含isa指针，并且还有一个<strong>forwarding指针，flags、size、和一个int a 。此时，发现int a作为结构体成员，而</strong>forwarding指针是指向其本身，这就保证了被拷贝到堆区之后依然能够找到该变量。<br>将参数转变成对象之后，其也会增加</p>
<pre><code>static void __BlockObject__testBlockAutomaticInterceptVar_block_copy_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*dst, struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __BlockObject__testBlockAutomaticInterceptVar_block_dispose_0(struct __BlockObject__testBlockAutomaticInterceptVar_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}
</code></pre><p>copy和dispose函数的最后一个参数变为8，意味截获的变量是<strong>block转换来的。<br>具体的关于copy和dispose 可以祥见[霜神博客《深入研究Block捕获外部变量和</strong>block实现原理》第二部分Block的copy和dispose](<a href="https://www.jianshu.com/p/ee9756f3d5f6" target="_blank" rel="noopener">https://www.jianshu.com/p/ee9756f3d5f6</a>)</p>
<p>#截获内存地址<br>.对于静态变量，全局变量，Block截获的是内存地址，在Block内部可以直接修改值。<br>主要因为静态变量和全局变量的存储区域并不会发生改变，所以在Block截获时引用的是其内存地址，修改后仍旧是存储在静态区</p>
<pre><code>static int count = 100;
 typedef int (^blockStatic)(void);
 blockStatic blk = ^(){
    count = 1000;
   return count;
  };
</code></pre><p>转换后的函数实现如下</p>
<pre><code>static int __BlockObject__testBlockKinds_block_func_0(struct __BlockObject__testBlockKinds_block_impl_0 *__cself) {
        count = 1000;
        return count;
  }
</code></pre><p>在Block内部直接可以修改count的值，对count的引用直接获取的内存地址，且在__block _impl 结构体中并没有将count值引用或copy。</p>
<p>#结尾补充：”570425344”代表啥？<br>细心的大佬们肯定发现了在Block语法转换时候，若引用的是对象，则后面必跟一个数字<strong>570425344</strong> ，且不管是不同项目、不同类、不同Block，这个数值是固定的。为了这个问题也困惑了好久，开始以为这就是一个判断是否是对象的枚举类型。最后特不好意思的咨询霜大神，醍醐灌顶。可能和霜神之间隔了570425344光年的距离，这距离差在解决问题的思路和办法上，我是一直在编译后的cpp文件中查看，发现并没有解释，只能通过尝试来得出一个猜想。霜神是直接将这串数次Google ，而Google 告诉我们了答案（虽然这答案未必准备，但比我的想法好多了）。</p>
<pre><code>myBlock-&gt;impl.isa = &amp;_NSConcreteStackBlock;
myBlock-&gt;impl.Flags = 570425344;
</code></pre><p><code>570425344</code>为Flags的偏移量，这个偏移量是固定的。大家可以自己代码运行下查看GlobalBlock的Flags为10位数正数，StackBlock和MallocBlock的Flags为10位数负数，<br>这里暂时将”<code>570425344&quot;</code>理解为Flags的偏移量，若有大佬知道确切答案，希望能不吝赐教</p>

  </section>
</article>



            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2019 温凉 - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
  
         <script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    }); 
    
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
   
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
